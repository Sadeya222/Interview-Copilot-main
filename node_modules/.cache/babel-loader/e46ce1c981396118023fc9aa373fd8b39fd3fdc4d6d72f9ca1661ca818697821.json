{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Stream } from \"./Exports.js\";\nexport class ChunkedArrayBufferStream extends Stream {\n  constructor(targetChunkSize, streamId) {\n    super(streamId);\n    this.privTargetChunkSize = targetChunkSize;\n    this.privNextBufferReadyBytes = 0;\n  }\n  writeStreamChunk(chunk) {\n    // No pending write, and the buffer is the right size so write it.\n    if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) {\n      super.writeStreamChunk(chunk);\n      return;\n    }\n    let bytesCopiedFromBuffer = 0;\n    while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\n      // Fill the next buffer.\n      if (undefined === this.privNextBufferToWrite) {\n        this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\n        this.privNextBufferStartTime = chunk.timeReceived;\n      }\n      // Find out how many bytes we can copy into the read buffer.\n      const bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\n      const targetView = new Uint8Array(this.privNextBufferToWrite);\n      const sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\n      targetView.set(sourceView, this.privNextBufferReadyBytes);\n      this.privNextBufferReadyBytes += bytesToCopy;\n      bytesCopiedFromBuffer += bytesToCopy;\n      // Are we ready to write?\n      if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\n        super.writeStreamChunk({\n          buffer: this.privNextBufferToWrite,\n          isEnd: false,\n          timeReceived: this.privNextBufferStartTime\n        });\n        this.privNextBufferReadyBytes = 0;\n        this.privNextBufferToWrite = undefined;\n      }\n    }\n  }\n  close() {\n    // Send whatever is pending, then close the base class.\n    if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\n      super.writeStreamChunk({\n        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\n        isEnd: false,\n        timeReceived: this.privNextBufferStartTime\n      });\n    }\n    super.close();\n  }\n}","map":{"version":3,"names":["Stream","ChunkedArrayBufferStream","constructor","targetChunkSize","streamId","privTargetChunkSize","privNextBufferReadyBytes","writeStreamChunk","chunk","isEnd","buffer","byteLength","bytesCopiedFromBuffer","undefined","privNextBufferToWrite","ArrayBuffer","privNextBufferStartTime","timeReceived","bytesToCopy","Math","min","targetView","Uint8Array","sourceView","slice","set","close","isClosed"],"sources":["src/common/ChunkedArrayBufferStream.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { IStreamChunk, Stream } from \"./Exports.js\";\r\n\r\nexport class ChunkedArrayBufferStream extends Stream<ArrayBuffer> {\r\n    private privTargetChunkSize: number;\r\n    private privNextBufferToWrite: ArrayBuffer;\r\n    private privNextBufferStartTime: number;\r\n    private privNextBufferReadyBytes: number;\r\n\r\n    public constructor(targetChunkSize: number, streamId?: string) {\r\n        super(streamId);\r\n        this.privTargetChunkSize = targetChunkSize;\r\n        this.privNextBufferReadyBytes = 0;\r\n    }\r\n\r\n    public writeStreamChunk(chunk: IStreamChunk<ArrayBuffer>): void {\r\n        // No pending write, and the buffer is the right size so write it.\r\n        if (chunk.isEnd ||\r\n            (0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize)) {\r\n            super.writeStreamChunk(chunk);\r\n            return;\r\n        }\r\n\r\n        let bytesCopiedFromBuffer: number = 0;\r\n\r\n        while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\r\n            // Fill the next buffer.\r\n            if (undefined === this.privNextBufferToWrite) {\r\n                this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\r\n                this.privNextBufferStartTime = chunk.timeReceived;\r\n            }\r\n\r\n            // Find out how many bytes we can copy into the read buffer.\r\n            const bytesToCopy: number = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\r\n            const targetView: Uint8Array = new Uint8Array(this.privNextBufferToWrite);\r\n            const sourceView: Uint8Array = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\r\n\r\n            targetView.set(sourceView, this.privNextBufferReadyBytes);\r\n            this.privNextBufferReadyBytes += bytesToCopy;\r\n            bytesCopiedFromBuffer += bytesToCopy;\r\n\r\n            // Are we ready to write?\r\n            if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\r\n                super.writeStreamChunk({\r\n                    buffer: this.privNextBufferToWrite,\r\n                    isEnd: false,\r\n                    timeReceived: this.privNextBufferStartTime,\r\n                });\r\n                this.privNextBufferReadyBytes = 0;\r\n                this.privNextBufferToWrite = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    public close(): void {\r\n        // Send whatever is pending, then close the base class.\r\n        if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\r\n            super.writeStreamChunk({\r\n                buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\r\n                isEnd: false,\r\n                timeReceived: this.privNextBufferStartTime,\r\n            });\r\n        }\r\n\r\n        super.close();\r\n    }\r\n}\r\n"],"mappings":";;;AAAA;AACA;AAEA,SAAuBA,MAAM,QAAQ,cAAc;AAEnD,OAAM,MAAOC,wBAAyB,SAAQD,MAAmB;EAM7DE,YAAmBC,eAAuB,EAAEC,QAAiB;IACzD,KAAK,CAACA,QAAQ,CAAC;IACf,IAAI,CAACC,mBAAmB,GAAGF,eAAe;IAC1C,IAAI,CAACG,wBAAwB,GAAG,CAAC;EACrC;EAEOC,gBAAgBA,CAACC,KAAgC;IACpD;IACA,IAAIA,KAAK,CAACC,KAAK,IACV,CAAC,KAAK,IAAI,CAACH,wBAAwB,IAAIE,KAAK,CAACE,MAAM,CAACC,UAAU,KAAK,IAAI,CAACN,mBAAoB,EAAE;MAC/F,KAAK,CAACE,gBAAgB,CAACC,KAAK,CAAC;MAC7B;;IAGJ,IAAII,qBAAqB,GAAW,CAAC;IAErC,OAAOA,qBAAqB,GAAGJ,KAAK,CAACE,MAAM,CAACC,UAAU,EAAE;MACpD;MACA,IAAIE,SAAS,KAAK,IAAI,CAACC,qBAAqB,EAAE;QAC1C,IAAI,CAACA,qBAAqB,GAAG,IAAIC,WAAW,CAAC,IAAI,CAACV,mBAAmB,CAAC;QACtE,IAAI,CAACW,uBAAuB,GAAGR,KAAK,CAACS,YAAY;;MAGrD;MACA,MAAMC,WAAW,GAAWC,IAAI,CAACC,GAAG,CAACZ,KAAK,CAACE,MAAM,CAACC,UAAU,GAAGC,qBAAqB,EAAE,IAAI,CAACP,mBAAmB,GAAG,IAAI,CAACC,wBAAwB,CAAC;MAC/I,MAAMe,UAAU,GAAe,IAAIC,UAAU,CAAC,IAAI,CAACR,qBAAqB,CAAC;MACzE,MAAMS,UAAU,GAAe,IAAID,UAAU,CAACd,KAAK,CAACE,MAAM,CAACc,KAAK,CAACZ,qBAAqB,EAAEM,WAAW,GAAGN,qBAAqB,CAAC,CAAC;MAE7HS,UAAU,CAACI,GAAG,CAACF,UAAU,EAAE,IAAI,CAACjB,wBAAwB,CAAC;MACzD,IAAI,CAACA,wBAAwB,IAAIY,WAAW;MAC5CN,qBAAqB,IAAIM,WAAW;MAEpC;MACA,IAAI,IAAI,CAACZ,wBAAwB,KAAK,IAAI,CAACD,mBAAmB,EAAE;QAC5D,KAAK,CAACE,gBAAgB,CAAC;UACnBG,MAAM,EAAE,IAAI,CAACI,qBAAqB;UAClCL,KAAK,EAAE,KAAK;UACZQ,YAAY,EAAE,IAAI,CAACD;SACtB,CAAC;QACF,IAAI,CAACV,wBAAwB,GAAG,CAAC;QACjC,IAAI,CAACQ,qBAAqB,GAAGD,SAAS;;;EAGlD;EAEOa,KAAKA,CAAA;IACR;IACA,IAAI,CAAC,KAAK,IAAI,CAACpB,wBAAwB,IAAI,CAAC,IAAI,CAACqB,QAAQ,EAAE;MACvD,KAAK,CAACpB,gBAAgB,CAAC;QACnBG,MAAM,EAAE,IAAI,CAACI,qBAAqB,CAACU,KAAK,CAAC,CAAC,EAAE,IAAI,CAAClB,wBAAwB,CAAC;QAC1EG,KAAK,EAAE,KAAK;QACZQ,YAAY,EAAE,IAAI,CAACD;OACtB,CAAC;;IAGN,KAAK,CAACU,KAAK,EAAE;EACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}