{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ReplayableAudioNode } from \"../common.browser/Exports.js\";\nimport { Deferred, MessageType } from \"../common/Exports.js\";\nimport { CancellationErrorCode, CancellationReason, SpeakerRecognitionResult, PropertyCollection, PropertyId, ResultReason, SessionEventArgs } from \"../sdk/Exports.js\";\nimport { CancellationErrorCodePropertyName, ServiceRecognizerBase } from \"./Exports.js\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\n// eslint-disable-next-line max-classes-per-file\nexport class SpeakerServiceRecognizer extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.privSpeakerRecognizer = recognizer;\n    this.privSpeakerAudioSource = audioSource;\n    this.recognizeSpeaker = model => this.recognizeSpeakerOnce(model);\n    this.sendPrePayloadJSONOverride = () => this.noOp();\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    let processed = false;\n    const resultProps = new PropertyCollection();\n    if (connectionMessage.messageType === MessageType.Text) {\n      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speaker.response\":\n        const response = JSON.parse(connectionMessage.textBody);\n        let result;\n        if (response.status.statusCode.toLowerCase() !== \"success\") {\n          result = new SpeakerRecognitionResult(response, ResultReason.Canceled, CancellationErrorCode.ServiceError, response.status.reason);\n        } else {\n          result = new SpeakerRecognitionResult(response, ResultReason.RecognizedSpeaker);\n        }\n        if (!!this.privResultDeferral) {\n          this.privResultDeferral.resolve(result);\n        }\n        processed = true;\n        break;\n      default:\n        break;\n    }\n    const defferal = new Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n    if (!!this.privResultDeferral) {\n      const result = new SpeakerRecognitionResult({\n        scenario: this.privSpeakerModel.scenario,\n        status: {\n          statusCode: error,\n          reason: error\n        }\n      }, ResultReason.Canceled, errorCode, error);\n      try {\n        this.privResultDeferral.resolve(result);\n      } catch (error) {\n        this.privResultDeferral.reject(error);\n      }\n    }\n  }\n  recognizeSpeakerOnce(model) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privSpeakerModel = model;\n      this.voiceProfileType = model.scenario;\n      if (!this.privResultDeferral) {\n        this.privResultDeferral = new Deferred();\n      }\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);\n      this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      const conPromise = this.connectImpl();\n      const preAudioPromise = this.sendPreAudioMessages(this.extractSpeakerContext(model));\n      const node = yield this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);\n      const format = yield this.privSpeakerAudioSource.format;\n      const deviceInfo = yield this.privSpeakerAudioSource.deviceInfo;\n      const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\n      yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n        source: deviceInfo\n      };\n      try {\n        yield conPromise;\n        yield preAudioPromise;\n      } catch (err) {\n        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, err);\n      }\n      const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n      void this.receiveMessage();\n      const audioSendPromise = this.sendAudio(audioNode);\n      // /* eslint-disable no-empty */\n      audioSendPromise.then(() => {}, error => {\n        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      });\n      return this.privResultDeferral.promise;\n    });\n  }\n  sendPreAudioMessages(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      yield this.sendSpeakerRecognition(connection, context);\n      // await this.sendWaveHeader(connection);\n    });\n  }\n\n  sendSpeakerRecognition(connection, context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const speakerContextJson = JSON.stringify(context);\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speaker.context\", this.privRequestSession.requestId, \"application/json; charset=utf-8\", speakerContextJson));\n    });\n  }\n  extractSpeakerContext(model) {\n    return {\n      features: {\n        interimResult: \"enabled\",\n        progressiveDetection: \"disabled\"\n      },\n      profileIds: model.profileIds,\n      scenario: model.scenario\n    };\n  }\n}","map":{"version":3,"names":["ReplayableAudioNode","Deferred","MessageType","CancellationErrorCode","CancellationReason","SpeakerRecognitionResult","PropertyCollection","PropertyId","ResultReason","SessionEventArgs","CancellationErrorCodePropertyName","ServiceRecognizerBase","SpeechConnectionMessage","SpeakerServiceRecognizer","constructor","authentication","connectionFactory","audioSource","recognizerConfig","recognizer","privSpeakerRecognizer","privSpeakerAudioSource","recognizeSpeaker","model","recognizeSpeakerOnce","sendPrePayloadJSONOverride","noOp","processTypeSpecificMessages","connectionMessage","processed","resultProps","messageType","Text","setProperty","SpeechServiceResponse_JsonResult","textBody","path","toLowerCase","response","JSON","parse","result","status","statusCode","Canceled","ServiceError","reason","RecognizedSpeaker","privResultDeferral","resolve","defferal","promise","cancelRecognition","sessionId","requestId","cancellationReason","errorCode","error","properties","scenario","privSpeakerModel","reject","voiceProfileType","privRequestSession","startNewRecognition","listenForServiceTelemetry","events","privRecognizerConfig","parameters","Speech_SessionId","conPromise","connectImpl","preAudioPromise","sendPreAudioMessages","extractSpeakerContext","node","attach","audioNodeId","format","deviceInfo","audioNode","avgBytesPerSec","onAudioSourceAttachCompleted","SpeechServiceConfig","Context","audio","source","err","Error","ConnectionFailure","sessionStartEventArgs","privRecognizer","sessionStarted","receiveMessage","audioSendPromise","sendAudio","then","RuntimeError","context","connection","fetchConnection","sendSpeakerRecognition","speakerContextJson","stringify","send","features","interimResult","progressiveDetection","profileIds"],"sources":["src/common.speech/SpeakerServiceRecognizer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports.js\";\r\nimport {\r\n    Deferred,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    MessageType,\r\n} from \"../common/Exports.js\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat.js\";\r\nimport { SpeakerRecognitionModel } from \"../sdk/SpeakerRecognitionModel.js\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    SpeakerRecognitionResult,\r\n    SpeakerRecognizer,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n} from \"../sdk/Exports.js\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    ISpeechConfigAudioDevice,\r\n    SpeakerResponse,\r\n    ServiceRecognizerBase,\r\n} from \"./Exports.js\";\r\nimport { IAuthentication } from \"./IAuthentication.js\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory.js\";\r\nimport { RecognizerConfig } from \"./RecognizerConfig.js\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\r\n\r\ninterface SpeakerContext {\r\n    scenario: string;\r\n    profileIds: string[];\r\n    features: {\r\n        interimResult: string;\r\n        progressiveDetection: string;\r\n    };\r\n}\r\n\r\n// eslint-disable-next-line max-classes-per-file\r\nexport class SpeakerServiceRecognizer extends ServiceRecognizerBase {\r\n    private privSpeakerRecognizer: SpeakerRecognizer;\r\n    private privSpeakerAudioSource: IAudioSource;\r\n    private privResultDeferral: Deferred<SpeakerRecognitionResult>;\r\n    private privSpeakerModel: SpeakerRecognitionModel;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        recognizer: SpeakerRecognizer) {\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\r\n        this.privSpeakerRecognizer = recognizer;\r\n        this.privSpeakerAudioSource = audioSource;\r\n        this.recognizeSpeaker = (model: SpeakerRecognitionModel): Promise<SpeakerRecognitionResult> => this.recognizeSpeakerOnce(model);\r\n        this.sendPrePayloadJSONOverride = (): Promise<void> => this.noOp();\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        let processed: boolean = false;\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speaker.response\":\r\n                const response: SpeakerResponse = JSON.parse(connectionMessage.textBody) as SpeakerResponse;\r\n                let result: SpeakerRecognitionResult;\r\n                if (response.status.statusCode.toLowerCase() !== \"success\") {\r\n                    result = new SpeakerRecognitionResult(\r\n                        response,\r\n                        ResultReason.Canceled,\r\n                        CancellationErrorCode.ServiceError,\r\n                        response.status.reason\r\n                        );\r\n                } else {\r\n                    result = new SpeakerRecognitionResult(\r\n                        response,\r\n                        ResultReason.RecognizedSpeaker,\r\n                        );\r\n                }\r\n                if (!!this.privResultDeferral) {\r\n                    this.privResultDeferral.resolve(result);\r\n                }\r\n                processed = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        const defferal = new Deferred<boolean>();\r\n        defferal.resolve(processed);\r\n        return defferal.promise;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n        if (!!this.privResultDeferral) {\r\n            const result: SpeakerRecognitionResult = new SpeakerRecognitionResult(\r\n                {\r\n                    scenario: this.privSpeakerModel.scenario,\r\n                    status: { statusCode: error, reason: error }\r\n                },\r\n                ResultReason.Canceled,\r\n                errorCode,\r\n                error\r\n                );\r\n            try {\r\n                this.privResultDeferral.resolve(result);\r\n            } catch (error) {\r\n                this.privResultDeferral.reject(error as string);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async recognizeSpeakerOnce(model: SpeakerRecognitionModel): Promise<SpeakerRecognitionResult> {\r\n        this.privSpeakerModel = model;\r\n        this.voiceProfileType = model.scenario;\r\n        if (!this.privResultDeferral) {\r\n            this.privResultDeferral = new Deferred<SpeakerRecognitionResult>();\r\n        }\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);\r\n\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n\r\n        const preAudioPromise: Promise<void> = this.sendPreAudioMessages(this.extractSpeakerContext(model));\r\n\r\n        const node: IAudioStreamNode = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);\r\n        const format: AudioStreamFormatImpl = await this.privSpeakerAudioSource.format;\r\n        const deviceInfo: ISpeechConfigAudioDevice = await this.privSpeakerAudioSource.deviceInfo;\r\n\r\n        const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\r\n        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        try {\r\n            await conPromise;\r\n            await preAudioPromise;\r\n        } catch (err) {\r\n            this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, err as string);\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        void this.receiveMessage();\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        // /* eslint-disable no-empty */\r\n        audioSendPromise.then((): void => { /* add? return true;*/ }, (error: string): void => {\r\n            this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n\r\n        return this.privResultDeferral.promise;\r\n    }\r\n\r\n    private async sendPreAudioMessages(context: SpeakerContext): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await this.sendSpeakerRecognition(connection, context);\r\n        // await this.sendWaveHeader(connection);\r\n    }\r\n\r\n    private async sendSpeakerRecognition(connection: IConnection, context: SpeakerContext): Promise<void> {\r\n        const speakerContextJson = JSON.stringify(context);\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speaker.context\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json; charset=utf-8\",\r\n            speakerContextJson));\r\n    }\r\n\r\n    private extractSpeakerContext(model: SpeakerRecognitionModel): SpeakerContext {\r\n        return {\r\n            features: {\r\n                interimResult: \"enabled\",\r\n                progressiveDetection: \"disabled\",\r\n            },\r\n            profileIds: model.profileIds,\r\n            scenario: model.scenario,\r\n        };\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}