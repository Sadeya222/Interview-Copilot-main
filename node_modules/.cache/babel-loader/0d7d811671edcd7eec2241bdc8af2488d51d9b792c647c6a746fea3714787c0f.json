{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport * as net from \"net\";\nimport * as tls from \"tls\";\nimport Agent from \"agent-base\";\nimport HttpsProxyAgent from \"https-proxy-agent\";\nimport ws from \"ws\";\nimport { HeaderNames } from \"../common.speech/HeaderNames.js\";\nimport { ArgumentNullError, BackgroundEvent, ConnectionClosedEvent, ConnectionErrorEvent, ConnectionEstablishedEvent, ConnectionMessageReceivedEvent, ConnectionMessageSentEvent, ConnectionOpenResponse, ConnectionStartEvent, ConnectionState, Deferred, Events, EventSource, MessageType, Queue, RawWebsocketMessage } from \"../common/Exports.js\";\nexport class WebsocketMessageAdapter {\n  constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {\n    if (!uri) {\n      throw new ArgumentNullError(\"uri\");\n    }\n    if (!messageFormatter) {\n      throw new ArgumentNullError(\"messageFormatter\");\n    }\n    this.proxyInfo = proxyInfo;\n    this.privConnectionEvents = new EventSource();\n    this.privConnectionId = connectionId;\n    this.privMessageFormatter = messageFormatter;\n    this.privConnectionState = ConnectionState.None;\n    this.privUri = uri;\n    this.privHeaders = headers;\n    this.privEnableCompression = enableCompression;\n    // Add the connection ID to the headers\n    this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\n    this.privLastErrorReceived = \"\";\n  }\n  get state() {\n    return this.privConnectionState;\n  }\n  open() {\n    if (this.privConnectionState === ConnectionState.Disconnected) {\n      return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);\n    }\n    if (this.privConnectionEstablishDeferral) {\n      return this.privConnectionEstablishDeferral.promise;\n    }\n    this.privConnectionEstablishDeferral = new Deferred();\n    this.privCertificateValidatedDeferral = new Deferred();\n    this.privConnectionState = ConnectionState.Connecting;\n    try {\n      if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\n        // Browser handles cert checks.\n        this.privCertificateValidatedDeferral.resolve();\n        this.privWebsocketClient = new WebSocket(this.privUri);\n      } else {\n        const options = {\n          headers: this.privHeaders,\n          perMessageDeflate: this.privEnableCompression\n        };\n        // The ocsp library will handle validation for us and fail the connection if needed.\n        this.privCertificateValidatedDeferral.resolve();\n        options.agent = this.getAgent();\n        // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\n        // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\n        const uri = new URL(this.privUri);\n        let protocol = uri.protocol;\n        if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"wss:\") {\n          protocol = \"https:\";\n        } else if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"ws:\") {\n          protocol = \"http:\";\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        options.agent.protocol = protocol;\n        this.privWebsocketClient = new ws(this.privUri, options);\n      }\n      this.privWebsocketClient.binaryType = \"arraybuffer\";\n      this.privReceivingMessageQueue = new Queue();\n      this.privDisconnectDeferral = new Deferred();\n      this.privSendMessageQueue = new Queue();\n      this.processSendQueue().catch(reason => {\n        Events.instance.onEvent(new BackgroundEvent(reason));\n      });\n    } catch (error) {\n      this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\n      return this.privConnectionEstablishDeferral.promise;\n    }\n    this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\n    this.privWebsocketClient.onopen = () => {\n      this.privCertificateValidatedDeferral.promise.then(() => {\n        this.privConnectionState = ConnectionState.Connected;\n        this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\n        this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\n      }, error => {\n        this.privConnectionEstablishDeferral.reject(error);\n      });\n    };\n    this.privWebsocketClient.onerror = e => {\n      this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\n      this.privLastErrorReceived = e.message;\n    };\n    this.privWebsocketClient.onclose = e => {\n      if (this.privConnectionState === ConnectionState.Connecting) {\n        this.privConnectionState = ConnectionState.Disconnected;\n        // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\n        this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\n      } else {\n        this.privConnectionState = ConnectionState.Disconnected;\n        this.privWebsocketClient = null;\n        this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\n      }\n      this.onClose(e.code, e.reason).catch(reason => {\n        Events.instance.onEvent(new BackgroundEvent(reason));\n      });\n    };\n    this.privWebsocketClient.onmessage = e => {\n      const networkReceivedTime = new Date().toISOString();\n      if (this.privConnectionState === ConnectionState.Connected) {\n        const deferred = new Deferred();\n        // let id = ++this.idCounter;\n        this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\n        if (e.data instanceof ArrayBuffer) {\n          const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\n          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n            deferred.resolve(connectionMessage);\n          }, error => {\n            // TODO: Events for these ?\n            deferred.reject(`Invalid binary message format. Error: ${error}`);\n          });\n        } else {\n          const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\n          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n            deferred.resolve(connectionMessage);\n          }, error => {\n            // TODO: Events for these ?\n            deferred.reject(`Invalid text message format. Error: ${error}`);\n          });\n        }\n      }\n    };\n    return this.privConnectionEstablishDeferral.promise;\n  }\n  send(message) {\n    if (this.privConnectionState !== ConnectionState.Connected) {\n      return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\n    }\n    const messageSendStatusDeferral = new Deferred();\n    const messageSendDeferral = new Deferred();\n    this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\n    this.privMessageFormatter.fromConnectionMessage(message).then(rawMessage => {\n      messageSendDeferral.resolve({\n        Message: message,\n        RawWebsocketMessage: rawMessage,\n        sendStatusDeferral: messageSendStatusDeferral\n      });\n    }, error => {\n      messageSendDeferral.reject(`Error formatting the message. ${error}`);\n    });\n    return messageSendStatusDeferral.promise;\n  }\n  read() {\n    if (this.privConnectionState !== ConnectionState.Connected) {\n      return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);\n    }\n    return this.privReceivingMessageQueue.dequeue();\n  }\n  close(reason) {\n    if (this.privWebsocketClient) {\n      if (this.privConnectionState !== ConnectionState.Disconnected) {\n        this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\n      }\n    } else {\n      return Promise.resolve();\n    }\n    return this.privDisconnectDeferral.promise;\n  }\n  get events() {\n    return this.privConnectionEvents;\n  }\n  sendRawMessage(sendItem) {\n    try {\n      // indicates we are draining the queue and it came with no message;\n      if (!sendItem) {\n        return Promise.resolve();\n      }\n      this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\n      // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\n      if (this.isWebsocketOpen) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\n      } else {\n        return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\n      }\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(`websocket send error: ${e}`);\n    }\n  }\n  onClose(code, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const closeReason = `Connection closed. ${code}: ${reason}`;\n      this.privConnectionState = ConnectionState.Disconnected;\n      this.privDisconnectDeferral.resolve();\n      yield this.privReceivingMessageQueue.drainAndDispose(() => {\n        // TODO: Events for these ?\n        // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\n      }, closeReason);\n      yield this.privSendMessageQueue.drainAndDispose(pendingSendItem => {\n        pendingSendItem.sendStatusDeferral.reject(closeReason);\n      }, closeReason);\n    });\n  }\n  processSendQueue() {\n    return __awaiter(this, void 0, void 0, function* () {\n      while (true) {\n        const itemToSend = this.privSendMessageQueue.dequeue();\n        const sendItem = yield itemToSend;\n        // indicates we are draining the queue and it came with no message;\n        if (!sendItem) {\n          return;\n        }\n        try {\n          yield this.sendRawMessage(sendItem);\n          sendItem.sendStatusDeferral.resolve();\n        } catch (sendError) {\n          sendItem.sendStatusDeferral.reject(sendError);\n        }\n      }\n    });\n  }\n  onEvent(event) {\n    this.privConnectionEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getAgent() {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const agent = new Agent.Agent(this.createConnection);\n    if (this.proxyInfo !== undefined && this.proxyInfo.HostName !== undefined && this.proxyInfo.Port > 0) {\n      agent.proxyInfo = this.proxyInfo;\n    }\n    return agent;\n  }\n  static GetProxyAgent(proxyInfo) {\n    const httpProxyOptions = {\n      host: proxyInfo.HostName,\n      port: proxyInfo.Port\n    };\n    if (!!proxyInfo.UserName) {\n      httpProxyOptions.headers = {\n        \"Proxy-Authentication\": \"Basic \" + new Buffer(`${proxyInfo.UserName}:${proxyInfo.Password === undefined ? \"\" : proxyInfo.Password}`).toString(\"base64\")\n      };\n    } else {\n      httpProxyOptions.headers = {};\n    }\n    httpProxyOptions.headers.requestOCSP = \"true\";\n    const httpProxyAgent = new HttpsProxyAgent(httpProxyOptions);\n    return httpProxyAgent;\n  }\n  createConnection(request, options) {\n    let socketPromise;\n    options = Object.assign(Object.assign({}, options), {\n      requestOCSP: true,\n      servername: options.host\n    });\n    if (!!this.proxyInfo) {\n      const httpProxyAgent = WebsocketMessageAdapter.GetProxyAgent(this.proxyInfo);\n      const baseAgent = httpProxyAgent;\n      socketPromise = new Promise((resolve, reject) => {\n        baseAgent.callback(request, options, (error, socket) => {\n          if (!!error) {\n            reject(error);\n          } else {\n            resolve(socket);\n          }\n        });\n      });\n    } else {\n      if (!!options.secureEndpoint) {\n        socketPromise = Promise.resolve(tls.connect(options));\n      } else {\n        socketPromise = Promise.resolve(net.connect(options));\n      }\n    }\n    return socketPromise;\n  }\n  get isWebsocketOpen() {\n    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\n  }\n}\nWebsocketMessageAdapter.forceNpmWebSocket = false;","map":{"version":3,"names":["net","tls","Agent","HttpsProxyAgent","ws","HeaderNames","ArgumentNullError","BackgroundEvent","ConnectionClosedEvent","ConnectionErrorEvent","ConnectionEstablishedEvent","ConnectionMessageReceivedEvent","ConnectionMessageSentEvent","ConnectionOpenResponse","ConnectionStartEvent","ConnectionState","Deferred","Events","EventSource","MessageType","Queue","RawWebsocketMessage","WebsocketMessageAdapter","constructor","uri","connectionId","messageFormatter","proxyInfo","headers","enableCompression","privConnectionEvents","privConnectionId","privMessageFormatter","privConnectionState","None","privUri","privHeaders","privEnableCompression","ConnectionId","privLastErrorReceived","state","open","Disconnected","Promise","reject","privConnectionEstablishDeferral","promise","privCertificateValidatedDeferral","Connecting","WebSocket","forceNpmWebSocket","resolve","privWebsocketClient","options","perMessageDeflate","agent","getAgent","URL","protocol","toLocaleLowerCase","binaryType","privReceivingMessageQueue","privDisconnectDeferral","privSendMessageQueue","processSendQueue","catch","reason","instance","onEvent","error","onopen","then","Connected","onerror","e","message","type","onclose","code","onClose","onmessage","networkReceivedTime","Date","toISOString","deferred","enqueueFromPromise","data","ArrayBuffer","rawMessage","Binary","toConnectionMessage","connectionMessage","Text","send","messageSendStatusDeferral","messageSendDeferral","fromConnectionMessage","Message","sendStatusDeferral","read","dequeue","close","events","sendRawMessage","sendItem","isWebsocketOpen","payload","id","Error","stack","closeReason","drainAndDispose","pendingSendItem","itemToSend","sendError","event","createConnection","undefined","HostName","Port","GetProxyAgent","httpProxyOptions","host","port","UserName","Buffer","Password","toString","requestOCSP","httpProxyAgent","request","socketPromise","Object","assign","servername","baseAgent","callback","socket","secureEndpoint","connect","readyState","OPEN"],"sources":["src/common.browser/WebsocketMessageAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\n// Node.JS specific web socket / browser support.\r\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\nimport * as http from \"http\";\r\nimport * as net from \"net\";\r\nimport * as tls from \"tls\";\r\nimport Agent from \"agent-base\";\r\nimport HttpsProxyAgent from \"https-proxy-agent\";\r\n\r\nimport ws from \"ws\";\r\nimport { HeaderNames } from \"../common.speech/HeaderNames.js\";\r\nimport {\r\n    ArgumentNullError,\r\n    BackgroundEvent,\r\n    ConnectionClosedEvent,\r\n    ConnectionErrorEvent,\r\n    ConnectionEstablishedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    ConnectionOpenResponse,\r\n    ConnectionStartEvent,\r\n    ConnectionState,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    Queue,\r\n    RawWebsocketMessage,\r\n} from \"../common/Exports.js\";\r\nimport { ProxyInfo } from \"./ProxyInfo.js\";\r\n\r\ninterface ISendItem {\r\n    Message: ConnectionMessage;\r\n    RawWebsocketMessage: RawWebsocketMessage;\r\n    sendStatusDeferral: Deferred<void>;\r\n}\r\n\r\nexport class WebsocketMessageAdapter {\r\n    private privConnectionState: ConnectionState;\r\n    private privMessageFormatter: IWebsocketMessageFormatter;\r\n    private privWebsocketClient: WebSocket | ws;\r\n\r\n    private privSendMessageQueue: Queue<ISendItem>;\r\n    private privReceivingMessageQueue: Queue<ConnectionMessage>;\r\n    private privConnectionEstablishDeferral: Deferred<ConnectionOpenResponse>;\r\n    private privCertificateValidatedDeferral: Deferred<void>;\r\n    private privDisconnectDeferral: Deferred<void>;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privConnectionId: string;\r\n    private privUri: string;\r\n    private proxyInfo: ProxyInfo;\r\n    private privHeaders: { [key: string]: string };\r\n    private privLastErrorReceived: string;\r\n    private privEnableCompression: boolean;\r\n\r\n    public static forceNpmWebSocket: boolean = false;\r\n\r\n    public constructor(\r\n        uri: string,\r\n        connectionId: string,\r\n        messageFormatter: IWebsocketMessageFormatter,\r\n        proxyInfo: ProxyInfo,\r\n        headers: { [key: string]: string },\r\n        enableCompression: boolean) {\r\n\r\n        if (!uri) {\r\n            throw new ArgumentNullError(\"uri\");\r\n        }\r\n\r\n        if (!messageFormatter) {\r\n            throw new ArgumentNullError(\"messageFormatter\");\r\n        }\r\n\r\n        this.proxyInfo = proxyInfo;\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privConnectionId = connectionId;\r\n        this.privMessageFormatter = messageFormatter;\r\n        this.privConnectionState = ConnectionState.None;\r\n        this.privUri = uri;\r\n        this.privHeaders = headers;\r\n        this.privEnableCompression = enableCompression;\r\n\r\n        // Add the connection ID to the headers\r\n        this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\r\n\r\n        this.privLastErrorReceived = \"\";\r\n    }\r\n\r\n    public get state(): ConnectionState {\r\n        return this.privConnectionState;\r\n    }\r\n\r\n    public open(): Promise<ConnectionOpenResponse> {\r\n        if (this.privConnectionState === ConnectionState.Disconnected) {\r\n            return Promise.reject<ConnectionOpenResponse>(`Cannot open a connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        if (this.privConnectionEstablishDeferral) {\r\n            return this.privConnectionEstablishDeferral.promise;\r\n        }\r\n\r\n        this.privConnectionEstablishDeferral = new Deferred<ConnectionOpenResponse>();\r\n        this.privCertificateValidatedDeferral = new Deferred<void>();\r\n\r\n        this.privConnectionState = ConnectionState.Connecting;\r\n\r\n        try {\r\n\r\n            if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\r\n                // Browser handles cert checks.\r\n                this.privCertificateValidatedDeferral.resolve();\r\n\r\n                this.privWebsocketClient = new WebSocket(this.privUri);\r\n            } else {\r\n                const options: ws.ClientOptions = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression };\r\n                // The ocsp library will handle validation for us and fail the connection if needed.\r\n                this.privCertificateValidatedDeferral.resolve();\r\n\r\n                options.agent = this.getAgent();\r\n                // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\r\n                // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\r\n                const uri = new URL(this.privUri);\r\n                let protocol: string = uri.protocol;\r\n\r\n                if (protocol?.toLocaleLowerCase() === \"wss:\") {\r\n                    protocol = \"https:\";\r\n                } else if (protocol?.toLocaleLowerCase() === \"ws:\") {\r\n                    protocol = \"http:\";\r\n                }\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n                (options.agent as any).protocol = protocol;\r\n                this.privWebsocketClient = new ws(this.privUri, options);\r\n            }\r\n\r\n            this.privWebsocketClient.binaryType = \"arraybuffer\";\r\n            this.privReceivingMessageQueue = new Queue<ConnectionMessage>();\r\n            this.privDisconnectDeferral = new Deferred<void>();\r\n            this.privSendMessageQueue = new Queue<ISendItem>();\r\n            this.processSendQueue().catch((reason: string): void => {\r\n                Events.instance.onEvent(new BackgroundEvent(reason));\r\n            });\r\n        } catch (error) {\r\n            this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error as string));\r\n            return this.privConnectionEstablishDeferral.promise;\r\n        }\r\n\r\n        this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\r\n\r\n        this.privWebsocketClient.onopen = (): void => {\r\n            this.privCertificateValidatedDeferral.promise.then((): void => {\r\n                this.privConnectionState = ConnectionState.Connected;\r\n                this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\r\n            }, (error: string): void => {\r\n                this.privConnectionEstablishDeferral.reject(error);\r\n            });\r\n        };\r\n\r\n        this.privWebsocketClient.onerror = (e: { error: any; message: string; type: string; target: WebSocket | ws }): void => {\r\n            this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\r\n            this.privLastErrorReceived = e.message;\r\n        };\r\n\r\n        this.privWebsocketClient.onclose = (e: { wasClean: boolean; code: number; reason: string; target: WebSocket | ws }): void => {\r\n            if (this.privConnectionState === ConnectionState.Connecting) {\r\n                this.privConnectionState = ConnectionState.Disconnected;\r\n                // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\r\n            } else {\r\n                this.privConnectionState = ConnectionState.Disconnected;\r\n                this.privWebsocketClient = null;\r\n                this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\r\n            }\r\n\r\n            this.onClose(e.code, e.reason).catch((reason: string): void => {\r\n                Events.instance.onEvent(new BackgroundEvent(reason));\r\n            });\r\n        };\r\n\r\n        this.privWebsocketClient.onmessage = (e: { data: ws.Data; type: string; target: WebSocket | ws }): void => {\r\n            const networkReceivedTime = new Date().toISOString();\r\n            if (this.privConnectionState === ConnectionState.Connected) {\r\n                const deferred = new Deferred<ConnectionMessage>();\r\n                // let id = ++this.idCounter;\r\n                this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\r\n                if (e.data instanceof ArrayBuffer) {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .then((connectionMessage: ConnectionMessage): void => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string): void => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid binary message format. Error: ${error}`);\r\n                        });\r\n                } else {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .then((connectionMessage: ConnectionMessage): void => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string): void => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid text message format. Error: ${error}`);\r\n                        });\r\n                }\r\n            }\r\n        };\r\n\r\n        return this.privConnectionEstablishDeferral.promise;\r\n    }\r\n\r\n    public send(message: ConnectionMessage): Promise<void> {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\r\n        }\r\n\r\n        const messageSendStatusDeferral = new Deferred<void>();\r\n        const messageSendDeferral = new Deferred<ISendItem>();\r\n\r\n        this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\r\n\r\n        this.privMessageFormatter\r\n            .fromConnectionMessage(message)\r\n            .then((rawMessage: RawWebsocketMessage): void => {\r\n                messageSendDeferral.resolve({\r\n                    Message: message,\r\n                    RawWebsocketMessage: rawMessage,\r\n                    sendStatusDeferral: messageSendStatusDeferral,\r\n                });\r\n            }, (error: string): void => {\r\n                messageSendDeferral.reject(`Error formatting the message. ${error}`);\r\n            });\r\n\r\n        return messageSendStatusDeferral.promise;\r\n    }\r\n\r\n    public read(): Promise<ConnectionMessage> {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return Promise.reject<ConnectionMessage>(`Cannot read on connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        return this.privReceivingMessageQueue.dequeue();\r\n    }\r\n\r\n    public close(reason?: string): Promise<void> {\r\n        if (this.privWebsocketClient) {\r\n            if (this.privConnectionState !== ConnectionState.Disconnected) {\r\n                this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\r\n            }\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return this.privDisconnectDeferral.promise;\r\n    }\r\n\r\n    public get events(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    private sendRawMessage(sendItem: ISendItem): Promise<void> {\r\n        try {\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!sendItem) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\r\n\r\n            // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\r\n            if (this.isWebsocketOpen) {\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\r\n                this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\r\n            } else {\r\n                return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\r\n            }\r\n            return Promise.resolve();\r\n\r\n        } catch (e) {\r\n            return Promise.reject(`websocket send error: ${e as string}`);\r\n        }\r\n    }\r\n\r\n    private async onClose(code: number, reason: string): Promise<void> {\r\n        const closeReason = `Connection closed. ${code}: ${reason}`;\r\n        this.privConnectionState = ConnectionState.Disconnected;\r\n        this.privDisconnectDeferral.resolve();\r\n        await this.privReceivingMessageQueue.drainAndDispose((): void => {\r\n            // TODO: Events for these ?\r\n            // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\r\n        }, closeReason);\r\n\r\n        await this.privSendMessageQueue.drainAndDispose((pendingSendItem: ISendItem): void => {\r\n            pendingSendItem.sendStatusDeferral.reject(closeReason);\r\n        }, closeReason);\r\n    }\r\n\r\n    private async processSendQueue(): Promise<void> {\r\n        while (true) {\r\n            const itemToSend: Promise<ISendItem> = this.privSendMessageQueue.dequeue();\r\n            const sendItem: ISendItem = await itemToSend;\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!sendItem) {\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this.sendRawMessage(sendItem);\r\n                sendItem.sendStatusDeferral.resolve();\r\n            } catch (sendError) {\r\n                sendItem.sendStatusDeferral.reject(sendError as string);\r\n            }\r\n        }\r\n    }\r\n\r\n    private onEvent(event: ConnectionEvent): void {\r\n        this.privConnectionEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private getAgent(): http.Agent {\r\n        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n        const agent: { proxyInfo: ProxyInfo } = new Agent.Agent(this.createConnection) as unknown as { proxyInfo: ProxyInfo } ;\r\n\r\n        if (this.proxyInfo !== undefined &&\r\n            this.proxyInfo.HostName !== undefined &&\r\n            this.proxyInfo.Port > 0) {\r\n            agent.proxyInfo = this.proxyInfo;\r\n        }\r\n\r\n        return agent as unknown as http.Agent;\r\n    }\r\n\r\n    private static GetProxyAgent(proxyInfo: ProxyInfo): HttpsProxyAgent {\r\n        const httpProxyOptions: HttpsProxyAgent.HttpsProxyAgentOptions = {\r\n            host: proxyInfo.HostName,\r\n            port: proxyInfo.Port,\r\n        };\r\n\r\n        if (!!proxyInfo.UserName) {\r\n            httpProxyOptions.headers = {\r\n                \"Proxy-Authentication\": \"Basic \" + new Buffer(`${proxyInfo.UserName}:${(proxyInfo.Password === undefined) ? \"\" : proxyInfo.Password}`).toString(\"base64\"),\r\n            };\r\n        } else {\r\n            httpProxyOptions.headers = {};\r\n        }\r\n\r\n        httpProxyOptions.headers.requestOCSP = \"true\";\r\n\r\n        const httpProxyAgent: HttpsProxyAgent = new HttpsProxyAgent(httpProxyOptions);\r\n        return httpProxyAgent;\r\n    }\r\n\r\n    private createConnection(request: Agent.ClientRequest, options: Agent.RequestOptions): Promise<net.Socket> {\r\n        let socketPromise: Promise<net.Socket>;\r\n\r\n        options = {\r\n            ...options,\r\n            ...{\r\n                requestOCSP: true,\r\n                servername: options.host\r\n            }\r\n        };\r\n\r\n        if (!!this.proxyInfo) {\r\n            const httpProxyAgent: HttpsProxyAgent = WebsocketMessageAdapter.GetProxyAgent(this.proxyInfo);\r\n            const baseAgent: Agent.Agent = httpProxyAgent as unknown as Agent.Agent;\r\n\r\n            socketPromise = new Promise<net.Socket>((resolve: (value: net.Socket) => void, reject: (error: string | Error) => void): void => {\r\n                baseAgent.callback(request, options, (error: Error, socket: net.Socket): void => {\r\n                    if (!!error) {\r\n                        reject(error);\r\n                    } else {\r\n                        resolve(socket);\r\n                    }\r\n                });\r\n            });\r\n        } else {\r\n            if (!!options.secureEndpoint) {\r\n                socketPromise = Promise.resolve(tls.connect(options));\r\n            } else {\r\n                socketPromise = Promise.resolve(net.connect(options));\r\n            }\r\n        }\r\n\r\n        return socketPromise;\r\n    }\r\n\r\n    private get isWebsocketOpen(): boolean {\r\n        return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\r\n    }\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}