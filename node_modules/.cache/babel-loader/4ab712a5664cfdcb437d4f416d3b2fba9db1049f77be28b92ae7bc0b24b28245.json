{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/**\n * String helper functions\n */\nexport class StringUtils {\n  /**\n   * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.\n   * @param format The format string that contains the parts to replace surrounded by {}. For example: \"wss://{region}.cts.speech.microsoft.com\".\n   * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.\n   * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string\n   * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned\n   */\n  static formatString(format, replacements) {\n    if (!format) {\n      return \"\";\n    }\n    if (!replacements) {\n      return format;\n    }\n    let formatted = \"\";\n    let key = \"\";\n    const appendToFormatted = str => {\n      formatted += str;\n    };\n    const appendToKey = str => {\n      key += str;\n    };\n    let appendFunc = appendToFormatted;\n    for (let i = 0; i < format.length; i++) {\n      const c = format[i];\n      const next = i + 1 < format.length ? format[i + 1] : \"\";\n      switch (c) {\n        case \"{\":\n          if (next === \"{\") {\n            appendFunc(\"{\");\n            i++;\n          } else {\n            appendFunc = appendToKey;\n          }\n          break;\n        case \"}\":\n          if (next === \"}\") {\n            appendFunc(\"}\");\n            i++;\n          } else {\n            if (replacements.hasOwnProperty(key)) {\n              formatted += replacements[key];\n            }\n            appendFunc = appendToFormatted;\n            key = \"\";\n          }\n          break;\n        default:\n          appendFunc(c);\n          break;\n      }\n    }\n    return formatted;\n  }\n}","map":{"version":3,"names":["StringUtils","formatString","format","replacements","formatted","key","appendToFormatted","str","appendToKey","appendFunc","i","length","c","next","hasOwnProperty"],"sources":["src/common/StringUtils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { IStringDictionary } from \"./IDictionary.js\";\r\n\r\n/**\r\n * String helper functions\r\n */\r\nexport class StringUtils {\r\n\r\n    /**\r\n     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.\r\n     * @param format The format string that contains the parts to replace surrounded by {}. For example: \"wss://{region}.cts.speech.microsoft.com\".\r\n     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.\r\n     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string\r\n     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned\r\n     */\r\n    public static formatString(format: string, replacements: IStringDictionary<string>): string {\r\n        if (!format) {\r\n            return \"\";\r\n        }\r\n\r\n        if (!replacements) {\r\n            return format;\r\n        }\r\n\r\n        let formatted: string = \"\";\r\n        let key: string = \"\";\r\n\r\n        const appendToFormatted = (str: string): void => {\r\n            formatted += str;\r\n        };\r\n        const appendToKey = (str: string): void => {\r\n            key += str;\r\n        };\r\n        let appendFunc: (str: string) => void = appendToFormatted;\r\n\r\n        for (let i = 0; i < format.length; i++) {\r\n            const c: string = format[i];\r\n            const next: string = i + 1 < format.length ? format[i + 1] : \"\";\r\n\r\n            switch (c) {\r\n                case \"{\":\r\n                    if (next === \"{\") {\r\n                        appendFunc(\"{\");\r\n                        i++;\r\n                    } else {\r\n                        appendFunc = appendToKey;\r\n                    }\r\n                    break;\r\n\r\n                case \"}\":\r\n                    if (next === \"}\") {\r\n                        appendFunc(\"}\");\r\n                        i++;\r\n                    } else {\r\n                        if (replacements.hasOwnProperty(key)) {\r\n                            formatted += replacements[key];\r\n                        }\r\n\r\n                        appendFunc = appendToFormatted;\r\n                        key = \"\";\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    appendFunc(c);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return formatted;\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AAIA;;;AAGA,OAAM,MAAOA,WAAW;EAEpB;;;;;;;EAOO,OAAOC,YAAYA,CAACC,MAAc,EAAEC,YAAuC;IAC9E,IAAI,CAACD,MAAM,EAAE;MACT,OAAO,EAAE;;IAGb,IAAI,CAACC,YAAY,EAAE;MACf,OAAOD,MAAM;;IAGjB,IAAIE,SAAS,GAAW,EAAE;IAC1B,IAAIC,GAAG,GAAW,EAAE;IAEpB,MAAMC,iBAAiB,GAAIC,GAAW,IAAU;MAC5CH,SAAS,IAAIG,GAAG;IACpB,CAAC;IACD,MAAMC,WAAW,GAAID,GAAW,IAAU;MACtCF,GAAG,IAAIE,GAAG;IACd,CAAC;IACD,IAAIE,UAAU,GAA0BH,iBAAiB;IAEzD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,CAACS,MAAM,EAAED,CAAC,EAAE,EAAE;MACpC,MAAME,CAAC,GAAWV,MAAM,CAACQ,CAAC,CAAC;MAC3B,MAAMG,IAAI,GAAWH,CAAC,GAAG,CAAC,GAAGR,MAAM,CAACS,MAAM,GAAGT,MAAM,CAACQ,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE;MAE/D,QAAQE,CAAC;QACL,KAAK,GAAG;UACJ,IAAIC,IAAI,KAAK,GAAG,EAAE;YACdJ,UAAU,CAAC,GAAG,CAAC;YACfC,CAAC,EAAE;WACN,MAAM;YACHD,UAAU,GAAGD,WAAW;;UAE5B;QAEJ,KAAK,GAAG;UACJ,IAAIK,IAAI,KAAK,GAAG,EAAE;YACdJ,UAAU,CAAC,GAAG,CAAC;YACfC,CAAC,EAAE;WACN,MAAM;YACH,IAAIP,YAAY,CAACW,cAAc,CAACT,GAAG,CAAC,EAAE;cAClCD,SAAS,IAAID,YAAY,CAACE,GAAG,CAAC;;YAGlCI,UAAU,GAAGH,iBAAiB;YAC9BD,GAAG,GAAG,EAAE;;UAEZ;QAEJ;UACII,UAAU,CAACG,CAAC,CAAC;UACb;;;IAIZ,OAAOR,SAAS;EACpB"},"metadata":{},"sourceType":"module","externalDependencies":[]}