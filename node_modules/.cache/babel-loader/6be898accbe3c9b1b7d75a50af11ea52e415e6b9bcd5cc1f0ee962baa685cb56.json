{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent } from \"../common/Exports.js\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, SpeechSynthesisBookmarkEventArgs, SpeechSynthesisResult, SpeechSynthesisVisemeEventArgs, SpeechSynthesisWordBoundaryEventArgs } from \"../sdk/Exports.js\";\nimport { AgentConfig, CancellationErrorCodePropertyName, MetadataType, SynthesisAudioMetadata, SynthesisContext, SynthesisTurn } from \"./Exports.js\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\nexport class SynthesisAdapterBase {\n  constructor(authentication, connectionFactory, synthesizerConfig, audioDestination) {\n    this.speakOverride = undefined;\n    this.receiveMessageOverride = undefined;\n    this.connectImplOverride = undefined;\n    this.configConnectionOverride = undefined;\n    // A promise for a configured connection.\n    // Do not consume directly, call fetchConnection instead.\n    this.privConnectionConfigurationPromise = undefined;\n    if (!authentication) {\n      throw new ArgumentNullError(\"authentication\");\n    }\n    if (!connectionFactory) {\n      throw new ArgumentNullError(\"connectionFactory\");\n    }\n    if (!synthesizerConfig) {\n      throw new ArgumentNullError(\"synthesizerConfig\");\n    }\n    this.privAuthentication = authentication;\n    this.privConnectionFactory = connectionFactory;\n    this.privSynthesizerConfig = synthesizerConfig;\n    this.privIsDisposed = false;\n    this.privSessionAudioDestination = audioDestination;\n    this.privSynthesisTurn = new SynthesisTurn();\n    this.privConnectionEvents = new EventSource();\n    this.privServiceEvents = new EventSource();\n    this.privSynthesisContext = new SynthesisContext();\n    this.privAgentConfig = new AgentConfig();\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        const connectionClosedEvent = connectionEvent;\n        if (connectionClosedEvent.statusCode !== 1000) {\n          this.cancelSynthesisLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n        }\n      }\n    });\n  }\n  get synthesisContext() {\n    return this.privSynthesisContext;\n  }\n  get agentConfig() {\n    return this.privAgentConfig;\n  }\n  get connectionEvents() {\n    return this.privConnectionEvents;\n  }\n  get serviceEvents() {\n    return this.privServiceEvents;\n  }\n  set activityTemplate(messagePayload) {\n    this.privActivityTemplate = messagePayload;\n  }\n  get activityTemplate() {\n    return this.privActivityTemplate;\n  }\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n    this.privSynthesisTurn.audioOutputFormat = format;\n    if (this.privSessionAudioDestination !== undefined) {\n      this.privSessionAudioDestination.format = format;\n    }\n    if (this.synthesisContext !== undefined) {\n      this.synthesisContext.audioOutputFormat = format;\n    }\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privIsDisposed = true;\n      if (this.privSessionAudioDestination !== undefined) {\n        this.privSessionAudioDestination.close();\n      }\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        const connection = yield this.privConnectionConfigurationPromise;\n        yield connection.dispose(reason);\n      }\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n    });\n  }\n  sendNetworkMessage(path, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n      const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n    });\n  }\n  Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ssml;\n      if (isSSML) {\n        ssml = text;\n      } else {\n        ssml = this.privSynthesizer.buildSsml(text);\n      }\n      if (this.speakOverride !== undefined) {\n        return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n      }\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallBack;\n      this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n      try {\n        yield this.connectImpl();\n        const connection = yield this.fetchConnection();\n        yield this.sendSynthesisContext(connection);\n        yield this.sendSsmlMessage(connection, ssml, requestId);\n        this.onSynthesisStarted(requestId);\n        void this.receiveMessage();\n      } catch (e) {\n        this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\n        return Promise.reject(e);\n      }\n    });\n  }\n  stopSpeaking() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"synthesis.control\", this.privSynthesisTurn.requestId, \"application/json\", JSON.stringify({\n        action: \"stop\"\n      })));\n    });\n  }\n  // Cancels synthesis.\n  cancelSynthesis(requestId, _cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n    const result = new SpeechSynthesisResult(requestId, ResultReason.Canceled, undefined, error, properties);\n    this.onSynthesisCancelled(result);\n    if (!!this.privSuccessCallback) {\n      try {\n        this.privSuccessCallback(result);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n  }\n  // Cancels synthesis.\n  cancelSynthesisLocal(cancellationReason, errorCode, error) {\n    if (!!this.privSynthesisTurn.isSynthesizing) {\n      this.privSynthesisTurn.onStopSynthesizing();\n      this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  processTypeSpecificMessages(_connectionMessage) {\n    return true;\n  }\n  receiveMessage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n        if (this.receiveMessageOverride !== undefined) {\n          return this.receiveMessageOverride();\n        }\n        if (this.privIsDisposed) {\n          // We're done.\n          return;\n        }\n        // indicates we are draining the queue and it came with no message;\n        if (!message) {\n          if (!this.privSynthesisTurn.isSynthesizing) {\n            return;\n          } else {\n            return this.receiveMessage();\n          }\n        }\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n        if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n          switch (connectionMessage.path.toLowerCase()) {\n            case \"turn.start\":\n              this.privSynthesisTurn.onServiceTurnStartResponse(connectionMessage.textBody);\n              break;\n            case \"response\":\n              this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n              break;\n            case \"audio\":\n              if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {\n                this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n                this.onSynthesizing(connectionMessage.binaryBody);\n                if (this.privSessionAudioDestination !== undefined) {\n                  this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                }\n              }\n              break;\n            case \"audio.metadata\":\n              const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n              for (const metadata of metadataList) {\n                switch (metadata.Type) {\n                  case MetadataType.WordBoundary:\n                  case MetadataType.SentenceBoundary:\n                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\n                    const wordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);\n                    this.onWordBoundary(wordBoundaryEventArgs);\n                    break;\n                  case MetadataType.Bookmark:\n                    const bookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);\n                    this.onBookmarkReached(bookmarkEventArgs);\n                    break;\n                  case MetadataType.Viseme:\n                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n                    if (metadata.Data.IsLastAnimation) {\n                      const visemeEventArgs = new SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());\n                      this.onVisemeReceived(visemeEventArgs);\n                    }\n                    break;\n                  case MetadataType.AvatarSignal:\n                    this.onAvatarEvent(metadata);\n                    break;\n                  case MetadataType.SessionEnd:\n                    this.privSynthesisTurn.onSessionEnd(metadata);\n                    break;\n                }\n              }\n              break;\n            case \"turn.end\":\n              this.privSynthesisTurn.onServiceTurnEndResponse();\n              let result;\n              try {\n                result = yield this.privSynthesisTurn.constructSynthesisResult();\n                if (!!this.privSuccessCallback) {\n                  this.privSuccessCallback(result);\n                }\n              } catch (error) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(error);\n                }\n              }\n              this.onSynthesisCompleted(result);\n              break;\n            default:\n              if (!this.processTypeSpecificMessages(connectionMessage)) {\n                // here are some messages that the derived class has not processed, dispatch them to connect class\n                if (!!this.privServiceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n          }\n        }\n        return this.receiveMessage();\n      } catch (e) {\n        // TODO: What goes here?\n      }\n    });\n  }\n  sendSynthesisContext(connection) {\n    this.setSynthesisContextSynthesisSection();\n    const synthesisContextJson = this.synthesisContext.toJSON();\n    if (synthesisContextJson) {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"synthesis.context\", this.privSynthesisTurn.requestId, \"application/json\", synthesisContextJson));\n    }\n    return;\n  }\n  setSpeechConfigSynthesisSection() {\n    return;\n  }\n  connectImpl(isUnAuthorized = false) {\n    if (this.privConnectionPromise != null) {\n      return this.privConnectionPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionPromise = null;\n          return this.connectImpl();\n        }\n        return this.privConnectionPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionPromise = null;\n        return this.connectImpl();\n      });\n    }\n    this.privAuthFetchEventId = createNoDashGuid();\n    this.privConnectionId = createNoDashGuid();\n    this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\n    const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n    this.privConnectionPromise = authPromise.then(result => __awaiter(this, void 0, void 0, function* () {\n      this.privSynthesisTurn.onAuthCompleted(false);\n      const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\n      // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n      connection.events.attach(event => {\n        this.connectionEvents.onEvent(event);\n      });\n      const response = yield connection.open();\n      if (response.statusCode === 200) {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.resolve(connection);\n      } else if (response.statusCode === 403 && !isUnAuthorized) {\n        return this.connectImpl(true);\n      } else {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n      }\n    }), error => {\n      this.privSynthesisTurn.onAuthCompleted(true);\n      throw new Error(error);\n    });\n    // Attach an empty handler to allow the promise to run in the background while\n    // other startup events happen. It'll eventually be awaited on.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    this.privConnectionPromise.catch(() => {});\n    return this.privConnectionPromise;\n  }\n  sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {\n    if (SpeechServiceConfigJson) {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", this.privSynthesisTurn.requestId, \"application/json\", SpeechServiceConfigJson));\n    }\n  }\n  sendSsmlMessage(connection, ssml, requestId) {\n    return connection.send(new SpeechConnectionMessage(MessageType.Text, \"ssml\", requestId, \"application/ssml+xml\", ssml));\n  }\n  fetchConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        return this.privConnectionConfigurationPromise.then(connection => {\n          if (connection.state() === ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = undefined;\n            return this.fetchConnection();\n          }\n          return this.privConnectionConfigurationPromise;\n        }, () => {\n          this.privConnectionId = null;\n          this.privConnectionConfigurationPromise = undefined;\n          return this.fetchConnection();\n        });\n      }\n      this.privConnectionConfigurationPromise = this.configureConnection();\n      return yield this.privConnectionConfigurationPromise;\n    });\n  }\n  // Takes an established websocket connection to the endpoint and sends speech configuration information.\n  configureConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.connectImpl();\n      if (this.configConnectionOverride !== undefined) {\n        return this.configConnectionOverride(connection);\n      }\n      this.setSpeechConfigSynthesisSection();\n      yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n      return connection;\n    });\n  }\n  onAvatarEvent(_metadata) {\n    return;\n  }\n  onSynthesisStarted(_requestId) {\n    return;\n  }\n  onSynthesizing(_audio) {\n    return;\n  }\n  onSynthesisCancelled(_result) {\n    return;\n  }\n  onSynthesisCompleted(_result) {\n    return;\n  }\n  onWordBoundary(_wordBoundaryEventArgs) {\n    return;\n  }\n  onVisemeReceived(_visemeEventArgs) {\n    return;\n  }\n  onBookmarkReached(_bookmarkEventArgs) {\n    return;\n  }\n}\nSynthesisAdapterBase.telemetryDataEnabled = true;","map":{"version":3,"names":["ArgumentNullError","ConnectionState","createNoDashGuid","EventSource","MessageType","ServiceEvent","CancellationErrorCode","CancellationReason","PropertyCollection","PropertyId","ResultReason","SpeechSynthesisBookmarkEventArgs","SpeechSynthesisResult","SpeechSynthesisVisemeEventArgs","SpeechSynthesisWordBoundaryEventArgs","AgentConfig","CancellationErrorCodePropertyName","MetadataType","SynthesisAudioMetadata","SynthesisContext","SynthesisTurn","SpeechConnectionMessage","SynthesisAdapterBase","constructor","authentication","connectionFactory","synthesizerConfig","audioDestination","speakOverride","undefined","receiveMessageOverride","connectImplOverride","configConnectionOverride","privConnectionConfigurationPromise","privAuthentication","privConnectionFactory","privSynthesizerConfig","privIsDisposed","privSessionAudioDestination","privSynthesisTurn","privConnectionEvents","privServiceEvents","privSynthesisContext","privAgentConfig","connectionEvents","attach","connectionEvent","name","connectionClosedEvent","statusCode","cancelSynthesisLocal","Error","BadRequestParameters","ConnectionFailure","reason","synthesisContext","agentConfig","serviceEvents","activityTemplate","messagePayload","privActivityTemplate","audioOutputFormat","format","privAudioOutputFormat","isDisposed","dispose","close","connection","connect","connectImpl","sendNetworkMessage","path","payload","type","Text","Binary","contentType","fetchConnection","send","requestId","Speak","text","isSSML","successCallback","errorCallBack","ssml","privSynthesizer","buildSsml","privSuccessCallback","privErrorCallback","startNewSynthesis","sendSynthesisContext","sendSsmlMessage","onSynthesisStarted","receiveMessage","e","Promise","reject","stopSpeaking","JSON","stringify","action","cancelSynthesis","_cancellationReason","errorCode","error","properties","setProperty","result","Canceled","onSynthesisCancelled","_a","cancellationReason","isSynthesizing","onStopSynthesizing","processTypeSpecificMessages","_connectionMessage","message","read","connectionMessage","fromConnectionMessage","toLowerCase","onServiceTurnStartResponse","textBody","onServiceResponseMessage","streamId","binaryBody","onAudioChunkReceived","onSynthesizing","write","metadataList","fromJSON","Metadata","metadata","Type","WordBoundary","SentenceBoundary","onTextBoundaryEvent","wordBoundaryEventArgs","Data","Offset","Duration","Length","currentTextOffset","currentSentenceOffset","BoundaryType","onWordBoundary","Bookmark","bookmarkEventArgs","onBookmarkReached","Viseme","onVisemeMetadataReceived","IsLastAnimation","visemeEventArgs","VisemeId","getAndClearVisemeAnimation","onVisemeReceived","AvatarSignal","onAvatarEvent","SessionEnd","onSessionEnd","onServiceTurnEndResponse","constructSynthesisResult","onSynthesisCompleted","onEvent","setSynthesisContextSynthesisSection","synthesisContextJson","toJSON","setSpeechConfigSynthesisSection","isUnAuthorized","privConnectionPromise","then","state","Disconnected","privConnectionId","privAuthFetchEventId","onPreConnectionStart","authPromise","fetchOnExpiry","fetch","__awaiter","onAuthCompleted","create","events","event","response","open","onConnectionEstablishCompleted","resolve","parameters","getProperty","SpeechServiceConnection_Endpoint","catch","sendSpeechServiceConfig","SpeechServiceConfigJson","configureConnection","SpeechServiceConfig","serialize","_metadata","_requestId","_audio","_result","_wordBoundaryEventArgs","_visemeEventArgs","_bookmarkEventArgs","telemetryDataEnabled"],"sources":["src/common.speech/SynthesisAdapterBase.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    EventSource,\r\n    IAudioDestination,\r\n    IConnection,\r\n    IDisposable,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports.js\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat.js\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechSynthesisBookmarkEventArgs,\r\n    SpeechSynthesisResult,\r\n    SpeechSynthesisVisemeEventArgs,\r\n    SpeechSynthesisWordBoundaryEventArgs,\r\n    Synthesizer,\r\n} from \"../sdk/Exports.js\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    ISynthesisConnectionFactory,\r\n    ISynthesisMetadata,\r\n    MetadataType,\r\n    SynthesisAudioMetadata,\r\n    SynthesisContext,\r\n    SynthesisTurn,\r\n    SynthesizerConfig\r\n} from \"./Exports.js\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication.js\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\r\n\r\nexport abstract class SynthesisAdapterBase implements IDisposable {\r\n    protected privSynthesisTurn: SynthesisTurn;\r\n    protected privConnectionId: string;\r\n    protected privSynthesizerConfig: SynthesizerConfig;\r\n    protected privSynthesizer: Synthesizer;\r\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\r\n    protected privErrorCallback: (e: string) => void;\r\n\r\n    public get synthesisContext(): SynthesisContext {\r\n        return this.privSynthesisContext;\r\n    }\r\n\r\n    public get agentConfig(): AgentConfig {\r\n        return this.privAgentConfig;\r\n    }\r\n\r\n    public get connectionEvents(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    public get serviceEvents(): EventSource<ServiceEvent> {\r\n        return this.privServiceEvents;\r\n    }\r\n\r\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => void = undefined;\r\n\r\n    // Called when telemetry data is sent to the service.\r\n    // Used for testing Telemetry capture.\r\n    public static telemetryData: (json: string) => void;\r\n    public static telemetryDataEnabled: boolean = true;\r\n\r\n    public set activityTemplate(messagePayload: string) {\r\n        this.privActivityTemplate = messagePayload;\r\n    }\r\n    public get activityTemplate(): string {\r\n        return this.privActivityTemplate;\r\n    }\r\n\r\n    protected receiveMessageOverride: () => void = undefined;\r\n\r\n    protected connectImplOverride: (isUnAuthorized: boolean) => void = undefined;\r\n\r\n    protected configConnectionOverride: (connection: IConnection) => Promise<IConnection> = undefined;\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n        this.privSynthesisTurn.audioOutputFormat = format;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.format = format;\r\n        }\r\n        if (this.synthesisContext !== undefined) {\r\n            this.synthesisContext.audioOutputFormat = format;\r\n        }\r\n    }\r\n    private privAuthentication: IAuthentication;\r\n    private privConnectionFactory: ISynthesisConnectionFactory;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionConfigurationPromise: Promise<IConnection> = undefined;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionPromise: Promise<IConnection>;\r\n    private privAuthFetchEventId: string;\r\n    private privIsDisposed: boolean;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privServiceEvents: EventSource<ServiceEvent>;\r\n    protected privSynthesisContext: SynthesisContext;\r\n    private privAgentConfig: AgentConfig;\r\n    private privActivityTemplate: string;\r\n    protected privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privSessionAudioDestination: IAudioDestination;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: ISynthesisConnectionFactory,\r\n        synthesizerConfig: SynthesizerConfig,\r\n        audioDestination: IAudioDestination) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!synthesizerConfig) {\r\n            throw new ArgumentNullError(\"synthesizerConfig\");\r\n        }\r\n\r\n        this.privAuthentication = authentication;\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.privSynthesizerConfig = synthesizerConfig;\r\n        this.privIsDisposed = false;\r\n        this.privSessionAudioDestination = audioDestination;\r\n        this.privSynthesisTurn = new SynthesisTurn();\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privServiceEvents = new EventSource<ServiceEvent>();\r\n        this.privSynthesisContext = new SynthesisContext();\r\n        this.privAgentConfig = new AgentConfig();\r\n\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\r\n                if (connectionClosedEvent.statusCode !== 1000) {\r\n                    this.cancelSynthesisLocal(CancellationReason.Error,\r\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\r\n                        `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privIsDisposed = true;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.close();\r\n        }\r\n        if (this.privConnectionConfigurationPromise !== undefined) {\r\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        await this.connectImpl();\r\n    }\r\n\r\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\r\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\r\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\r\n    }\r\n\r\n    public async Speak(\r\n        text: string,\r\n        isSSML: boolean,\r\n        requestId: string,\r\n        successCallback: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack: (e: string) => void,\r\n        audioDestination: IAudioDestination,\r\n    ): Promise<void> {\r\n\r\n        let ssml: string;\r\n\r\n        if (isSSML) {\r\n            ssml = text;\r\n        } else {\r\n            ssml = this.privSynthesizer.buildSsml(text);\r\n        }\r\n\r\n        if (this.speakOverride !== undefined) {\r\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\r\n        }\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallBack;\r\n\r\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\r\n\r\n        try {\r\n            await this.connectImpl();\r\n            const connection: IConnection = await this.fetchConnection();\r\n            await this.sendSynthesisContext(connection);\r\n            await this.sendSsmlMessage(connection, ssml, requestId);\r\n            this.onSynthesisStarted(requestId);\r\n\r\n            void this.receiveMessage();\r\n        } catch (e) {\r\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e as string);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    public async stopSpeaking(): Promise<void> {\r\n        await this.connectImpl();\r\n        const connection: IConnection = await this.fetchConnection();\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"synthesis.control\",\r\n            this.privSynthesisTurn.requestId,\r\n            \"application/json\",\r\n            JSON.stringify({\r\n                action: \"stop\"\r\n            })\r\n        ));\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesis(\r\n        requestId: string,\r\n        _cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\r\n            requestId,\r\n            ResultReason.Canceled,\r\n            undefined,\r\n            error,\r\n            properties\r\n        );\r\n\r\n        this.onSynthesisCancelled(result);\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesisLocal(\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        if (!!this.privSynthesisTurn.isSynthesizing) {\r\n            this.privSynthesisTurn.onStopSynthesizing();\r\n\r\n            this.cancelSynthesis(\r\n                this.privSynthesisTurn.requestId,\r\n                cancellationReason,\r\n                errorCode,\r\n                error);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected processTypeSpecificMessages(_connectionMessage: SpeechConnectionMessage): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected async receiveMessage(): Promise<void> {\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConnectionMessage = await connection.read();\r\n\r\n            if (this.receiveMessageOverride !== undefined) {\r\n                return this.receiveMessageOverride();\r\n            }\r\n            if (this.privIsDisposed) {\r\n                // We're done.\r\n                return;\r\n            }\r\n\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!message) {\r\n                if (!this.privSynthesisTurn.isSynthesizing) {\r\n                    return;\r\n                } else {\r\n                    return this.receiveMessage();\r\n                }\r\n            }\r\n\r\n\r\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        this.privSynthesisTurn.onServiceTurnStartResponse(connectionMessage.textBody);\r\n                        break;\r\n                    case \"response\":\r\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\r\n                        break;\r\n                    case \"audio\":\r\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\r\n                            && !!connectionMessage.binaryBody) {\r\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\r\n                            this.onSynthesizing(connectionMessage.binaryBody);\r\n                            if (this.privSessionAudioDestination !== undefined) {\r\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"audio.metadata\":\r\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\r\n                        for (const metadata of metadataList) {\r\n                            switch (metadata.Type) {\r\n                                case MetadataType.WordBoundary:\r\n                                case MetadataType.SentenceBoundary:\r\n                                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\r\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Duration,\r\n                                        metadata.Data.text.Text,\r\n                                        metadata.Data.text.Length,\r\n                                        metadata.Type === MetadataType.WordBoundary\r\n                                            ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset,\r\n                                        metadata.Data.text.BoundaryType);\r\n                                    this.onWordBoundary(wordBoundaryEventArgs);\r\n                                    break;\r\n                                case MetadataType.Bookmark:\r\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Bookmark);\r\n                                    this.onBookmarkReached(bookmarkEventArgs);\r\n                                    break;\r\n                                case MetadataType.Viseme:\r\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\r\n                                    if (metadata.Data.IsLastAnimation) {\r\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\r\n                                            metadata.Data.Offset,\r\n                                            metadata.Data.VisemeId,\r\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\r\n                                        this.onVisemeReceived(visemeEventArgs);\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.AvatarSignal:\r\n                                    this.onAvatarEvent(metadata);\r\n                                    break;\r\n                                case MetadataType.SessionEnd:\r\n                                    this.privSynthesisTurn.onSessionEnd(metadata);\r\n                                    break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"turn.end\":\r\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\r\n                        let result: SpeechSynthesisResult;\r\n                        try {\r\n                            result = await this.privSynthesisTurn.constructSynthesisResult();\r\n                            if (!!this.privSuccessCallback) {\r\n                                this.privSuccessCallback(result);\r\n                            }\r\n                        } catch (error) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(error as string);\r\n                            }\r\n                        }\r\n                        this.onSynthesisCompleted(result);\r\n                        break;\r\n\r\n                    default:\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\r\n                            if (!!this.privServiceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n\r\n                }\r\n            }\r\n\r\n            return this.receiveMessage();\r\n\r\n        } catch (e) {\r\n            // TODO: What goes here?\r\n        }\r\n    }\r\n\r\n    protected sendSynthesisContext(connection: IConnection): Promise<void> {\r\n        this.setSynthesisContextSynthesisSection();\r\n        const synthesisContextJson = this.synthesisContext.toJSON();\r\n\r\n        if (synthesisContextJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"synthesis.context\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                synthesisContextJson));\r\n        }\r\n        return;\r\n    }\r\n\r\n    protected abstract setSynthesisContextSynthesisSection(): void;\r\n\r\n    protected setSpeechConfigSynthesisSection(): void {\r\n        return;\r\n    }\r\n\r\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privConnectionPromise != null) {\r\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionPromise = null;\r\n                    return this.connectImpl();\r\n                }\r\n                return this.privConnectionPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionPromise = null;\r\n                return this.connectImpl();\r\n            });\r\n        }\r\n        this.privAuthFetchEventId = createNoDashGuid();\r\n        this.privConnectionId = createNoDashGuid();\r\n\r\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\r\n\r\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo): Promise<IConnection> => {\r\n            this.privSynthesisTurn.onAuthCompleted(false);\r\n\r\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\r\n\r\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n            // it'll stop sending events.\r\n            connection.events.attach((event: ConnectionEvent): void => {\r\n                this.connectionEvents.onEvent(event);\r\n            });\r\n            const response = await connection.open();\r\n            if (response.statusCode === 200) {\r\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.resolve(connection);\r\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                return this.connectImpl(true);\r\n            } else {\r\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n            }\r\n        }, (error: string): Promise<IConnection> => {\r\n            this.privSynthesisTurn.onAuthCompleted(true);\r\n            throw new Error(error);\r\n        });\r\n\r\n        // Attach an empty handler to allow the promise to run in the background while\r\n        // other startup events happen. It'll eventually be awaited on.\r\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n        this.privConnectionPromise.catch((): void => { });\r\n\r\n        return this.privConnectionPromise;\r\n    }\r\n    protected sendSpeechServiceConfig(connection: IConnection, SpeechServiceConfigJson: string): Promise<void> {\r\n        if (SpeechServiceConfigJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.config\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                SpeechServiceConfigJson));\r\n        }\r\n    }\r\n\r\n    protected sendSsmlMessage(connection: IConnection, ssml: string, requestId: string): Promise<void> {\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"ssml\",\r\n            requestId,\r\n            \"application/ssml+xml\",\r\n            ssml));\r\n    }\r\n\r\n    private async fetchConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigurationPromise !== undefined) {\r\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigurationPromise = undefined;\r\n                    return this.fetchConnection();\r\n                }\r\n                return this.privConnectionConfigurationPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigurationPromise = undefined;\r\n                return this.fetchConnection();\r\n            });\r\n        }\r\n        this.privConnectionConfigurationPromise = this.configureConnection();\r\n        return await this.privConnectionConfigurationPromise;\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configureConnection(): Promise<IConnection> {\r\n        const connection: IConnection = await this.connectImpl();\r\n        if (this.configConnectionOverride !== undefined) {\r\n            return this.configConnectionOverride(connection);\r\n        }\r\n        this.setSpeechConfigSynthesisSection();\r\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\r\n        return connection;\r\n    }\r\n\r\n    protected onAvatarEvent(_metadata: ISynthesisMetadata): void {\r\n        return;\r\n    }\r\n\r\n    protected onSynthesisStarted(_requestId: string): void {\r\n        return;\r\n    }\r\n\r\n    protected onSynthesizing(_audio: ArrayBuffer): void {\r\n        return;\r\n    }\r\n\r\n    protected onSynthesisCancelled(_result: SpeechSynthesisResult): void {\r\n        return;\r\n    }\r\n\r\n    protected onSynthesisCompleted(_result: SpeechSynthesisResult): void {\r\n        return;\r\n    }\r\n\r\n    protected onWordBoundary(_wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs): void {\r\n        return;\r\n    }\r\n\r\n    protected onVisemeReceived(_visemeEventArgs: SpeechSynthesisVisemeEventArgs): void {\r\n        return;\r\n    }\r\n\r\n    protected onBookmarkReached(_bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs): void {\r\n        return;\r\n    }\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}