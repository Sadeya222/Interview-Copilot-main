{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { InvalidOperationError } from \"../../common/Error.js\";\nimport { AudioStreamFormat } from \"../Exports.js\";\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat.js\";\n/**\n * Base audio player class\n * TODO: Plays only PCM for now.\n * @class\n */\nexport class BaseAudioPlayer {\n  /**\n   * Creates and initializes an instance of this class.\n   * @constructor\n   * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.\n   */\n  constructor(audioFormat) {\n    this.audioContext = null;\n    this.gainNode = null;\n    this.autoUpdateBufferTimer = 0;\n    if (audioFormat === undefined) {\n      audioFormat = AudioStreamFormat.getDefaultInputFormat();\n    }\n    this.init(audioFormat);\n  }\n  /**\n   * play Audio sample\n   * @param newAudioData audio data to be played.\n   */\n  playAudioSample(newAudioData, cb, err) {\n    try {\n      this.ensureInitializedContext();\n      const audioData = this.formatAudioData(newAudioData);\n      const newSamplesData = new Float32Array(this.samples.length + audioData.length);\n      newSamplesData.set(this.samples, 0);\n      newSamplesData.set(audioData, this.samples.length);\n      this.samples = newSamplesData;\n      if (!!cb) {\n        cb();\n      }\n    } catch (e) {\n      if (!!err) {\n        err(e);\n      }\n    }\n  }\n  /**\n   * stops audio and clears the buffers\n   */\n  stopAudio(cb, err) {\n    if (this.audioContext !== null) {\n      this.samples = new Float32Array();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      clearInterval(this.autoUpdateBufferTimer);\n      this.audioContext.close().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n      this.audioContext = null;\n    }\n  }\n  init(audioFormat) {\n    this.audioFormat = audioFormat;\n    this.samples = new Float32Array();\n  }\n  ensureInitializedContext() {\n    if (this.audioContext === null) {\n      this.createAudioContext();\n      const timerPeriod = 200;\n      this.autoUpdateBufferTimer = setInterval(() => {\n        this.updateAudioBuffer();\n      }, timerPeriod);\n    }\n  }\n  createAudioContext() {\n    // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\n    this.audioContext = AudioStreamFormatImpl.getAudioContext();\n    // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\n    // to control the volume, not likely\n    this.gainNode = this.audioContext.createGain();\n    this.gainNode.gain.value = 1;\n    this.gainNode.connect(this.audioContext.destination);\n    this.startTime = this.audioContext.currentTime;\n  }\n  formatAudioData(audioData) {\n    switch (this.audioFormat.bitsPerSample) {\n      case 8:\n        return this.formatArrayBuffer(new Int8Array(audioData), 128);\n      case 16:\n        return this.formatArrayBuffer(new Int16Array(audioData), 32768);\n      case 32:\n        return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\n      default:\n        throw new InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\n    }\n  }\n  formatArrayBuffer(audioData, maxValue) {\n    const float32Data = new Float32Array(audioData.length);\n    for (let i = 0; i < audioData.length; i++) {\n      float32Data[i] = audioData[i] / maxValue;\n    }\n    return float32Data;\n  }\n  updateAudioBuffer() {\n    if (this.samples.length === 0) {\n      return;\n    }\n    const channelCount = this.audioFormat.channels;\n    const bufferSource = this.audioContext.createBufferSource();\n    const frameCount = this.samples.length / channelCount;\n    const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);\n    // TODO: Should we do the conversion in the pushAudioSample instead?\n    for (let channel = 0; channel < channelCount; channel++) {\n      // Fill in individual channel data\n      let channelOffset = channel;\n      const audioData = audioBuffer.getChannelData(channel);\n      for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\n        audioData[i] = this.samples[channelOffset];\n      }\n    }\n    if (this.startTime < this.audioContext.currentTime) {\n      this.startTime = this.audioContext.currentTime;\n    }\n    bufferSource.buffer = audioBuffer;\n    bufferSource.connect(this.gainNode);\n    bufferSource.start(this.startTime);\n    // Make sure we play the next sample after the current one.\n    this.startTime += audioBuffer.duration;\n    // Clear the samples for the next pushed data.\n    this.samples = new Float32Array();\n  }\n  playAudio(audioData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.audioContext === null) {\n        this.createAudioContext();\n      }\n      const source = this.audioContext.createBufferSource();\n      const destination = this.audioContext.destination;\n      yield this.audioContext.decodeAudioData(audioData, newBuffer => {\n        source.buffer = newBuffer;\n        source.connect(destination);\n        source.start(0);\n      });\n    });\n  }\n}","map":{"version":3,"names":["InvalidOperationError","AudioStreamFormat","AudioStreamFormatImpl","BaseAudioPlayer","constructor","audioFormat","audioContext","gainNode","autoUpdateBufferTimer","undefined","getDefaultInputFormat","init","playAudioSample","newAudioData","cb","err","ensureInitializedContext","audioData","formatAudioData","newSamplesData","Float32Array","samples","length","set","e","stopAudio","clearInterval","close","then","error","createAudioContext","timerPeriod","setInterval","updateAudioBuffer","getAudioContext","createGain","gain","value","connect","destination","startTime","currentTime","bitsPerSample","formatArrayBuffer","Int8Array","Int16Array","Int32Array","maxValue","float32Data","i","channelCount","channels","bufferSource","createBufferSource","frameCount","audioBuffer","createBuffer","samplesPerSec","channel","channelOffset","getChannelData","buffer","start","duration","playAudio","source","decodeAudioData","newBuffer"],"sources":["src/sdk/Audio/BaseAudioPlayer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"../../common/Error.js\";\r\nimport { AudioStreamFormat } from \"../Exports.js\";\r\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat.js\";\r\n\r\ntype AudioDataTypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array;\r\n/**\r\n * Base audio player class\r\n * TODO: Plays only PCM for now.\r\n * @class\r\n */\r\nexport class BaseAudioPlayer {\r\n\r\n    private audioContext: AudioContext = null;\r\n    private gainNode: GainNode = null;\r\n    private audioFormat: AudioStreamFormatImpl;\r\n    private autoUpdateBufferTimer: any = 0;\r\n    private samples: Float32Array;\r\n    private startTime: number;\r\n\r\n    /**\r\n     * Creates and initializes an instance of this class.\r\n     * @constructor\r\n     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.\r\n     */\r\n    public constructor(audioFormat?: AudioStreamFormat) {\r\n        if (audioFormat === undefined) {\r\n            audioFormat = AudioStreamFormat.getDefaultInputFormat();\r\n        }\r\n        this.init(audioFormat);\r\n    }\r\n\r\n    /**\r\n     * play Audio sample\r\n     * @param newAudioData audio data to be played.\r\n     */\r\n    public playAudioSample(newAudioData: ArrayBuffer, cb?: () => void, err?: (error: string) => void): void {\r\n        try {\r\n            this.ensureInitializedContext();\r\n            const audioData = this.formatAudioData(newAudioData);\r\n            const newSamplesData = new Float32Array(this.samples.length + audioData.length);\r\n            newSamplesData.set(this.samples, 0);\r\n            newSamplesData.set(audioData, this.samples.length);\r\n            this.samples = newSamplesData;\r\n            if (!!cb) {\r\n                cb();\r\n            }\r\n        } catch (e) {\r\n            if (!!err) {\r\n                err(e as string);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * stops audio and clears the buffers\r\n     */\r\n    public stopAudio(cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.audioContext !== null) {\r\n            this.samples = new Float32Array();\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\r\n            clearInterval(this.autoUpdateBufferTimer);\r\n            this.audioContext.close().then((): void => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n            this.audioContext = null;\r\n        }\r\n    }\r\n\r\n    private init(audioFormat: AudioStreamFormat): void {\r\n        this.audioFormat = audioFormat as AudioStreamFormatImpl;\r\n        this.samples = new Float32Array();\r\n    }\r\n\r\n    private ensureInitializedContext(): void {\r\n        if (this.audioContext === null) {\r\n            this.createAudioContext();\r\n            const timerPeriod = 200;\r\n            this.autoUpdateBufferTimer = setInterval((): void => {\r\n                this.updateAudioBuffer();\r\n            }, timerPeriod);\r\n        }\r\n    }\r\n\r\n    private createAudioContext(): void {\r\n        // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\r\n        this.audioContext = AudioStreamFormatImpl.getAudioContext();\r\n\r\n        // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\r\n        // to control the volume, not likely\r\n        this.gainNode = this.audioContext.createGain();\r\n        this.gainNode.gain.value = 1;\r\n        this.gainNode.connect(this.audioContext.destination);\r\n        this.startTime = this.audioContext.currentTime;\r\n    }\r\n\r\n    private formatAudioData(audioData: ArrayBuffer): Float32Array {\r\n        switch (this.audioFormat.bitsPerSample) {\r\n            case 8:\r\n                return this.formatArrayBuffer(new Int8Array(audioData), 128);\r\n            case 16:\r\n                return this.formatArrayBuffer(new Int16Array(audioData), 32768);\r\n            case 32:\r\n                return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\r\n            default:\r\n                throw new InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\r\n        }\r\n    }\r\n\r\n    private formatArrayBuffer(audioData: AudioDataTypedArray, maxValue: number): Float32Array {\r\n        const float32Data = new Float32Array(audioData.length);\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            float32Data[i] = audioData[i] / maxValue;\r\n        }\r\n        return float32Data;\r\n    }\r\n\r\n    private updateAudioBuffer(): void {\r\n        if (this.samples.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const channelCount = this.audioFormat.channels;\r\n        const bufferSource = this.audioContext.createBufferSource();\r\n        const frameCount = this.samples.length / channelCount;\r\n        const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);\r\n\r\n        // TODO: Should we do the conversion in the pushAudioSample instead?\r\n        for (let channel = 0; channel < channelCount; channel++) {\r\n            // Fill in individual channel data\r\n            let channelOffset = channel;\r\n            const audioData = audioBuffer.getChannelData(channel);\r\n            for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\r\n                audioData[i] = this.samples[channelOffset];\r\n            }\r\n        }\r\n\r\n        if (this.startTime < this.audioContext.currentTime) {\r\n            this.startTime = this.audioContext.currentTime;\r\n        }\r\n\r\n        bufferSource.buffer = audioBuffer;\r\n        bufferSource.connect(this.gainNode);\r\n        bufferSource.start(this.startTime);\r\n\r\n        // Make sure we play the next sample after the current one.\r\n        this.startTime += audioBuffer.duration;\r\n\r\n        // Clear the samples for the next pushed data.\r\n        this.samples = new Float32Array();\r\n    }\r\n\r\n    private async playAudio(audioData: ArrayBuffer): Promise<void> {\r\n        if (this.audioContext === null) {\r\n            this.createAudioContext();\r\n        }\r\n        const source: AudioBufferSourceNode = this.audioContext.createBufferSource();\r\n        const destination: AudioDestinationNode = this.audioContext.destination;\r\n        await this.audioContext.decodeAudioData(audioData, (newBuffer: AudioBuffer): void => {\r\n            source.buffer = newBuffer;\r\n            source.connect(destination);\r\n            source.start(0);\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}