{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable max-classes-per-file */\nimport { ConversationConnectionConfig, ConversationManager, ConversationRecognizerFactory, ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, InternalParticipants } from \"../../common.speech/Exports.js\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports.js\";\nimport { Contracts } from \"../Contracts.js\";\nimport { ConversationParticipantsChangedEventArgs, ConversationTranslationEventArgs, Participant, ParticipantChangedReason, ProfanityOption, PropertyCollection, PropertyId } from \"../Exports.js\";\nexport class Conversation {\n  constructor() {\n    return;\n  }\n  /**\n   * Create a conversation\n   * @param speechConfig\n   * @param cb\n   * @param err\n   */\n  static createConversationAsync(speechConfig, arg2, arg3, arg4) {\n    Contracts.throwIfNullOrUndefined(speechConfig, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n    Contracts.throwIfNullOrUndefined(speechConfig.region, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\n    if (!speechConfig.subscriptionKey && !speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceAuthorization_Token])) {\n      Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\n    }\n    let conversationImpl;\n    let cb;\n    let err;\n    if (typeof arg2 === \"string\") {\n      conversationImpl = new ConversationImpl(speechConfig, arg2);\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {}))(), arg3, arg4);\n    } else {\n      conversationImpl = new ConversationImpl(speechConfig);\n      cb = arg2;\n      err = arg3;\n      conversationImpl.createConversationAsync(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    }\n    return conversationImpl;\n  }\n}\nexport class ConversationImpl extends Conversation {\n  /**\n   * Create a conversation impl\n   * @param speechConfig\n   * @param {string} id - optional conversationId\n   */\n  constructor(speechConfig, id) {\n    super();\n    this.privErrors = ConversationConnectionConfig.restErrors;\n    /** websocket callbacks */\n    /* eslint-disable @typescript-eslint/typedef */\n    this.onConnected = e => {\n      var _a;\n      this.privIsConnected = true;\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStarted)) {\n          this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onDisconnected = e => {\n      var _a;\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStopped)) {\n          this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      } finally {\n        void this.close(false);\n      }\n    };\n    this.onCanceled = (r, e) => {\n      var _a;\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.canceled)) {\n          this.privConversationTranslator.canceled(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantUpdateCommandReceived = (r, e) => {\n      try {\n        const updatedParticipant = this.privParticipants.getParticipant(e.id);\n        if (updatedParticipant !== undefined) {\n          switch (e.key) {\n            case ConversationTranslatorCommandTypes.changeNickname:\n              updatedParticipant.displayName = e.value;\n              break;\n            case ConversationTranslatorCommandTypes.setUseTTS:\n              updatedParticipant.isUsingTts = e.value;\n              break;\n            case ConversationTranslatorCommandTypes.setProfanityFiltering:\n              updatedParticipant.profanity = e.value;\n              break;\n            case ConversationTranslatorCommandTypes.setMute:\n              updatedParticipant.isMuted = e.value;\n              break;\n            case ConversationTranslatorCommandTypes.setTranslateToLanguages:\n              updatedParticipant.translateToLanguages = e.value;\n              break;\n          }\n          this.privParticipants.addOrUpdateParticipant(updatedParticipant);\n          if (!!this.privConversationTranslator) {\n            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onLockRoomCommandReceived = () => {\n      // TODO\n    };\n    this.onMuteAllCommandReceived = (r, e) => {\n      try {\n        this.privParticipants.participants.forEach(p => p.isMuted = p.isHost ? false : e.isMuted);\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantJoinCommandReceived = (r, e) => {\n      try {\n        const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);\n        if (newParticipant !== undefined) {\n          if (!!this.privConversationTranslator) {\n            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantLeaveCommandReceived = (r, e) => {\n      try {\n        const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);\n        if (ejectedParticipant !== undefined) {\n          // remove the participant from the internal participants list\n          this.privParticipants.deleteParticipant(e.participant.id);\n          if (!!this.privConversationTranslator) {\n            // notify subscribers that the participant has left the conversation\n            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onTranslationReceived = (r, e) => {\n      try {\n        switch (e.command) {\n          case ConversationTranslatorMessageTypes.final:\n            if (!!this.privConversationTranslator) {\n              this.privConversationTranslator.transcribed(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n            break;\n          case ConversationTranslatorMessageTypes.partial:\n            if (!!this.privConversationTranslator) {\n              this.privConversationTranslator.transcribing(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n            break;\n          case ConversationTranslatorMessageTypes.instantMessage:\n            if (!!this.privConversationTranslator) {\n              this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n            break;\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onParticipantsListReceived = (r, e) => {\n      var _a;\n      try {\n        // check if the session token needs to be updated\n        if (e.sessionToken !== undefined && e.sessionToken !== null) {\n          this.privRoom.token = e.sessionToken;\n        }\n        // save the participants\n        this.privParticipants.participants = [...e.participants];\n        // enable the conversation\n        if (this.privParticipants.me !== undefined) {\n          this.privIsReady = true;\n        }\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));\n        }\n        // if this is the host, update the nickname if needed\n        if (this.me.isHost) {\n          const nickname = (_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.properties.getProperty(PropertyId.ConversationTranslator_Name);\n          if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {\n            // issue a change nickname request\n            this.changeNicknameAsync(nickname);\n          }\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.onConversationExpiration = (r, e) => {\n      try {\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, e);\n        }\n      } catch (e) {\n        //\n      }\n    };\n    this.privIsConnected = false;\n    this.privIsDisposed = false;\n    this.privConversationId = \"\";\n    this.privProperties = new PropertyCollection();\n    this.privManager = new ConversationManager();\n    // check the speech language\n    const language = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n    if (!language) {\n      speechConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], ConversationConnectionConfig.defaultLanguageCode);\n    }\n    this.privLanguage = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n    if (!id) {\n      // check the target language(s)\n      if (speechConfig.targetLanguages.length === 0) {\n        speechConfig.addTargetLanguage(this.privLanguage);\n      }\n      // check the profanity setting: speech and conversationTranslator should be in sync\n      const profanity = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption]);\n      if (!profanity) {\n        speechConfig.setProfanity(ProfanityOption.Masked);\n      }\n      // check the nickname: it should pass this regex: ^\\w+([\\s-][\\w\\(\\)]+)*$\"\n      // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error\n      // TODO: check what the max length is and if a truncation is required or if the service handles it without an error\n      let hostNickname = speechConfig.getProperty(PropertyId[PropertyId.ConversationTranslator_Name]);\n      if (hostNickname === undefined || hostNickname === null) {\n        hostNickname = \"Host\";\n      }\n      Contracts.throwIfNullOrTooLong(hostNickname, \"nickname\", 50);\n      Contracts.throwIfNullOrTooShort(hostNickname, \"nickname\", 2);\n      speechConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], hostNickname);\n    } else {\n      this.privConversationId = id;\n    }\n    // save the speech config for future usage\n    this.privConfig = speechConfig;\n    // save the config properties\n    const configImpl = speechConfig;\n    Contracts.throwIfNull(configImpl, \"speechConfig\");\n    this.privProperties = configImpl.properties.clone();\n    this.privIsConnected = false;\n    this.privParticipants = new InternalParticipants();\n    this.privIsReady = false;\n    this.privTextMessageMaxLength = 1000;\n  }\n  // get the internal data about a conversation\n  get room() {\n    return this.privRoom;\n  }\n  // get the wrapper for connecting to the websockets\n  get connection() {\n    return this.privConversationRecognizer; // this.privConnection;\n  }\n  // get the config\n  get config() {\n    return this.privConfig;\n  }\n  // get the conversation Id\n  get conversationId() {\n    return this.privRoom ? this.privRoom.roomId : this.privConversationId;\n  }\n  // get the properties\n  get properties() {\n    return this.privProperties;\n  }\n  // get the speech language\n  get speechRecognitionLanguage() {\n    return this.privLanguage;\n  }\n  get isMutedByHost() {\n    var _a, _b;\n    return ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost) ? false : (_b = this.privParticipants.me) === null || _b === void 0 ? void 0 : _b.isMuted;\n  }\n  get isConnected() {\n    return this.privIsConnected && this.privIsReady;\n  }\n  get participants() {\n    return this.toParticipants(true);\n  }\n  get me() {\n    return this.toParticipant(this.privParticipants.me);\n  }\n  get host() {\n    return this.toParticipant(this.privParticipants.host);\n  }\n  get transcriberRecognizer() {\n    return this.privTranscriberRecognizer;\n  }\n  get conversationInfo() {\n    const convId = this.conversationId;\n    const p = this.participants.map(part => ({\n      id: part.id,\n      preferredLanguage: part.preferredLanguage,\n      voice: part.voice\n    }));\n    const props = {};\n    for (const key of ConversationConnectionConfig.transcriptionEventKeys) {\n      const val = this.properties.getProperty(key, \"\");\n      if (val !== \"\") {\n        props[key] = val;\n      }\n    }\n    const info = {\n      id: convId,\n      participants: p,\n      conversationProperties: props\n    };\n    return info;\n  }\n  get canSend() {\n    var _a;\n    return this.privIsConnected && !((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isMuted);\n  }\n  get canSendAsHost() {\n    var _a;\n    return this.privIsConnected && ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost);\n  }\n  // get / set the speech auth token\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  get authorizationToken() {\n    return this.privToken;\n  }\n  set authorizationToken(value) {\n    Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\n    this.privToken = value;\n  }\n  set conversationTranslator(conversationTranslator) {\n    this.privConversationTranslator = conversationTranslator;\n  }\n  onToken(token) {\n    this.privConversationTranslator.onToken(token);\n  }\n  /**\n   * Create a new conversation as Host\n   * @param cb\n   * @param err\n   */\n  createConversationAsync(cb, err) {\n    try {\n      if (!!this.privConversationRecognizer) {\n        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n      }\n      this.privManager.createOrJoin(this.privProperties, undefined, room => {\n        if (!room) {\n          this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);\n        }\n        this.privRoom = room;\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Starts a new conversation as host.\n   * @param cb\n   * @param err\n   */\n  startConversationAsync(cb, err) {\n    try {\n      // check if there is already a recognizer\n      if (!!this.privConversationRecognizer) {\n        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n      }\n      // check if there is conversation data available\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);\n      // connect to the conversation websocket\n      this.privParticipants.meId = this.privRoom.participantId;\n      this.privConversationRecognizer = ConversationRecognizerFactory.fromConfig(this, this.privConfig);\n      // Because ConversationTranslator manually sets up and manages the connection, Conversation\n      // has to forward serviceRecognizer connection events that usually get passed automatically\n      this.privConversationRecognizer.connected = this.onConnected;\n      this.privConversationRecognizer.disconnected = this.onDisconnected;\n      this.privConversationRecognizer.canceled = this.onCanceled;\n      this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\n      this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\n      this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\n      this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\n      this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\n      this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\n      this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\n      this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\n      this.privConversationRecognizer.connect(this.privRoom.token, () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Join a conversation as a participant.\n   * @param { IParticipant } participant - participant to add\n   * @param cb\n   * @param err\n   */\n  addParticipantAsync(participant, cb, err) {\n    Contracts.throwIfNullOrUndefined(participant, \"Participant\");\n    marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);\n  }\n  /**\n   * Join a conversation as a participant.\n   * @param conversation\n   * @param nickname\n   * @param lang\n   * @param cb\n   * @param err\n   */\n  joinConversationAsync(conversationId, nickname, lang, cb, err) {\n    try {\n      // TODO\n      // if (!!this.privConversationRecognizer) {\n      //     throw new Error(this.privErrors.permissionDeniedStart);\n      // }\n      Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\n      Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n      Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\"));\n      // join the conversation\n      this.privManager.createOrJoin(this.privProperties, conversationId, room => {\n        Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);\n        this.privRoom = room;\n        this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;\n        // join callback\n        if (!!cb) {\n          cb(room.cognitiveSpeechAuthToken);\n        }\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Deletes a conversation\n   * @param cb\n   * @param err\n   */\n  deleteConversationAsync(cb, err) {\n    marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb, err);\n  }\n  deleteConversationImplAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\n      Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\n      yield this.privManager.leave(this.privProperties, this.privRoom.token);\n      this.dispose();\n    });\n  }\n  /**\n   * Issues a request to close the client websockets\n   * @param cb\n   * @param err\n   */\n  endConversationAsync(cb, err) {\n    marshalPromiseToCallbacks(this.endConversationImplAsync(), cb, err);\n  }\n  endConversationImplAsync() {\n    return this.close(true);\n  }\n  /**\n   * Issues a request to lock the conversation\n   * @param cb\n   * @param err\n   */\n  lockConversationAsync(cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getLockCommand(true), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to mute the conversation\n   * @param cb\n   * @param err\n   */\n  muteAllParticipantsAsync(cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      // check the user's permissions\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to mute a participant in the conversation\n   * @param userId\n   * @param cb\n   * @param err\n   */\n  muteParticipantAsync(userId, cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      // check the connection is open (host + participant can perform the mute command)\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      // if not host, check the participant is not muting another participant\n      if (!this.me.isHost && this.me.id !== userId) {\n        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n      }\n      // check the user exists\n      const exists = this.privParticipants.getParticipantIndex(userId);\n      if (exists === -1) {\n        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to remove a participant from the conversation\n   * @param userId\n   * @param cb\n   * @param err\n   */\n  removeParticipantAsync(userId, cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      if (!!this.privTranscriberRecognizer && userId.hasOwnProperty(\"id\")) {\n        // Assume this is a transcription participant\n        marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);\n      } else {\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\n        }\n        let participantId = \"\";\n        if (typeof userId === \"string\") {\n          participantId = userId;\n        } else if (userId.hasOwnProperty(\"id\")) {\n          const participant = userId;\n          participantId = participant.id;\n        } else if (userId.hasOwnProperty(\"userId\")) {\n          const user = userId;\n          participantId = user.userId;\n        }\n        Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n        // check the participant exists\n        const index = this.participants.findIndex(p => p.id === participantId);\n        if (index === -1) {\n          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n        }\n        if (!!this.privConversationRecognizer) {\n          this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId), () => {\n            this.handleCallback(cb, err);\n          }, error => {\n            this.handleError(error, err);\n          });\n        }\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to unlock the conversation\n   * @param cb\n   * @param err\n   */\n  unlockConversationAsync(cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getLockCommand(false), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to unmute all participants in the conversation\n   * @param cb\n   * @param err\n   */\n  unmuteAllParticipantsAsync(cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Issues a request to unmute a participant in the conversation\n   * @param userId\n   * @param cb\n   * @param err\n   */\n  unmuteParticipantAsync(userId, cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      // check the connection is open (host + participant can perform the mute command)\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      // if not host, check the participant is not muting another participant\n      if (!this.me.isHost && this.me.id !== userId) {\n        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n      }\n      // check the user exists\n      const exists = this.privParticipants.getParticipantIndex(userId);\n      if (exists === -1) {\n        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Send a text message\n   * @param message\n   * @param cb\n   * @param err\n   */\n  sendTextMessageAsync(message, cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      // TODO: is a max length check required?\n      if (message.length > this.privTextMessageMaxLength) {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Set translated to languages\n   * @param {string[]} languages - languages to translate to\n   * @param cb\n   * @param err\n   */\n  setTranslatedLanguagesAsync(languages, cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace(\"{arg}\", \"languages\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\n   * Change nickname\n   * @param {string} nickname - new nickname for the room\n   * @param cb\n   * @param err\n   */\n  changeNicknameAsync(nickname, cb, err) {\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n      if (!!this.privConversationRecognizer) {\n        this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n    this.privIsDisposed = true;\n    if (!!this.config) {\n      this.config.close();\n    }\n    this.privConfig = undefined;\n    this.privLanguage = undefined;\n    this.privProperties = undefined;\n    this.privRoom = undefined;\n    this.privToken = undefined;\n    this.privManager = undefined;\n    this.privIsConnected = false;\n    this.privIsReady = false;\n    this.privParticipants = undefined;\n  }\n  connectTranscriberRecognizer(recognizer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privTranscriberRecognizer) {\n        yield this.privTranscriberRecognizer.close();\n      }\n      yield recognizer.enforceAudioGating();\n      this.privTranscriberRecognizer = recognizer;\n      this.privTranscriberRecognizer.conversation = this;\n    });\n  }\n  getKeepAlive() {\n    const nickname = !!this.me ? this.me.displayName : \"default_nickname\";\n    return JSON.stringify({\n      id: \"0\",\n      nickname,\n      participantId: this.privRoom.participantId,\n      roomId: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.keepAlive\n    });\n  }\n  /* eslint-enable @typescript-eslint/typedef */\n  addParticipantImplAsync(participant) {\n    const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);\n    if (newParticipant !== undefined) {\n      if (!!this.privTranscriberRecognizer) {\n        const conversationInfo = this.conversationInfo;\n        conversationInfo.participants = [participant];\n        return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"join\");\n      }\n    }\n  }\n  removeParticipantImplAsync(participant) {\n    this.privParticipants.deleteParticipant(participant.id);\n    const conversationInfo = this.conversationInfo;\n    conversationInfo.participants = [participant];\n    return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"leave\");\n  }\n  close(dispose) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.privIsConnected = false;\n        yield (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.close();\n        this.privConversationRecognizer = undefined;\n        if (!!this.privConversationTranslator) {\n          this.privConversationTranslator.dispose();\n        }\n      } catch (e) {\n        // ignore error\n        throw e;\n      }\n      if (dispose) {\n        this.dispose();\n      }\n    });\n  }\n  /** Helpers */\n  handleCallback(cb, err) {\n    if (!!cb) {\n      try {\n        cb();\n      } catch (e) {\n        if (!!err) {\n          err(e);\n        }\n      }\n      cb = undefined;\n    }\n  }\n  handleError(error, err) {\n    if (!!err) {\n      if (error instanceof Error) {\n        const typedError = error;\n        err(typedError.name + \": \" + typedError.message);\n      } else {\n        err(error);\n      }\n    }\n  }\n  /** Participant Helpers */\n  toParticipants(includeHost) {\n    const participants = this.privParticipants.participants.map(p => this.toParticipant(p));\n    if (!includeHost) {\n      return participants.filter(p => p.isHost === false);\n    } else {\n      return participants;\n    }\n  }\n  toParticipant(p) {\n    return new Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);\n  }\n  getMuteAllCommand(isMuted) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.setMuteAll,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: isMuted\n    });\n  }\n  getMuteCommand(participantId, isMuted) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.setMute,\n      // eslint-disable-next-line object-shorthand\n      participantId: participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: isMuted\n    });\n  }\n  getLockCommand(isLocked) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.setLockState,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: isLocked\n    });\n  }\n  getEjectCommand(participantId) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.ejectParticipant,\n      // eslint-disable-next-line object-shorthand\n      participantId: participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand\n    });\n  }\n  getSetTranslateToLanguagesCommand(languages) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.setTranslateToLanguages,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: languages\n    });\n  }\n  getChangeNicknameCommand(nickname) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.changeNickname,\n      nickname,\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: nickname\n    });\n  }\n  getMessageCommand(message) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    Contracts.throwIfNullOrWhitespace(message, \"message\");\n    return JSON.stringify({\n      participantId: this.privRoom.participantId,\n      roomId: this.privRoom.roomId,\n      text: message,\n      type: ConversationTranslatorMessageTypes.instantMessage\n    });\n  }\n}","map":{"version":3,"names":["ConversationConnectionConfig","ConversationManager","ConversationRecognizerFactory","ConversationTranslatorCommandTypes","ConversationTranslatorMessageTypes","InternalParticipants","marshalPromiseToCallbacks","Contracts","ConversationParticipantsChangedEventArgs","ConversationTranslationEventArgs","Participant","ParticipantChangedReason","ProfanityOption","PropertyCollection","PropertyId","Conversation","constructor","createConversationAsync","speechConfig","arg2","arg3","arg4","throwIfNullOrUndefined","restErrors","invalidArgs","replace","region","subscriptionKey","getProperty","SpeechServiceAuthorization_Token","conversationImpl","cb","err","ConversationImpl","__awaiter","error","id","privErrors","onConnected","e","privIsConnected","_a","privConversationTranslator","sessionStarted","onDisconnected","sessionStopped","close","onCanceled","r","canceled","onParticipantUpdateCommandReceived","updatedParticipant","privParticipants","getParticipant","undefined","key","changeNickname","displayName","value","setUseTTS","isUsingTts","setProfanityFiltering","profanity","setMute","isMuted","setTranslateToLanguages","translateToLanguages","addOrUpdateParticipant","participantsChanged","Updated","toParticipant","sessionId","onLockRoomCommandReceived","onMuteAllCommandReceived","participants","forEach","p","isHost","toParticipants","onParticipantJoinCommandReceived","newParticipant","participant","JoinedConversation","onParticipantLeaveCommandReceived","ejectedParticipant","deleteParticipant","LeftConversation","onTranslationReceived","command","final","transcribed","payload","partial","transcribing","instantMessage","textMessageReceived","onParticipantsListReceived","sessionToken","privRoom","token","me","privIsReady","nickname","properties","ConversationTranslator_Name","length","changeNicknameAsync","onConversationExpiration","conversationExpiration","privIsDisposed","privConversationId","privProperties","privManager","language","SpeechServiceConnection_RecoLanguage","setProperty","defaultLanguageCode","privLanguage","targetLanguages","addTargetLanguage","SpeechServiceResponse_ProfanityOption","setProfanity","Masked","hostNickname","throwIfNullOrTooLong","throwIfNullOrTooShort","privConfig","configImpl","throwIfNull","clone","privTextMessageMaxLength","room","connection","privConversationRecognizer","config","conversationId","roomId","speechRecognitionLanguage","isMutedByHost","_b","isConnected","host","transcriberRecognizer","privTranscriberRecognizer","conversationInfo","convId","map","part","preferredLanguage","voice","props","transcriptionEventKeys","val","info","conversationProperties","canSend","canSendAsHost","authorizationToken","privToken","throwIfNullOrWhitespace","conversationTranslator","onToken","handleError","Error","permissionDeniedStart","createOrJoin","permissionDeniedConnect","handleCallback","startConversationAsync","meId","participantId","fromConfig","connected","disconnected","participantUpdateCommandReceived","lockRoomCommandReceived","muteAllCommandReceived","participantJoinCommandReceived","participantLeaveCommandReceived","translationReceived","participantsListReceived","connect","addParticipantAsync","addParticipantImplAsync","joinConversationAsync","lang","cognitiveSpeechAuthToken","deleteConversationAsync","deleteConversationImplAsync","leave","dispose","endConversationAsync","endConversationImplAsync","lockConversationAsync","throwIfDisposed","isDisposed","permissionDeniedSend","permissionDeniedConversation","sendRequest","getLockCommand","muteAllParticipantsAsync","getMuteAllCommand","muteParticipantAsync","userId","permissionDeniedParticipant","exists","getParticipantIndex","invalidParticipantRequest","getMuteCommand","removeParticipantAsync","hasOwnProperty","removeParticipantImplAsync","user","index","findIndex","getEjectCommand","unlockConversationAsync","unmuteAllParticipantsAsync","unmuteParticipantAsync","sendTextMessageAsync","message","getMessageCommand","setTranslatedLanguagesAsync","languages","throwIfArrayEmptyOrWhitespace","getSetTranslateToLanguagesCommand","getChangeNicknameCommand","connectTranscriberRecognizer","recognizer","enforceAudioGating","conversation","getKeepAlive","JSON","stringify","type","keepAlive","pushConversationEvent","typedError","name","includeHost","filter","avatar","setMuteAll","roomid","participantCommand","isLocked","setLockState","ejectParticipant","text"],"sources":["src/sdk/Transcription/Conversation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n// Multi-device Conversation is a Preview feature.\r\n\r\n/* eslint-disable max-classes-per-file */\r\n\r\nimport {\r\n    ConversationConnectionConfig,\r\n    ConversationManager,\r\n    ConversationReceivedTranslationEventArgs,\r\n    ConversationRecognizer,\r\n    ConversationRecognizerFactory,\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IAuthentication,\r\n    IInternalConversation,\r\n    IInternalParticipant,\r\n    InternalParticipants,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs,\r\n    TranscriberRecognizer\r\n} from \"../../common.speech/Exports.js\";\r\nimport {\r\n    IDisposable,\r\n    IErrorMessages,\r\n    marshalPromiseToCallbacks\r\n} from \"../../common/Exports.js\";\r\nimport { Contracts } from \"../Contracts.js\";\r\nimport {\r\n    ConnectionEventArgs,\r\n    ConversationExpirationEventArgs,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationEventArgs,\r\n    ConversationTranslator,\r\n    Participant,\r\n    ParticipantChangedReason,\r\n    ProfanityOption,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    SpeechTranslationConfig,\r\n} from \"../Exports.js\";\r\nimport { SpeechTranslationConfigImpl } from \"../SpeechTranslationConfig.js\";\r\nimport { Callback, ConversationInfo, ConversationProperties, IConversation } from \"./IConversation.js\";\r\nimport { IParticipant, IUser, TranscriptionParticipant } from \"./IParticipant.js\";\r\n\r\nexport abstract class Conversation implements IConversation {\r\n\r\n    protected constructor() {\r\n        return;\r\n    }\r\n\r\n    public abstract get authorizationToken(): string;\r\n\r\n    public abstract get config(): SpeechTranslationConfig;\r\n\r\n    public abstract get conversationId(): string;\r\n    public abstract get conversationInfo(): ConversationInfo;\r\n    public abstract get properties(): PropertyCollection;\r\n    public abstract get speechRecognitionLanguage(): string;\r\n    public abstract get participants(): Participant[];\r\n    public abstract set authorizationToken(value: string);\r\n    public abstract get isConnected(): boolean;\r\n\r\n    /**\r\n     * Create a conversation\r\n     * @param speechConfig\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public static createConversationAsync(speechConfig: SpeechTranslationConfig, arg2?: string | Callback, arg3?: Callback, arg4?: Callback): Conversation {\r\n        Contracts.throwIfNullOrUndefined(speechConfig, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\r\n        Contracts.throwIfNullOrUndefined(speechConfig.region, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\r\n        if (!speechConfig.subscriptionKey && !speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceAuthorization_Token])) {\r\n            Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\r\n        }\r\n        let conversationImpl: ConversationImpl;\r\n        let cb: Callback;\r\n        let err: Callback;\r\n        if (typeof arg2 === \"string\") {\r\n            conversationImpl = new ConversationImpl(speechConfig, arg2);\r\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n            marshalPromiseToCallbacks((async (): Promise<void> => {})(), arg3, arg4);\r\n        } else {\r\n            conversationImpl = new ConversationImpl(speechConfig);\r\n            cb = arg2;\r\n            err = arg3;\r\n            conversationImpl.createConversationAsync(\r\n                ((): void => {\r\n                    if (!!cb) {\r\n                        cb();\r\n                    }\r\n                }),\r\n                (error: any): void => {\r\n                    if (!!err) {\r\n                        err(error);\r\n                    }\r\n                });\r\n        }\r\n        return conversationImpl;\r\n\r\n    }\r\n\r\n    /** Start a conversation. */\r\n    public abstract startConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Delete a conversation. After this no one will be able to join the conversation. */\r\n    public abstract deleteConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** End a conversation. */\r\n    public abstract endConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Lock a conversation. This will prevent new participants from joining. */\r\n    public abstract lockConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Add Participant to Conversation. */\r\n    public abstract addParticipantAsync(participant: IParticipant, cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Mute all other participants in the conversation. After this no other participants will\r\n     * have their speech recognitions broadcast, nor be able to send text messages.\r\n     */\r\n    public abstract muteAllParticipantsAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Mute a participant.\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract muteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Remove a participant from a conversation using the user id, Participant or User object\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract removeParticipantAsync(userId: string | IParticipant | IUser, cb?: Callback, err?: Callback): void;\r\n\r\n    /** Unlocks a conversation. */\r\n    public abstract unlockConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Unmute all other participants in the conversation. */\r\n    public abstract unmuteAllParticipantsAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Unmute a participant.\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract unmuteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void;\r\n}\r\n\r\nexport class ConversationImpl extends Conversation implements IDisposable {\r\n\r\n    private privConfig: SpeechTranslationConfig;\r\n    private privProperties: PropertyCollection;\r\n    private privLanguage: string;\r\n    private privToken: string;\r\n    private privIsDisposed: boolean;\r\n    private privRoom: IInternalConversation;\r\n    private privManager: ConversationManager;\r\n    private privConversationRecognizer: ConversationRecognizer;\r\n    private privIsConnected: boolean;\r\n    private privParticipants: InternalParticipants;\r\n    private privIsReady: boolean;\r\n    private privConversationTranslator: ConversationTranslator;\r\n    private privTranscriberRecognizer: TranscriberRecognizer;\r\n    private privErrors: IErrorMessages = ConversationConnectionConfig.restErrors;\r\n    private privConversationId: string;\r\n    private readonly privTextMessageMaxLength: number;\r\n\r\n    /**\r\n     * Create a conversation impl\r\n     * @param speechConfig\r\n     * @param {string} id - optional conversationId\r\n     */\r\n    public constructor(speechConfig: SpeechTranslationConfig, id?: string) {\r\n        super();\r\n        this.privIsConnected = false;\r\n        this.privIsDisposed = false;\r\n        this.privConversationId = \"\";\r\n        this.privProperties = new PropertyCollection();\r\n        this.privManager = new ConversationManager();\r\n\r\n        // check the speech language\r\n        const language: string = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\r\n        if (!language) {\r\n            speechConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], ConversationConnectionConfig.defaultLanguageCode);\r\n        }\r\n        this.privLanguage = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\r\n\r\n        if (!id) {\r\n            // check the target language(s)\r\n            if (speechConfig.targetLanguages.length === 0) {\r\n                speechConfig.addTargetLanguage(this.privLanguage);\r\n            }\r\n\r\n            // check the profanity setting: speech and conversationTranslator should be in sync\r\n            const profanity: string = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption]);\r\n            if (!profanity) {\r\n                speechConfig.setProfanity(ProfanityOption.Masked);\r\n            }\r\n            // check the nickname: it should pass this regex: ^\\w+([\\s-][\\w\\(\\)]+)*$\"\r\n            // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error\r\n            // TODO: check what the max length is and if a truncation is required or if the service handles it without an error\r\n            let hostNickname: string = speechConfig.getProperty(PropertyId[PropertyId.ConversationTranslator_Name]);\r\n            if (hostNickname === undefined || hostNickname === null) {\r\n                hostNickname = \"Host\";\r\n            }\r\n            Contracts.throwIfNullOrTooLong(hostNickname, \"nickname\", 50);\r\n            Contracts.throwIfNullOrTooShort(hostNickname, \"nickname\", 2);\r\n            speechConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], hostNickname);\r\n\r\n        } else {\r\n            this.privConversationId = id;\r\n        }\r\n\r\n        // save the speech config for future usage\r\n        this.privConfig = speechConfig;\r\n\r\n        // save the config properties\r\n        const configImpl = speechConfig as SpeechTranslationConfigImpl;\r\n        Contracts.throwIfNull(configImpl, \"speechConfig\");\r\n        this.privProperties = configImpl.properties.clone();\r\n        this.privIsConnected = false;\r\n        this.privParticipants = new InternalParticipants();\r\n        this.privIsReady = false;\r\n        this.privTextMessageMaxLength = 1000;\r\n    }\r\n\r\n    // get the internal data about a conversation\r\n    public get room(): IInternalConversation {\r\n        return this.privRoom;\r\n    }\r\n\r\n    // get the wrapper for connecting to the websockets\r\n    public get connection(): ConversationRecognizer {\r\n        return this.privConversationRecognizer; // this.privConnection;\r\n    }\r\n\r\n    // get the config\r\n    public get config(): SpeechTranslationConfig {\r\n        return this.privConfig;\r\n    }\r\n\r\n    // get the conversation Id\r\n    public get conversationId(): string {\r\n        return this.privRoom ? this.privRoom.roomId : this.privConversationId;\r\n    }\r\n\r\n    // get the properties\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    // get the speech language\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privLanguage;\r\n    }\r\n\r\n    public get isMutedByHost(): boolean {\r\n        return this.privParticipants.me?.isHost ? false : this.privParticipants.me?.isMuted;\r\n    }\r\n\r\n    public get isConnected(): boolean {\r\n        return this.privIsConnected && this.privIsReady;\r\n    }\r\n\r\n    public get participants(): Participant[] {\r\n        return this.toParticipants(true);\r\n    }\r\n\r\n    public get me(): Participant {\r\n        return this.toParticipant(this.privParticipants.me);\r\n    }\r\n\r\n    public get host(): Participant {\r\n        return this.toParticipant(this.privParticipants.host);\r\n    }\r\n\r\n    public get transcriberRecognizer(): TranscriberRecognizer {\r\n        return this.privTranscriberRecognizer;\r\n    }\r\n\r\n    public get conversationInfo(): ConversationInfo {\r\n        const convId: string = this.conversationId;\r\n        const p: TranscriptionParticipant[] = this.participants.map((part: Participant): TranscriptionParticipant => (\r\n            {\r\n                id: part.id,\r\n                preferredLanguage: part.preferredLanguage,\r\n                voice: part.voice\r\n            }\r\n        ));\r\n        const props: ConversationProperties = {};\r\n        for (const key of ConversationConnectionConfig.transcriptionEventKeys) {\r\n            const val: string = this.properties.getProperty(key, \"\");\r\n            if (val !== \"\") {\r\n                props[key] = val;\r\n            }\r\n        }\r\n        const info: ConversationInfo = { id: convId, participants: p, conversationProperties: props };\r\n        return info;\r\n    }\r\n\r\n    private get canSend(): boolean {\r\n        return this.privIsConnected && !this.privParticipants.me?.isMuted;\r\n    }\r\n\r\n    private get canSendAsHost(): boolean {\r\n        return this.privIsConnected && this.privParticipants.me?.isHost;\r\n    }\r\n\r\n    // get / set the speech auth token\r\n    // eslint-disable-next-line @typescript-eslint/member-ordering\r\n    public get authorizationToken(): string {\r\n        return this.privToken;\r\n    }\r\n\r\n    public set authorizationToken(value: string) {\r\n        Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\r\n        this.privToken = value;\r\n    }\r\n\r\n    public set conversationTranslator(conversationTranslator: ConversationTranslator) {\r\n        this.privConversationTranslator = conversationTranslator;\r\n    }\r\n\r\n    public onToken(token: IAuthentication): void {\r\n        this.privConversationTranslator.onToken(token);\r\n    }\r\n\r\n    /**\r\n     * Create a new conversation as Host\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public createConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            if (!!this.privConversationRecognizer) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\r\n            }\r\n            this.privManager.createOrJoin(this.privProperties, undefined,\r\n                ((room: IInternalConversation): void => {\r\n                    if (!room) {\r\n                        this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);\r\n                    }\r\n                    this.privRoom = room;\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any): void => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a new conversation as host.\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public startConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            // check if there is already a recognizer\r\n            if (!!this.privConversationRecognizer) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\r\n            }\r\n            // check if there is conversation data available\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);\r\n            // connect to the conversation websocket\r\n            this.privParticipants.meId = this.privRoom.participantId;\r\n            this.privConversationRecognizer = ConversationRecognizerFactory.fromConfig(this, this.privConfig);\r\n\r\n            // Because ConversationTranslator manually sets up and manages the connection, Conversation\r\n            // has to forward serviceRecognizer connection events that usually get passed automatically\r\n            this.privConversationRecognizer.connected = this.onConnected;\r\n            this.privConversationRecognizer.disconnected = this.onDisconnected;\r\n            this.privConversationRecognizer.canceled = this.onCanceled;\r\n\r\n            this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\r\n            this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\r\n            this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\r\n            this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\r\n            this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\r\n            this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\r\n            this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\r\n            this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\r\n\r\n            this.privConversationRecognizer.connect(this.privRoom.token,\r\n                ((): void => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any): void => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Join a conversation as a participant.\r\n     * @param { IParticipant } participant - participant to add\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public addParticipantAsync(participant: IParticipant, cb?: Callback, err?: Callback): void {\r\n        Contracts.throwIfNullOrUndefined(participant, \"Participant\");\r\n        marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Join a conversation as a participant.\r\n     * @param conversation\r\n     * @param nickname\r\n     * @param lang\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public joinConversationAsync(conversationId: string, nickname: string, lang: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            // TODO\r\n            // if (!!this.privConversationRecognizer) {\r\n            //     throw new Error(this.privErrors.permissionDeniedStart);\r\n            // }\r\n            Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\r\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n            Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\"));\r\n            // join the conversation\r\n            this.privManager.createOrJoin(this.privProperties, conversationId,\r\n                ((room: IInternalConversation): void => {\r\n                    Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);\r\n                    this.privRoom = room;\r\n                    this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;\r\n                    // join callback\r\n                    if (!!cb) {\r\n                        cb(room.cognitiveSpeechAuthToken);\r\n                    }\r\n                }),\r\n                ((error: any): void => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes a conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public deleteConversationAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb, err);\r\n    }\r\n\r\n    public async deleteConversationImplAsync(): Promise<void> {\r\n            Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\r\n            await this.privManager.leave(this.privProperties, this.privRoom.token);\r\n\r\n            this.dispose();\r\n    }\r\n\r\n    /**\r\n     * Issues a request to close the client websockets\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public endConversationAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks(this.endConversationImplAsync(), cb, err);\r\n    }\r\n\r\n    public endConversationImplAsync(): Promise<void> {\r\n        return this.close(true);\r\n    }\r\n\r\n    /**\r\n     * Issues a request to lock the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public lockConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getLockCommand(true),\r\n                    ((): void => {\r\n                        this.handleCallback(cb, err);\r\n                    }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to mute the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public muteAllParticipantsAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the user's permissions\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true),\r\n                    ((): void => {\r\n                        this.handleCallback(cb, err);\r\n                    }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to mute a participant in the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public muteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the connection is open (host + participant can perform the mute command)\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // if not host, check the participant is not muting another participant\r\n            if (!this.me.isHost && this.me.id !== userId) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            // check the user exists\r\n            const exists: number = this.privParticipants.getParticipantIndex(userId);\r\n            if (exists === -1) {\r\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), ((): void => {\r\n                        this.handleCallback(cb, err);\r\n                    }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to remove a participant from the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public removeParticipantAsync(userId: string | IParticipant | IUser, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            if (!!this.privTranscriberRecognizer && userId.hasOwnProperty(\"id\")) {\r\n                // Assume this is a transcription participant\r\n                marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId as IParticipant), cb, err);\r\n            } else {\r\n                Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n                Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n                if (!this.canSendAsHost) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\r\n                }\r\n                let participantId = \"\";\r\n                if (typeof userId === \"string\") {\r\n                    participantId = userId;\r\n                } else if (userId.hasOwnProperty(\"id\")) {\r\n                    const participant: IParticipant = userId as IParticipant;\r\n                    participantId = participant.id;\r\n                } else if (userId.hasOwnProperty(\"userId\")) {\r\n                    const user: IUser = userId as IUser;\r\n                    participantId = user.userId;\r\n                }\r\n                Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n                // check the participant exists\r\n                const index: number = this.participants.findIndex((p: Participant): boolean => p.id === participantId);\r\n                if (index === -1) {\r\n                    this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n                }\r\n                if (!!this.privConversationRecognizer) {\r\n                    this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId), ((): void => {\r\n                        this.handleCallback(cb, err);\r\n                    }),\r\n                        ((error: any): void => {\r\n                            this.handleError(error, err);\r\n                        }));\r\n                }\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unlock the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unlockConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getLockCommand(false), ((): void => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n                }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unmute all participants in the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unmuteAllParticipantsAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), ((): void => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unmute a participant in the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unmuteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the connection is open (host + participant can perform the mute command)\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // if not host, check the participant is not muting another participant\r\n            if (!this.me.isHost && this.me.id !== userId) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            // check the user exists\r\n            const exists: number = this.privParticipants.getParticipantIndex(userId);\r\n            if (exists === -1) {\r\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), ((): void => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a text message\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public sendTextMessageAsync(message: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // TODO: is a max length check required?\r\n            if (message.length > this.privTextMessageMaxLength) {\r\n                this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), ((): void => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set translated to languages\r\n     * @param {string[]} languages - languages to translate to\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public setTranslatedLanguagesAsync(languages: string[], cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace(\"{arg}\", \"languages\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages),\r\n                    ((): void => {\r\n                        this.handleCallback(cb, err);\r\n                    }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change nickname\r\n     * @param {string} nickname - new nickname for the room\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public changeNicknameAsync(nickname: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            if (!!this.privConversationRecognizer) {\r\n                this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname),\r\n                    ((): void => {\r\n                        this.handleCallback(cb, err);\r\n                    }),\r\n                    ((error: any): void => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.isDisposed) {\r\n            return;\r\n        }\r\n        this.privIsDisposed = true;\r\n        if (!!this.config) {\r\n            this.config.close();\r\n        }\r\n        this.privConfig = undefined;\r\n        this.privLanguage = undefined;\r\n        this.privProperties = undefined;\r\n        this.privRoom = undefined;\r\n        this.privToken = undefined;\r\n        this.privManager = undefined;\r\n        this.privIsConnected = false;\r\n        this.privIsReady = false;\r\n        this.privParticipants = undefined;\r\n    }\r\n\r\n    public async connectTranscriberRecognizer(recognizer: TranscriberRecognizer): Promise<void> {\r\n        if (!!this.privTranscriberRecognizer) {\r\n            await this.privTranscriberRecognizer.close();\r\n        }\r\n        await recognizer.enforceAudioGating();\r\n        this.privTranscriberRecognizer = recognizer;\r\n        this.privTranscriberRecognizer.conversation = this;\r\n    }\r\n\r\n    public getKeepAlive(): string {\r\n        const nickname: string = (!!this.me) ? this.me.displayName : \"default_nickname\";\r\n        return JSON.stringify({\r\n            id: \"0\",\r\n            nickname,\r\n            participantId: this.privRoom.participantId,\r\n            roomId: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.keepAlive\r\n        });\r\n    }\r\n\r\n    /** websocket callbacks */\r\n    /* eslint-disable @typescript-eslint/typedef */\r\n    private onConnected = (e: ConnectionEventArgs): void => {\r\n        this.privIsConnected = true;\r\n        try {\r\n            if (!!this.privConversationTranslator?.sessionStarted) {\r\n                this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onDisconnected = (e: ConnectionEventArgs): void => {\r\n        try {\r\n            if (!!this.privConversationTranslator?.sessionStopped) {\r\n                this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        } finally {\r\n            void this.close(false);\r\n        }\r\n    };\r\n\r\n    private onCanceled = (r: ConversationRecognizer, e: ConversationTranslationCanceledEventArgs): void => {\r\n        try {\r\n            if (!!this.privConversationTranslator?.canceled) {\r\n                this.privConversationTranslator.canceled(this.privConversationTranslator, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onParticipantUpdateCommandReceived = (r: ConversationRecognizer, e: ParticipantAttributeEventArgs): void => {\r\n        try {\r\n            const updatedParticipant: IInternalParticipant = this.privParticipants.getParticipant(e.id);\r\n            if (updatedParticipant !== undefined) {\r\n\r\n                switch (e.key) {\r\n                    case ConversationTranslatorCommandTypes.changeNickname:\r\n                        updatedParticipant.displayName = e.value as string;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setUseTTS:\r\n                        updatedParticipant.isUsingTts = e.value as boolean;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setProfanityFiltering:\r\n                        updatedParticipant.profanity = e.value as boolean;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setMute:\r\n                        updatedParticipant.isMuted = e.value as boolean;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setTranslateToLanguages:\r\n                        updatedParticipant.translateToLanguages = e.value as string[];\r\n                        break;\r\n                }\r\n                this.privParticipants.addOrUpdateParticipant(updatedParticipant);\r\n\r\n                if (!!this.privConversationTranslator) {\r\n                    this.privConversationTranslator.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated,\r\n                            [this.toParticipant(updatedParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onLockRoomCommandReceived = (): void => {\r\n        // TODO\r\n    };\r\n\r\n    private onMuteAllCommandReceived = (r: ConversationRecognizer, e: MuteAllEventArgs): void => {\r\n        try {\r\n            this.privParticipants.participants.forEach((p: IInternalParticipant): boolean => p.isMuted = (p.isHost ? false : e.isMuted));\r\n            if (!!this.privConversationTranslator) {\r\n                this.privConversationTranslator.participantsChanged(\r\n                    this.privConversationTranslator,\r\n                    new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated,\r\n                        this.toParticipants(false), e.sessionId));\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onParticipantJoinCommandReceived = (r: ConversationRecognizer, e: ParticipantEventArgs): void => {\r\n        try {\r\n            const newParticipant: IInternalParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);\r\n            if (newParticipant !== undefined) {\r\n                if (!!this.privConversationTranslator) {\r\n                    this.privConversationTranslator.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation,\r\n                            [this.toParticipant(newParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onParticipantLeaveCommandReceived = (r: ConversationRecognizer, e: ParticipantEventArgs): void => {\r\n        try {\r\n            const ejectedParticipant: IInternalParticipant = this.privParticipants.getParticipant(e.participant.id);\r\n            if (ejectedParticipant !== undefined) {\r\n                // remove the participant from the internal participants list\r\n                this.privParticipants.deleteParticipant(e.participant.id);\r\n                if (!!this.privConversationTranslator) {\r\n                    // notify subscribers that the participant has left the conversation\r\n                    this.privConversationTranslator.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.LeftConversation,\r\n                            [this.toParticipant(ejectedParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onTranslationReceived = (r: ConversationRecognizer, e: ConversationReceivedTranslationEventArgs): void => {\r\n        try {\r\n            switch (e.command) {\r\n                case ConversationTranslatorMessageTypes.final:\r\n                    if (!!this.privConversationTranslator) {\r\n                        this.privConversationTranslator.transcribed(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n                case ConversationTranslatorMessageTypes.partial:\r\n                    if (!!this.privConversationTranslator) {\r\n                        this.privConversationTranslator.transcribing(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n                case ConversationTranslatorMessageTypes.instantMessage:\r\n                    if (!!this.privConversationTranslator) {\r\n                        this.privConversationTranslator.textMessageReceived(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onParticipantsListReceived = (r: ConversationRecognizer, e: ParticipantsListEventArgs): void => {\r\n        try {\r\n            // check if the session token needs to be updated\r\n            if (e.sessionToken !== undefined && e.sessionToken !== null) {\r\n                this.privRoom.token = e.sessionToken;\r\n            }\r\n            // save the participants\r\n            this.privParticipants.participants = [...e.participants];\r\n            // enable the conversation\r\n            if (this.privParticipants.me !== undefined) {\r\n                this.privIsReady = true;\r\n            }\r\n            if (!!this.privConversationTranslator) {\r\n                this.privConversationTranslator.participantsChanged(\r\n                    this.privConversationTranslator,\r\n                    new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));\r\n            }\r\n            // if this is the host, update the nickname if needed\r\n            if (this.me.isHost) {\r\n                const nickname: string = this.privConversationTranslator?.properties.getProperty(PropertyId.ConversationTranslator_Name);\r\n                if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {\r\n                    // issue a change nickname request\r\n                    this.changeNicknameAsync(nickname);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n\r\n    private onConversationExpiration = (r: ConversationRecognizer, e: ConversationExpirationEventArgs): void => {\r\n        try {\r\n            if (!!this.privConversationTranslator) {\r\n                this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    };\r\n    /* eslint-enable @typescript-eslint/typedef */\r\n\r\n    private addParticipantImplAsync(participant: IParticipant): Promise<void> {\r\n        const newParticipant: IInternalParticipant = this.privParticipants.addOrUpdateParticipant(participant);\r\n        if (newParticipant !== undefined) {\r\n            if (!!this.privTranscriberRecognizer) {\r\n                const conversationInfo = this.conversationInfo;\r\n                conversationInfo.participants = [participant];\r\n                return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"join\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeParticipantImplAsync(participant: IParticipant): Promise<void> {\r\n        this.privParticipants.deleteParticipant(participant.id);\r\n        const conversationInfo = this.conversationInfo;\r\n        conversationInfo.participants = [participant];\r\n        return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"leave\");\r\n    }\r\n\r\n    private async close(dispose: boolean): Promise<void> {\r\n        try {\r\n            this.privIsConnected = false;\r\n            await this.privConversationRecognizer?.close();\r\n            this.privConversationRecognizer = undefined;\r\n            if (!!this.privConversationTranslator) {\r\n                this.privConversationTranslator.dispose();\r\n            }\r\n        } catch (e) {\r\n            // ignore error\r\n            throw e;\r\n        }\r\n        if (dispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /** Helpers */\r\n    private handleCallback(cb: () => void, err: (message: string) => void): void {\r\n        if (!!cb) {\r\n            try {\r\n                cb();\r\n            } catch (e) {\r\n                if (!!err) {\r\n                    err(e as string);\r\n                }\r\n            }\r\n            cb = undefined;\r\n        }\r\n    }\r\n\r\n    private handleError(error: any, err: (message: string) => void): void {\r\n        if (!!err) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error;\r\n                err(typedError.name + \": \" + typedError.message);\r\n\r\n            } else {\r\n                err(error as string);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Participant Helpers */\r\n    private toParticipants(includeHost: boolean): Participant[] {\r\n\r\n        const participants: Participant[] = this.privParticipants.participants.map((p: IInternalParticipant): Participant => ( this.toParticipant(p) ) );\r\n        if (!includeHost) {\r\n            return participants.filter((p: Participant): boolean => p.isHost === false);\r\n        } else {\r\n            return participants;\r\n        }\r\n    }\r\n\r\n    private toParticipant(p: IInternalParticipant): Participant {\r\n        return new Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);\r\n    }\r\n\r\n    private getMuteAllCommand(isMuted: boolean): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.setMuteAll,\r\n            participantId: this.privRoom.participantId, // the id of the host\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: isMuted\r\n        });\r\n    }\r\n\r\n    private getMuteCommand(participantId: string, isMuted: boolean): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.setMute,\r\n            // eslint-disable-next-line object-shorthand\r\n            participantId: participantId,\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: isMuted\r\n        });\r\n    }\r\n\r\n    private getLockCommand(isLocked: boolean): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.setLockState,\r\n            participantId: this.privRoom.participantId,\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: isLocked\r\n        });\r\n    }\r\n\r\n    private getEjectCommand(participantId: string): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.ejectParticipant,\r\n            // eslint-disable-next-line object-shorthand\r\n            participantId: participantId,\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n        });\r\n    }\r\n\r\n    private getSetTranslateToLanguagesCommand(languages: string[]): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n            participantId: this.privRoom.participantId, // the id of the host\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: languages\r\n        });\r\n    }\r\n\r\n    private getChangeNicknameCommand(nickname: string): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.changeNickname,\r\n            nickname,\r\n            participantId: this.privRoom.participantId, // the id of the host\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: nickname\r\n        });\r\n    }\r\n\r\n    private getMessageCommand(message: string): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n        Contracts.throwIfNullOrWhitespace(message, \"message\");\r\n\r\n        return JSON.stringify({\r\n            participantId: this.privRoom.participantId,\r\n            roomId: this.privRoom.roomId,\r\n            text: message,\r\n            type: ConversationTranslatorMessageTypes.instantMessage\r\n        });\r\n    }\r\n\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAEA,SACIA,4BAA4B,EAC5BC,mBAAmB,EAGnBC,6BAA6B,EAC7BC,kCAAkC,EAClCC,kCAAkC,EAIlCC,oBAAoB,QAMjB,gCAAgC;AACvC,SAGIC,yBAAyB,QACtB,yBAAyB;AAChC,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAGIC,wCAAwC,EAExCC,gCAAgC,EAEhCC,WAAW,EACXC,wBAAwB,EACxBC,eAAe,EACfC,kBAAkB,EAClBC,UAAU,QAEP,eAAe;AAKtB,OAAM,MAAgBC,YAAY;EAE9BC,YAAA;IACI;EACJ;EAcA;;;;;;EAMO,OAAOC,uBAAuBA,CAACC,YAAqC,EAAEC,IAAwB,EAAEC,IAAe,EAAEC,IAAe;IACnId,SAAS,CAACe,sBAAsB,CAACJ,YAAY,EAAElB,4BAA4B,CAACuB,UAAU,CAACC,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC9HlB,SAAS,CAACe,sBAAsB,CAACJ,YAAY,CAACQ,MAAM,EAAE1B,4BAA4B,CAACuB,UAAU,CAACC,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,gCAAgC,CAAC,CAAC;IAC7J,IAAI,CAACP,YAAY,CAACS,eAAe,IAAI,CAACT,YAAY,CAACU,WAAW,CAACd,UAAU,CAACA,UAAU,CAACe,gCAAgC,CAAC,CAAC,EAAE;MACrHtB,SAAS,CAACe,sBAAsB,CAACJ,YAAY,CAACS,eAAe,EAAE3B,4BAA4B,CAACuB,UAAU,CAACC,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,6BAA6B,CAAC,CAAC;;IAEvK,IAAIK,gBAAkC;IACtC,IAAIC,EAAY;IAChB,IAAIC,GAAa;IACjB,IAAI,OAAOb,IAAI,KAAK,QAAQ,EAAE;MAC1BW,gBAAgB,GAAG,IAAIG,gBAAgB,CAACf,YAAY,EAAEC,IAAI,CAAC;MAC3D;MACAb,yBAAyB,CAAC,CAAC,MAA0B4B,SAAA,qCAAE,CAAC,GAAC,CAAE,EAAEd,IAAI,EAAEC,IAAI,CAAC;KAC3E,MAAM;MACHS,gBAAgB,GAAG,IAAIG,gBAAgB,CAACf,YAAY,CAAC;MACrDa,EAAE,GAAGZ,IAAI;MACTa,GAAG,GAAGZ,IAAI;MACVU,gBAAgB,CAACb,uBAAuB,CACnC,MAAW;QACR,IAAI,CAAC,CAACc,EAAE,EAAE;UACNA,EAAE,EAAE;;MAEZ,CAAC,EACAI,KAAU,IAAU;QACjB,IAAI,CAAC,CAACH,GAAG,EAAE;UACPA,GAAG,CAACG,KAAK,CAAC;;MAElB,CAAC,CAAC;;IAEV,OAAOL,gBAAgB;EAE3B;;AAgDJ,OAAM,MAAOG,gBAAiB,SAAQlB,YAAY;EAmB9C;;;;;EAKAC,YAAmBE,YAAqC,EAAEkB,EAAW;IACjE,KAAK,EAAE;IAVH,KAAAC,UAAU,GAAmBrC,4BAA4B,CAACuB,UAAU;IAoqB5E;IACA;IACQ,KAAAe,WAAW,GAAIC,CAAsB,IAAU;;MACnD,IAAI,CAACC,eAAe,GAAG,IAAI;MAC3B,IAAI;QACA,IAAI,CAAC,GAAAC,EAAA,GAAC,IAAI,CAACC,0BAA0B,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,cAAc,GAAE;UACnD,IAAI,CAACD,0BAA0B,CAACC,cAAc,CAAC,IAAI,CAACD,0BAA0B,EAAEH,CAAC,CAAC;;OAEzF,CAAC,OAAOA,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAAK,cAAc,GAAIL,CAAsB,IAAU;;MACtD,IAAI;QACA,IAAI,CAAC,GAAAE,EAAA,GAAC,IAAI,CAACC,0BAA0B,cAAAD,EAAA,uBAAAA,EAAA,CAAEI,cAAc,GAAE;UACnD,IAAI,CAACH,0BAA0B,CAACG,cAAc,CAAC,IAAI,CAACH,0BAA0B,EAAEH,CAAC,CAAC;;OAEzF,CAAC,OAAOA,CAAC,EAAE;QACR;MAAA,CACH,SAAS;QACN,KAAK,IAAI,CAACO,KAAK,CAAC,KAAK,CAAC;;IAE9B,CAAC;IAEO,KAAAC,UAAU,GAAG,CAACC,CAAyB,EAAET,CAA2C,KAAU;;MAClG,IAAI;QACA,IAAI,CAAC,GAAAE,EAAA,GAAC,IAAI,CAACC,0BAA0B,cAAAD,EAAA,uBAAAA,EAAA,CAAEQ,QAAQ,GAAE;UAC7C,IAAI,CAACP,0BAA0B,CAACO,QAAQ,CAAC,IAAI,CAACP,0BAA0B,EAAEH,CAAC,CAAC;;OAEnF,CAAC,OAAOA,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAAW,kCAAkC,GAAG,CAACF,CAAyB,EAAET,CAAgC,KAAU;MAC/G,IAAI;QACA,MAAMY,kBAAkB,GAAyB,IAAI,CAACC,gBAAgB,CAACC,cAAc,CAACd,CAAC,CAACH,EAAE,CAAC;QAC3F,IAAIe,kBAAkB,KAAKG,SAAS,EAAE;UAElC,QAAQf,CAAC,CAACgB,GAAG;YACT,KAAKpD,kCAAkC,CAACqD,cAAc;cAClDL,kBAAkB,CAACM,WAAW,GAAGlB,CAAC,CAACmB,KAAe;cAClD;YACJ,KAAKvD,kCAAkC,CAACwD,SAAS;cAC7CR,kBAAkB,CAACS,UAAU,GAAGrB,CAAC,CAACmB,KAAgB;cAClD;YACJ,KAAKvD,kCAAkC,CAAC0D,qBAAqB;cACzDV,kBAAkB,CAACW,SAAS,GAAGvB,CAAC,CAACmB,KAAgB;cACjD;YACJ,KAAKvD,kCAAkC,CAAC4D,OAAO;cAC3CZ,kBAAkB,CAACa,OAAO,GAAGzB,CAAC,CAACmB,KAAgB;cAC/C;YACJ,KAAKvD,kCAAkC,CAAC8D,uBAAuB;cAC3Dd,kBAAkB,CAACe,oBAAoB,GAAG3B,CAAC,CAACmB,KAAiB;cAC7D;;UAER,IAAI,CAACN,gBAAgB,CAACe,sBAAsB,CAAChB,kBAAkB,CAAC;UAEhE,IAAI,CAAC,CAAC,IAAI,CAACT,0BAA0B,EAAE;YACnC,IAAI,CAACA,0BAA0B,CAAC0B,mBAAmB,CAC/C,IAAI,CAAC1B,0BAA0B,EAC/B,IAAIlC,wCAAwC,CAACG,wBAAwB,CAAC0D,OAAO,EACzE,CAAC,IAAI,CAACC,aAAa,CAACnB,kBAAkB,CAAC,CAAC,EAAEZ,CAAC,CAACgC,SAAS,CAAC,CAAC;;;OAG1E,CAAC,OAAOhC,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAAiC,yBAAyB,GAAG,MAAW;MAC3C;IAAA,CACH;IAEO,KAAAC,wBAAwB,GAAG,CAACzB,CAAyB,EAAET,CAAmB,KAAU;MACxF,IAAI;QACA,IAAI,CAACa,gBAAgB,CAACsB,YAAY,CAACC,OAAO,CAAEC,CAAuB,IAAcA,CAAC,CAACZ,OAAO,GAAIY,CAAC,CAACC,MAAM,GAAG,KAAK,GAAGtC,CAAC,CAACyB,OAAQ,CAAC;QAC5H,IAAI,CAAC,CAAC,IAAI,CAACtB,0BAA0B,EAAE;UACnC,IAAI,CAACA,0BAA0B,CAAC0B,mBAAmB,CAC/C,IAAI,CAAC1B,0BAA0B,EAC/B,IAAIlC,wCAAwC,CAACG,wBAAwB,CAAC0D,OAAO,EACzE,IAAI,CAACS,cAAc,CAAC,KAAK,CAAC,EAAEvC,CAAC,CAACgC,SAAS,CAAC,CAAC;;OAExD,CAAC,OAAOhC,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAAwC,gCAAgC,GAAG,CAAC/B,CAAyB,EAAET,CAAuB,KAAU;MACpG,IAAI;QACA,MAAMyC,cAAc,GAAyB,IAAI,CAAC5B,gBAAgB,CAACe,sBAAsB,CAAC5B,CAAC,CAAC0C,WAAW,CAAC;QACxG,IAAID,cAAc,KAAK1B,SAAS,EAAE;UAC9B,IAAI,CAAC,CAAC,IAAI,CAACZ,0BAA0B,EAAE;YACnC,IAAI,CAACA,0BAA0B,CAAC0B,mBAAmB,CAC/C,IAAI,CAAC1B,0BAA0B,EAC/B,IAAIlC,wCAAwC,CAACG,wBAAwB,CAACuE,kBAAkB,EACpF,CAAC,IAAI,CAACZ,aAAa,CAACU,cAAc,CAAC,CAAC,EAAEzC,CAAC,CAACgC,SAAS,CAAC,CAAC;;;OAGtE,CAAC,OAAOhC,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAA4C,iCAAiC,GAAG,CAACnC,CAAyB,EAAET,CAAuB,KAAU;MACrG,IAAI;QACA,MAAM6C,kBAAkB,GAAyB,IAAI,CAAChC,gBAAgB,CAACC,cAAc,CAACd,CAAC,CAAC0C,WAAW,CAAC7C,EAAE,CAAC;QACvG,IAAIgD,kBAAkB,KAAK9B,SAAS,EAAE;UAClC;UACA,IAAI,CAACF,gBAAgB,CAACiC,iBAAiB,CAAC9C,CAAC,CAAC0C,WAAW,CAAC7C,EAAE,CAAC;UACzD,IAAI,CAAC,CAAC,IAAI,CAACM,0BAA0B,EAAE;YACnC;YACA,IAAI,CAACA,0BAA0B,CAAC0B,mBAAmB,CAC/C,IAAI,CAAC1B,0BAA0B,EAC/B,IAAIlC,wCAAwC,CAACG,wBAAwB,CAAC2E,gBAAgB,EAClF,CAAC,IAAI,CAAChB,aAAa,CAACc,kBAAkB,CAAC,CAAC,EAAE7C,CAAC,CAACgC,SAAS,CAAC,CAAC;;;OAG1E,CAAC,OAAOhC,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAAgD,qBAAqB,GAAG,CAACvC,CAAyB,EAAET,CAA2C,KAAU;MAC7G,IAAI;QACA,QAAQA,CAAC,CAACiD,OAAO;UACb,KAAKpF,kCAAkC,CAACqF,KAAK;YACzC,IAAI,CAAC,CAAC,IAAI,CAAC/C,0BAA0B,EAAE;cACnC,IAAI,CAACA,0BAA0B,CAACgD,WAAW,CACvC,IAAI,CAAChD,0BAA0B,EAC/B,IAAIjC,gCAAgC,CAAC8B,CAAC,CAACoD,OAAO,EAAErC,SAAS,EAAEf,CAAC,CAACgC,SAAS,CAAC,CAAC;;YAEhF;UACJ,KAAKnE,kCAAkC,CAACwF,OAAO;YAC3C,IAAI,CAAC,CAAC,IAAI,CAAClD,0BAA0B,EAAE;cACnC,IAAI,CAACA,0BAA0B,CAACmD,YAAY,CACxC,IAAI,CAACnD,0BAA0B,EAC/B,IAAIjC,gCAAgC,CAAC8B,CAAC,CAACoD,OAAO,EAAErC,SAAS,EAAEf,CAAC,CAACgC,SAAS,CAAC,CAAC;;YAEhF;UACJ,KAAKnE,kCAAkC,CAAC0F,cAAc;YAClD,IAAI,CAAC,CAAC,IAAI,CAACpD,0BAA0B,EAAE;cACnC,IAAI,CAACA,0BAA0B,CAACqD,mBAAmB,CAC/C,IAAI,CAACrD,0BAA0B,EAC/B,IAAIjC,gCAAgC,CAAC8B,CAAC,CAACoD,OAAO,EAAErC,SAAS,EAAEf,CAAC,CAACgC,SAAS,CAAC,CAAC;;YAEhF;;OAEX,CAAC,OAAOhC,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAAyD,0BAA0B,GAAG,CAAChD,CAAyB,EAAET,CAA4B,KAAU;;MACnG,IAAI;QACA;QACA,IAAIA,CAAC,CAAC0D,YAAY,KAAK3C,SAAS,IAAIf,CAAC,CAAC0D,YAAY,KAAK,IAAI,EAAE;UACzD,IAAI,CAACC,QAAQ,CAACC,KAAK,GAAG5D,CAAC,CAAC0D,YAAY;;QAExC;QACA,IAAI,CAAC7C,gBAAgB,CAACsB,YAAY,GAAG,CAAC,GAAGnC,CAAC,CAACmC,YAAY,CAAC;QACxD;QACA,IAAI,IAAI,CAACtB,gBAAgB,CAACgD,EAAE,KAAK9C,SAAS,EAAE;UACxC,IAAI,CAAC+C,WAAW,GAAG,IAAI;;QAE3B,IAAI,CAAC,CAAC,IAAI,CAAC3D,0BAA0B,EAAE;UACnC,IAAI,CAACA,0BAA0B,CAAC0B,mBAAmB,CAC/C,IAAI,CAAC1B,0BAA0B,EAC/B,IAAIlC,wCAAwC,CAACG,wBAAwB,CAACuE,kBAAkB,EAAE,IAAI,CAACJ,cAAc,CAAC,IAAI,CAAC,EAAEvC,CAAC,CAACgC,SAAS,CAAC,CAAC;;QAE1I;QACA,IAAI,IAAI,CAAC6B,EAAE,CAACvB,MAAM,EAAE;UAChB,MAAMyB,QAAQ,IAAA7D,EAAA,GAAW,IAAI,CAACC,0BAA0B,cAAAD,EAAA,uBAAAA,EAAA,CAAE8D,UAAU,CAAC3E,WAAW,CAACd,UAAU,CAAC0F,2BAA2B,CAAC;UACxH,IAAIF,QAAQ,KAAKhD,SAAS,IAAIgD,QAAQ,CAACG,MAAM,GAAG,CAAC,IAAIH,QAAQ,KAAK,IAAI,CAACF,EAAE,CAAC3C,WAAW,EAAE;YACnF;YACA,IAAI,CAACiD,mBAAmB,CAACJ,QAAQ,CAAC;;;OAG7C,CAAC,OAAO/D,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAEO,KAAAoE,wBAAwB,GAAG,CAAC3D,CAAyB,EAAET,CAAkC,KAAU;MACvG,IAAI;QACA,IAAI,CAAC,CAAC,IAAI,CAACG,0BAA0B,EAAE;UACnC,IAAI,CAACA,0BAA0B,CAACkE,sBAAsB,CAAC,IAAI,CAAClE,0BAA0B,EAAEH,CAAC,CAAC;;OAEjG,CAAC,OAAOA,CAAC,EAAE;QACR;MAAA;IAER,CAAC;IAz1BG,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACqE,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACC,kBAAkB,GAAG,EAAE;IAC5B,IAAI,CAACC,cAAc,GAAG,IAAIlG,kBAAkB,EAAE;IAC9C,IAAI,CAACmG,WAAW,GAAG,IAAI/G,mBAAmB,EAAE;IAE5C;IACA,MAAMgH,QAAQ,GAAW/F,YAAY,CAACU,WAAW,CAACd,UAAU,CAACA,UAAU,CAACoG,oCAAoC,CAAC,CAAC;IAC9G,IAAI,CAACD,QAAQ,EAAE;MACX/F,YAAY,CAACiG,WAAW,CAACrG,UAAU,CAACA,UAAU,CAACoG,oCAAoC,CAAC,EAAElH,4BAA4B,CAACoH,mBAAmB,CAAC;;IAE3I,IAAI,CAACC,YAAY,GAAGnG,YAAY,CAACU,WAAW,CAACd,UAAU,CAACA,UAAU,CAACoG,oCAAoC,CAAC,CAAC;IAEzG,IAAI,CAAC9E,EAAE,EAAE;MACL;MACA,IAAIlB,YAAY,CAACoG,eAAe,CAACb,MAAM,KAAK,CAAC,EAAE;QAC3CvF,YAAY,CAACqG,iBAAiB,CAAC,IAAI,CAACF,YAAY,CAAC;;MAGrD;MACA,MAAMvD,SAAS,GAAW5C,YAAY,CAACU,WAAW,CAACd,UAAU,CAACA,UAAU,CAAC0G,qCAAqC,CAAC,CAAC;MAChH,IAAI,CAAC1D,SAAS,EAAE;QACZ5C,YAAY,CAACuG,YAAY,CAAC7G,eAAe,CAAC8G,MAAM,CAAC;;MAErD;MACA;MACA;MACA,IAAIC,YAAY,GAAWzG,YAAY,CAACU,WAAW,CAACd,UAAU,CAACA,UAAU,CAAC0F,2BAA2B,CAAC,CAAC;MACvG,IAAImB,YAAY,KAAKrE,SAAS,IAAIqE,YAAY,KAAK,IAAI,EAAE;QACrDA,YAAY,GAAG,MAAM;;MAEzBpH,SAAS,CAACqH,oBAAoB,CAACD,YAAY,EAAE,UAAU,EAAE,EAAE,CAAC;MAC5DpH,SAAS,CAACsH,qBAAqB,CAACF,YAAY,EAAE,UAAU,EAAE,CAAC,CAAC;MAC5DzG,YAAY,CAACiG,WAAW,CAACrG,UAAU,CAACA,UAAU,CAAC0F,2BAA2B,CAAC,EAAEmB,YAAY,CAAC;KAE7F,MAAM;MACH,IAAI,CAACb,kBAAkB,GAAG1E,EAAE;;IAGhC;IACA,IAAI,CAAC0F,UAAU,GAAG5G,YAAY;IAE9B;IACA,MAAM6G,UAAU,GAAG7G,YAA2C;IAC9DX,SAAS,CAACyH,WAAW,CAACD,UAAU,EAAE,cAAc,CAAC;IACjD,IAAI,CAAChB,cAAc,GAAGgB,UAAU,CAACxB,UAAU,CAAC0B,KAAK,EAAE;IACnD,IAAI,CAACzF,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACY,gBAAgB,GAAG,IAAI/C,oBAAoB,EAAE;IAClD,IAAI,CAACgG,WAAW,GAAG,KAAK;IACxB,IAAI,CAAC6B,wBAAwB,GAAG,IAAI;EACxC;EAEA;EACA,IAAWC,IAAIA,CAAA;IACX,OAAO,IAAI,CAACjC,QAAQ;EACxB;EAEA;EACA,IAAWkC,UAAUA,CAAA;IACjB,OAAO,IAAI,CAACC,0BAA0B,CAAC,CAAC;EAC5C;EAEA;EACA,IAAWC,MAAMA,CAAA;IACb,OAAO,IAAI,CAACR,UAAU;EAC1B;EAEA;EACA,IAAWS,cAAcA,CAAA;IACrB,OAAO,IAAI,CAACrC,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACsC,MAAM,GAAG,IAAI,CAAC1B,kBAAkB;EACzE;EAEA;EACA,IAAWP,UAAUA,CAAA;IACjB,OAAO,IAAI,CAACQ,cAAc;EAC9B;EAEA;EACA,IAAW0B,yBAAyBA,CAAA;IAChC,OAAO,IAAI,CAACpB,YAAY;EAC5B;EAEA,IAAWqB,aAAaA,CAAA;;IACpB,OAAO,EAAAjG,EAAA,OAAI,CAACW,gBAAgB,CAACgD,EAAE,cAAA3D,EAAA,uBAAAA,EAAA,CAAEoC,MAAM,IAAG,KAAK,GAAE,CAAA8D,EAAA,GAAC,IAAI,CAACvF,gBAAgB,CAACgD,EAAE,cAAAuC,EAAA,uBAAAA,EAAA,CAAE3E,OAAO;EACvF;EAEA,IAAW4E,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACpG,eAAe,IAAI,IAAI,CAAC6D,WAAW;EACnD;EAEA,IAAW3B,YAAYA,CAAA;IACnB,OAAO,IAAI,CAACI,cAAc,CAAC,IAAI,CAAC;EACpC;EAEA,IAAWsB,EAAEA,CAAA;IACT,OAAO,IAAI,CAAC9B,aAAa,CAAC,IAAI,CAAClB,gBAAgB,CAACgD,EAAE,CAAC;EACvD;EAEA,IAAWyC,IAAIA,CAAA;IACX,OAAO,IAAI,CAACvE,aAAa,CAAC,IAAI,CAAClB,gBAAgB,CAACyF,IAAI,CAAC;EACzD;EAEA,IAAWC,qBAAqBA,CAAA;IAC5B,OAAO,IAAI,CAACC,yBAAyB;EACzC;EAEA,IAAWC,gBAAgBA,CAAA;IACvB,MAAMC,MAAM,GAAW,IAAI,CAACV,cAAc;IAC1C,MAAM3D,CAAC,GAA+B,IAAI,CAACF,YAAY,CAACwE,GAAG,CAAEC,IAAiB,KAC1E;MACI/G,EAAE,EAAE+G,IAAI,CAAC/G,EAAE;MACXgH,iBAAiB,EAAED,IAAI,CAACC,iBAAiB;MACzCC,KAAK,EAAEF,IAAI,CAACE;KACf,CACJ,CAAC;IACF,MAAMC,KAAK,GAA2B,EAAE;IACxC,KAAK,MAAM/F,GAAG,IAAIvD,4BAA4B,CAACuJ,sBAAsB,EAAE;MACnE,MAAMC,GAAG,GAAW,IAAI,CAACjD,UAAU,CAAC3E,WAAW,CAAC2B,GAAG,EAAE,EAAE,CAAC;MACxD,IAAIiG,GAAG,KAAK,EAAE,EAAE;QACZF,KAAK,CAAC/F,GAAG,CAAC,GAAGiG,GAAG;;;IAGxB,MAAMC,IAAI,GAAqB;MAAErH,EAAE,EAAE6G,MAAM;MAAEvE,YAAY,EAAEE,CAAC;MAAE8E,sBAAsB,EAAEJ;IAAK,CAAE;IAC7F,OAAOG,IAAI;EACf;EAEA,IAAYE,OAAOA,CAAA;;IACf,OAAO,IAAI,CAACnH,eAAe,IAAI,GAAAC,EAAA,GAAC,IAAI,CAACW,gBAAgB,CAACgD,EAAE,cAAA3D,EAAA,uBAAAA,EAAA,CAAEuB,OAAO;EACrE;EAEA,IAAY4F,aAAaA,CAAA;;IACrB,OAAO,IAAI,CAACpH,eAAe,MAAAC,EAAA,GAAI,IAAI,CAACW,gBAAgB,CAACgD,EAAE,cAAA3D,EAAA,uBAAAA,EAAA,CAAEoC,MAAM;EACnE;EAEA;EACA;EACA,IAAWgF,kBAAkBA,CAAA;IACzB,OAAO,IAAI,CAACC,SAAS;EACzB;EAEA,IAAWD,kBAAkBA,CAACnG,KAAa;IACvCnD,SAAS,CAACwJ,uBAAuB,CAACrG,KAAK,EAAE,oBAAoB,CAAC;IAC9D,IAAI,CAACoG,SAAS,GAAGpG,KAAK;EAC1B;EAEA,IAAWsG,sBAAsBA,CAACA,sBAA8C;IAC5E,IAAI,CAACtH,0BAA0B,GAAGsH,sBAAsB;EAC5D;EAEOC,OAAOA,CAAC9D,KAAsB;IACjC,IAAI,CAACzD,0BAA0B,CAACuH,OAAO,CAAC9D,KAAK,CAAC;EAClD;EAEA;;;;;EAKOlF,uBAAuBA,CAACc,EAAa,EAAEC,GAAc;IACxD,IAAI;MACA,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAAC6B,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC+H,qBAAqB,CAAC,EAAEpI,GAAG,CAAC;;MAE3E,IAAI,CAACgF,WAAW,CAACqD,YAAY,CAAC,IAAI,CAACtD,cAAc,EAAEzD,SAAS,EACtD6E,IAA2B,IAAU;QACnC,IAAI,CAACA,IAAI,EAAE;UACP,IAAI,CAAC+B,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACiI,uBAAuB,CAAC,EAAEtI,GAAG,CAAC;;QAE7E,IAAI,CAACkE,QAAQ,GAAGiC,IAAI;QACpB,IAAI,CAACoC,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;MAChC,CAAC,EACCG,KAAU,IAAU;QAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;MAChC,CAAE,CAAC;KACV,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;EAKOwI,sBAAsBA,CAACzI,EAAa,EAAEC,GAAc;IACvD,IAAI;MACA;MACA,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAAC6B,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC+H,qBAAqB,CAAC,EAAEpI,GAAG,CAAC;;MAE3E;MACAzB,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAACiI,uBAAuB,CAAC;MACxF;MACA,IAAI,CAAClH,gBAAgB,CAACqH,IAAI,GAAG,IAAI,CAACvE,QAAQ,CAACwE,aAAa;MACxD,IAAI,CAACrC,0BAA0B,GAAGnI,6BAA6B,CAACyK,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC7C,UAAU,CAAC;MAEjG;MACA;MACA,IAAI,CAACO,0BAA0B,CAACuC,SAAS,GAAG,IAAI,CAACtI,WAAW;MAC5D,IAAI,CAAC+F,0BAA0B,CAACwC,YAAY,GAAG,IAAI,CAACjI,cAAc;MAClE,IAAI,CAACyF,0BAA0B,CAACpF,QAAQ,GAAG,IAAI,CAACF,UAAU;MAE1D,IAAI,CAACsF,0BAA0B,CAACyC,gCAAgC,GAAG,IAAI,CAAC5H,kCAAkC;MAC1G,IAAI,CAACmF,0BAA0B,CAAC0C,uBAAuB,GAAG,IAAI,CAACvG,yBAAyB;MACxF,IAAI,CAAC6D,0BAA0B,CAAC2C,sBAAsB,GAAG,IAAI,CAACvG,wBAAwB;MACtF,IAAI,CAAC4D,0BAA0B,CAAC4C,8BAA8B,GAAG,IAAI,CAAClG,gCAAgC;MACtG,IAAI,CAACsD,0BAA0B,CAAC6C,+BAA+B,GAAG,IAAI,CAAC/F,iCAAiC;MACxG,IAAI,CAACkD,0BAA0B,CAAC8C,mBAAmB,GAAG,IAAI,CAAC5F,qBAAqB;MAChF,IAAI,CAAC8C,0BAA0B,CAAC+C,wBAAwB,GAAG,IAAI,CAACpF,0BAA0B;MAC1F,IAAI,CAACqC,0BAA0B,CAACzB,sBAAsB,GAAG,IAAI,CAACD,wBAAwB;MAEtF,IAAI,CAAC0B,0BAA0B,CAACgD,OAAO,CAAC,IAAI,CAACnF,QAAQ,CAACC,KAAK,EACtD,MAAW;QACR,IAAI,CAACoE,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;MAChC,CAAC,EACCG,KAAU,IAAU;QAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;MAChC,CAAE,CAAC;KACV,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;;EAMOsJ,mBAAmBA,CAACrG,WAAyB,EAAElD,EAAa,EAAEC,GAAc;IAC/EzB,SAAS,CAACe,sBAAsB,CAAC2D,WAAW,EAAE,aAAa,CAAC;IAC5D3E,yBAAyB,CAAC,IAAI,CAACiL,uBAAuB,CAACtG,WAAW,CAAC,EAAElD,EAAE,EAAEC,GAAG,CAAC;EACjF;EAEA;;;;;;;;EAQOwJ,qBAAqBA,CAACjD,cAAsB,EAAEjC,QAAgB,EAAEmF,IAAY,EAAE1J,EAAa,EAAEC,GAAc;IAC9G,IAAI;MACA;MACA;MACA;MACA;MACAzB,SAAS,CAACwJ,uBAAuB,CAACxB,cAAc,EAAE,IAAI,CAAClG,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;MACjHlB,SAAS,CAACwJ,uBAAuB,CAACzD,QAAQ,EAAE,IAAI,CAACjE,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;MACrGlB,SAAS,CAACwJ,uBAAuB,CAAC0B,IAAI,EAAE,IAAI,CAACpJ,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;MACjG;MACA,IAAI,CAACuF,WAAW,CAACqD,YAAY,CAAC,IAAI,CAACtD,cAAc,EAAEwB,cAAc,EAC3DJ,IAA2B,IAAU;QACnC5H,SAAS,CAACe,sBAAsB,CAAC6G,IAAI,EAAE,IAAI,CAAC9F,UAAU,CAACiI,uBAAuB,CAAC;QAC/E,IAAI,CAACpE,QAAQ,GAAGiC,IAAI;QACpB,IAAI,CAACL,UAAU,CAAC+B,kBAAkB,GAAG1B,IAAI,CAACuD,wBAAwB;QAClE;QACA,IAAI,CAAC,CAAC3J,EAAE,EAAE;UACNA,EAAE,CAACoG,IAAI,CAACuD,wBAAwB,CAAC;;MAEzC,CAAC,EACCvJ,KAAU,IAAU;QAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;MAChC,CAAE,CAAC;KACV,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;EAKO2J,uBAAuBA,CAAC5J,EAAa,EAAEC,GAAc;IACxD1B,yBAAyB,CAAC,IAAI,CAACsL,2BAA2B,EAAE,EAAE7J,EAAE,EAAEC,GAAG,CAAC;EAC1E;EAEa4J,2BAA2BA,CAAA;;MAChCrL,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAACyF,cAAc,EAAE,IAAI,CAAC1E,UAAU,CAACiI,uBAAuB,CAAC;MAC9F/J,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACC,KAAK,EAAE,IAAI,CAAC9D,UAAU,CAACiI,uBAAuB,CAAC;MAC/F,MAAM,IAAI,CAACtD,WAAW,CAAC6E,KAAK,CAAC,IAAI,CAAC9E,cAAc,EAAE,IAAI,CAACb,QAAQ,CAACC,KAAK,CAAC;MAEtE,IAAI,CAAC2F,OAAO,EAAE;IACtB,CAAC;;EAED;;;;;EAKOC,oBAAoBA,CAAChK,EAAa,EAAEC,GAAc;IACrD1B,yBAAyB,CAAC,IAAI,CAAC0L,wBAAwB,EAAE,EAAEjK,EAAE,EAAEC,GAAG,CAAC;EACvE;EAEOgK,wBAAwBA,CAAA;IAC3B,OAAO,IAAI,CAAClJ,KAAK,CAAC,IAAI,CAAC;EAC3B;EAEA;;;;;EAKOmJ,qBAAqBA,CAAClK,EAAa,EAAEC,GAAc;IACtD,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF,IAAI,CAAC,IAAI,CAACxC,aAAa,EAAE;QACrB,IAAI,CAACM,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACgK,4BAA4B,CAAC5K,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,EAAEO,GAAG,CAAC;;MAE/G,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACC,cAAc,CAAC,IAAI,CAAC,EAChE,MAAW;UACR,IAAI,CAAChC,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACCG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;EAKOwK,wBAAwBA,CAACzK,EAAa,EAAEC,GAAc;IACzD,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC+G,0BAA0B,EAAE,IAAI,CAAChG,UAAU,CAAC+J,oBAAoB,CAAC;MACvG7L,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF;MACA,IAAI,CAAC,IAAI,CAACxC,aAAa,EAAE;QACrB,IAAI,CAACM,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACgK,4BAA4B,CAAC5K,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,EAAEO,GAAG,CAAC;;MAE/G,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACG,iBAAiB,CAAC,IAAI,CAAC,EACnE,MAAW;UACR,IAAI,CAAClC,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACCG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;;EAMO0K,oBAAoBA,CAACC,MAAc,EAAE5K,EAAa,EAAEC,GAAc;IACrE,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACwJ,uBAAuB,CAAC4C,MAAM,EAAE,IAAI,CAACtK,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;MACjGlB,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF;MACA,IAAI,CAAC,IAAI,CAACzC,OAAO,EAAE;QACf,IAAI,CAACO,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC+J,oBAAoB,CAAC,EAAEpK,GAAG,CAAC;;MAE1E;MACA,IAAI,CAAC,IAAI,CAACoE,EAAE,CAACvB,MAAM,IAAI,IAAI,CAACuB,EAAE,CAAChE,EAAE,KAAKuK,MAAM,EAAE;QAC1C,IAAI,CAACzC,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACuK,2BAA2B,CAACnL,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,EAAEO,GAAG,CAAC;;MAE9G;MACA,MAAM6K,MAAM,GAAW,IAAI,CAACzJ,gBAAgB,CAAC0J,mBAAmB,CAACH,MAAM,CAAC;MACxE,IAAIE,MAAM,KAAK,CAAC,CAAC,EAAE;QACf,IAAI,CAAC3C,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC0K,yBAAyB,CAAC,EAAE/K,GAAG,CAAC;;MAE/E,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACU,cAAc,CAACL,MAAM,EAAE,IAAI,CAAC,EAAG,MAAW;UACnF,IAAI,CAACpC,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACCG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;;EAMOiL,sBAAsBA,CAACN,MAAqC,EAAE5K,EAAa,EAAEC,GAAc;IAC9F,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9C,IAAI,CAAC,CAAC,IAAI,CAACkC,yBAAyB,IAAI4D,MAAM,CAACO,cAAc,CAAC,IAAI,CAAC,EAAE;QACjE;QACA5M,yBAAyB,CAAC,IAAI,CAAC6M,0BAA0B,CAACR,MAAsB,CAAC,EAAE5K,EAAE,EAAEC,GAAG,CAAC;OAC9F,MAAM;QACHzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;QACvE5L,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;QACrF,IAAI,CAAC,IAAI,CAACxC,aAAa,EAAE;UACrB,IAAI,CAACM,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACuK,2BAA2B,CAACnL,OAAO,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,EAAEO,GAAG,CAAC;;QAEhH,IAAI0I,aAAa,GAAG,EAAE;QACtB,IAAI,OAAOiC,MAAM,KAAK,QAAQ,EAAE;UAC5BjC,aAAa,GAAGiC,MAAM;SACzB,MAAM,IAAIA,MAAM,CAACO,cAAc,CAAC,IAAI,CAAC,EAAE;UACpC,MAAMjI,WAAW,GAAiB0H,MAAsB;UACxDjC,aAAa,GAAGzF,WAAW,CAAC7C,EAAE;SACjC,MAAM,IAAIuK,MAAM,CAACO,cAAc,CAAC,QAAQ,CAAC,EAAE;UACxC,MAAME,IAAI,GAAUT,MAAe;UACnCjC,aAAa,GAAG0C,IAAI,CAACT,MAAM;;QAE/BpM,SAAS,CAACwJ,uBAAuB,CAACW,aAAa,EAAE,IAAI,CAACrI,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QACxG;QACA,MAAM4L,KAAK,GAAW,IAAI,CAAC3I,YAAY,CAAC4I,SAAS,CAAE1I,CAAc,IAAcA,CAAC,CAACxC,EAAE,KAAKsI,aAAa,CAAC;QACtG,IAAI2C,KAAK,KAAK,CAAC,CAAC,EAAE;UACd,IAAI,CAACnD,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC0K,yBAAyB,CAAC,EAAE/K,GAAG,CAAC;;QAE/E,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;UACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACiB,eAAe,CAAC7C,aAAa,CAAC,EAAG,MAAW;YACzF,IAAI,CAACH,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;UAChC,CAAC,EACKG,KAAU,IAAU;YAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;UAChC,CAAE,CAAC;;;KAGlB,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;EAKOwL,uBAAuBA,CAACzL,EAAa,EAAEC,GAAc;IACxD,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF,IAAI,CAAC,IAAI,CAACxC,aAAa,EAAE;QACrB,IAAI,CAACM,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACgK,4BAA4B,CAAC5K,OAAO,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,EAAEO,GAAG,CAAC;;MAEjH,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACC,cAAc,CAAC,KAAK,CAAC,EAAG,MAAW;UAChF,IAAI,CAAChC,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACKG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;EAKOyL,0BAA0BA,CAAC1L,EAAa,EAAEC,GAAc;IAC3D,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF,IAAI,CAAC,IAAI,CAACxC,aAAa,EAAE;QACrB,IAAI,CAACM,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACgK,4BAA4B,CAAC5K,OAAO,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC,EAAEO,GAAG,CAAC;;MAErH,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACG,iBAAiB,CAAC,KAAK,CAAC,EAAG,MAAW;UACnF,IAAI,CAAClC,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACKG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;;EAMO0L,sBAAsBA,CAACf,MAAc,EAAE5K,EAAa,EAAEC,GAAc;IACvE,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACwJ,uBAAuB,CAAC4C,MAAM,EAAE,IAAI,CAACtK,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;MACjGlB,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF;MACA,IAAI,CAAC,IAAI,CAACzC,OAAO,EAAE;QACf,IAAI,CAACO,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC+J,oBAAoB,CAAC,EAAEpK,GAAG,CAAC;;MAE1E;MACA,IAAI,CAAC,IAAI,CAACoE,EAAE,CAACvB,MAAM,IAAI,IAAI,CAACuB,EAAE,CAAChE,EAAE,KAAKuK,MAAM,EAAE;QAC1C,IAAI,CAACzC,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACuK,2BAA2B,CAACnL,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,EAAEO,GAAG,CAAC;;MAE9G;MACA,MAAM6K,MAAM,GAAW,IAAI,CAACzJ,gBAAgB,CAAC0J,mBAAmB,CAACH,MAAM,CAAC;MACxE,IAAIE,MAAM,KAAK,CAAC,CAAC,EAAE;QACf,IAAI,CAAC3C,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC0K,yBAAyB,CAAC,EAAE/K,GAAG,CAAC;;MAE/E,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACU,cAAc,CAACL,MAAM,EAAE,KAAK,CAAC,EAAG,MAAW;UACxF,IAAI,CAACpC,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACKG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;;EAMO2L,oBAAoBA,CAACC,OAAe,EAAE7L,EAAa,EAAEC,GAAc;IACtE,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACwJ,uBAAuB,CAAC6D,OAAO,EAAE,IAAI,CAACvL,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;MACnGlB,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF,IAAI,CAAC,IAAI,CAACzC,OAAO,EAAE;QACf,IAAI,CAACO,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC+J,oBAAoB,CAAC,EAAEpK,GAAG,CAAC;;MAE1E;MACA,IAAI4L,OAAO,CAACnH,MAAM,GAAG,IAAI,CAACyB,wBAAwB,EAAE;QAChD,IAAI,CAACgC,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC,EAAEO,GAAG,CAAC;;MAEpG,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAACuB,iBAAiB,CAACD,OAAO,CAAC,EAAG,MAAW;UACrF,IAAI,CAACrD,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACKG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;;EAMO8L,2BAA2BA,CAACC,SAAmB,EAAEhM,EAAa,EAAEC,GAAc;IACjF,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACyN,6BAA6B,CAACD,SAAS,EAAE,IAAI,CAAC1L,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;MAC7GlB,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF,IAAI,CAAC,IAAI,CAACzC,OAAO,EAAE;QACf,IAAI,CAACO,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC+J,oBAAoB,CAAC,EAAEpK,GAAG,CAAC;;MAE1E,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAAC2B,iCAAiC,CAACF,SAAS,CAAC,EACxF,MAAW;UACR,IAAI,CAACxD,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACCG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEA;;;;;;EAMO0E,mBAAmBA,CAACJ,QAAgB,EAAEvE,EAAa,EAAEC,GAAc;IACtE,IAAI;MACAzB,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAACrF,cAAc,CAAC;MAC9CtG,SAAS,CAAC2L,eAAe,CAAC,IAAI,CAAC7D,0BAA0B,CAAC8D,UAAU,EAAE,CAAC;MACvE5L,SAAS,CAACwJ,uBAAuB,CAACzD,QAAQ,EAAE,IAAI,CAACjE,UAAU,CAACb,WAAW,CAACC,OAAO,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;MACrGlB,SAAS,CAACe,sBAAsB,CAAC,IAAI,CAAC4E,QAAQ,EAAE,IAAI,CAAC7D,UAAU,CAAC+J,oBAAoB,CAAC;MACrF,IAAI,CAAC,IAAI,CAACzC,OAAO,EAAE;QACf,IAAI,CAACO,WAAW,CAAC,IAAIC,KAAK,CAAC,IAAI,CAAC9H,UAAU,CAAC+J,oBAAoB,CAAC,EAAEpK,GAAG,CAAC;;MAE1E,IAAI,CAAC,CAAC,IAAI,CAACqG,0BAA0B,EAAE;QACnC,IAAI,CAACA,0BAA0B,CAACiE,WAAW,CAAC,IAAI,CAAC4B,wBAAwB,CAAC5H,QAAQ,CAAC,EAC9E,MAAW;UACR,IAAI,CAACiE,cAAc,CAACxI,EAAE,EAAEC,GAAG,CAAC;QAChC,CAAC,EACCG,KAAU,IAAU;UAClB,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;QAChC,CAAE,CAAC;;KAEd,CAAC,OAAOG,KAAK,EAAE;MACZ,IAAI,CAAC+H,WAAW,CAAC/H,KAAK,EAAEH,GAAG,CAAC;;EAEpC;EAEOmK,UAAUA,CAAA;IACb,OAAO,IAAI,CAACtF,cAAc;EAC9B;EAEOiF,OAAOA,CAAA;IACV,IAAI,IAAI,CAACK,UAAU,EAAE;MACjB;;IAEJ,IAAI,CAACtF,cAAc,GAAG,IAAI;IAC1B,IAAI,CAAC,CAAC,IAAI,CAACyB,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAACxF,KAAK,EAAE;;IAEvB,IAAI,CAACgF,UAAU,GAAGxE,SAAS;IAC3B,IAAI,CAAC+D,YAAY,GAAG/D,SAAS;IAC7B,IAAI,CAACyD,cAAc,GAAGzD,SAAS;IAC/B,IAAI,CAAC4C,QAAQ,GAAG5C,SAAS;IACzB,IAAI,CAACwG,SAAS,GAAGxG,SAAS;IAC1B,IAAI,CAAC0D,WAAW,GAAG1D,SAAS;IAC5B,IAAI,CAACd,eAAe,GAAG,KAAK;IAC5B,IAAI,CAAC6D,WAAW,GAAG,KAAK;IACxB,IAAI,CAACjD,gBAAgB,GAAGE,SAAS;EACrC;EAEa6K,4BAA4BA,CAACC,UAAiC;;MACvE,IAAI,CAAC,CAAC,IAAI,CAACrF,yBAAyB,EAAE;QAClC,MAAM,IAAI,CAACA,yBAAyB,CAACjG,KAAK,EAAE;;MAEhD,MAAMsL,UAAU,CAACC,kBAAkB,EAAE;MACrC,IAAI,CAACtF,yBAAyB,GAAGqF,UAAU;MAC3C,IAAI,CAACrF,yBAAyB,CAACuF,YAAY,GAAG,IAAI;IACtD,CAAC;;EAEMC,YAAYA,CAAA;IACf,MAAMjI,QAAQ,GAAY,CAAC,CAAC,IAAI,CAACF,EAAE,GAAI,IAAI,CAACA,EAAE,CAAC3C,WAAW,GAAG,kBAAkB;IAC/E,OAAO+K,IAAI,CAACC,SAAS,CAAC;MAClBrM,EAAE,EAAE,GAAG;MACPkE,QAAQ;MACRoE,aAAa,EAAE,IAAI,CAACxE,QAAQ,CAACwE,aAAa;MAC1ClC,MAAM,EAAE,IAAI,CAACtC,QAAQ,CAACsC,MAAM;MAC5BkG,IAAI,EAAEtO,kCAAkC,CAACuO;KAC5C,CAAC;EACN;EAmMA;EAEQpD,uBAAuBA,CAACtG,WAAyB;IACrD,MAAMD,cAAc,GAAyB,IAAI,CAAC5B,gBAAgB,CAACe,sBAAsB,CAACc,WAAW,CAAC;IACtG,IAAID,cAAc,KAAK1B,SAAS,EAAE;MAC9B,IAAI,CAAC,CAAC,IAAI,CAACyF,yBAAyB,EAAE;QAClC,MAAMC,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;QAC9CA,gBAAgB,CAACtE,YAAY,GAAG,CAACO,WAAW,CAAC;QAC7C,OAAO,IAAI,CAAC8D,yBAAyB,CAAC6F,qBAAqB,CAAC5F,gBAAgB,EAAE,MAAM,CAAC;;;EAGjG;EAEQmE,0BAA0BA,CAAClI,WAAyB;IACxD,IAAI,CAAC7B,gBAAgB,CAACiC,iBAAiB,CAACJ,WAAW,CAAC7C,EAAE,CAAC;IACvD,MAAM4G,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;IAC9CA,gBAAgB,CAACtE,YAAY,GAAG,CAACO,WAAW,CAAC;IAC7C,OAAO,IAAI,CAAC8D,yBAAyB,CAAC6F,qBAAqB,CAAC5F,gBAAgB,EAAE,OAAO,CAAC;EAC1F;EAEclG,KAAKA,CAACgJ,OAAgB;;;MAChC,IAAI;QACA,IAAI,CAACtJ,eAAe,GAAG,KAAK;QAC5B,OAAAC,EAAA,GAAM,IAAI,CAAC4F,0BAA0B,cAAA5F,EAAA,uBAAAA,EAAA,CAAEK,KAAK,EAAE;QAC9C,IAAI,CAACuF,0BAA0B,GAAG/E,SAAS;QAC3C,IAAI,CAAC,CAAC,IAAI,CAACZ,0BAA0B,EAAE;UACnC,IAAI,CAACA,0BAA0B,CAACoJ,OAAO,EAAE;;OAEhD,CAAC,OAAOvJ,CAAC,EAAE;QACR;QACA,MAAMA,CAAC;;MAEX,IAAIuJ,OAAO,EAAE;QACT,IAAI,CAACA,OAAO,EAAE;;;;EAItB;EACQvB,cAAcA,CAACxI,EAAc,EAAEC,GAA8B;IACjE,IAAI,CAAC,CAACD,EAAE,EAAE;MACN,IAAI;QACAA,EAAE,EAAE;OACP,CAAC,OAAOQ,CAAC,EAAE;QACR,IAAI,CAAC,CAACP,GAAG,EAAE;UACPA,GAAG,CAACO,CAAW,CAAC;;;MAGxBR,EAAE,GAAGuB,SAAS;;EAEtB;EAEQ4G,WAAWA,CAAC/H,KAAU,EAAEH,GAA8B;IAC1D,IAAI,CAAC,CAACA,GAAG,EAAE;MACP,IAAIG,KAAK,YAAYgI,KAAK,EAAE;QACxB,MAAM0E,UAAU,GAAU1M,KAAK;QAC/BH,GAAG,CAAC6M,UAAU,CAACC,IAAI,GAAG,IAAI,GAAGD,UAAU,CAACjB,OAAO,CAAC;OAEnD,MAAM;QACH5L,GAAG,CAACG,KAAe,CAAC;;;EAGhC;EAEA;EACQ2C,cAAcA,CAACiK,WAAoB;IAEvC,MAAMrK,YAAY,GAAkB,IAAI,CAACtB,gBAAgB,CAACsB,YAAY,CAACwE,GAAG,CAAEtE,CAAuB,IAAoB,IAAI,CAACN,aAAa,CAACM,CAAC,CAAG,CAAE;IAChJ,IAAI,CAACmK,WAAW,EAAE;MACd,OAAOrK,YAAY,CAACsK,MAAM,CAAEpK,CAAc,IAAcA,CAAC,CAACC,MAAM,KAAK,KAAK,CAAC;KAC9E,MAAM;MACH,OAAOH,YAAY;;EAE3B;EAEQJ,aAAaA,CAACM,CAAuB;IACzC,OAAO,IAAIlE,WAAW,CAACkE,CAAC,CAACxC,EAAE,EAAEwC,CAAC,CAACqK,MAAM,EAAErK,CAAC,CAACnB,WAAW,EAAEmB,CAAC,CAACC,MAAM,EAAED,CAAC,CAACZ,OAAO,EAAEY,CAAC,CAAChB,UAAU,EAAEgB,CAAC,CAACwE,iBAAiB,EAAExE,CAAC,CAACyE,KAAK,CAAC;EAC1H;EAEQoD,iBAAiBA,CAACzI,OAAgB;IACtCzD,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACsC,MAAM,EAAE,gBAAgB,CAAC;IACzEjI,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACwE,aAAa,EAAE,eAAe,CAAC;IAE/E,OAAO8D,IAAI,CAACC,SAAS,CAAC;MAClBjJ,OAAO,EAAErF,kCAAkC,CAAC+O,UAAU;MACtDxE,aAAa,EAAE,IAAI,CAACxE,QAAQ,CAACwE,aAAa;MAC1CyE,MAAM,EAAE,IAAI,CAACjJ,QAAQ,CAACsC,MAAM;MAC5BkG,IAAI,EAAEtO,kCAAkC,CAACgP,kBAAkB;MAC3D1L,KAAK,EAAEM;KACV,CAAC;EACN;EAEQgJ,cAAcA,CAACtC,aAAqB,EAAE1G,OAAgB;IAC1DzD,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACsC,MAAM,EAAE,gBAAgB,CAAC;IACzEjI,SAAS,CAACwJ,uBAAuB,CAACW,aAAa,EAAE,eAAe,CAAC;IAEjE,OAAO8D,IAAI,CAACC,SAAS,CAAC;MAClBjJ,OAAO,EAAErF,kCAAkC,CAAC4D,OAAO;MACnD;MACA2G,aAAa,EAAEA,aAAa;MAC5ByE,MAAM,EAAE,IAAI,CAACjJ,QAAQ,CAACsC,MAAM;MAC5BkG,IAAI,EAAEtO,kCAAkC,CAACgP,kBAAkB;MAC3D1L,KAAK,EAAEM;KACV,CAAC;EACN;EAEQuI,cAAcA,CAAC8C,QAAiB;IACpC9O,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACsC,MAAM,EAAE,gBAAgB,CAAC;IACzEjI,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACwE,aAAa,EAAE,eAAe,CAAC;IAE/E,OAAO8D,IAAI,CAACC,SAAS,CAAC;MAClBjJ,OAAO,EAAErF,kCAAkC,CAACmP,YAAY;MACxD5E,aAAa,EAAE,IAAI,CAACxE,QAAQ,CAACwE,aAAa;MAC1CyE,MAAM,EAAE,IAAI,CAACjJ,QAAQ,CAACsC,MAAM;MAC5BkG,IAAI,EAAEtO,kCAAkC,CAACgP,kBAAkB;MAC3D1L,KAAK,EAAE2L;KACV,CAAC;EACN;EAEQ9B,eAAeA,CAAC7C,aAAqB;IACzCnK,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACsC,MAAM,EAAE,gBAAgB,CAAC;IACzEjI,SAAS,CAACwJ,uBAAuB,CAACW,aAAa,EAAE,eAAe,CAAC;IAEjE,OAAO8D,IAAI,CAACC,SAAS,CAAC;MAClBjJ,OAAO,EAAErF,kCAAkC,CAACoP,gBAAgB;MAC5D;MACA7E,aAAa,EAAEA,aAAa;MAC5ByE,MAAM,EAAE,IAAI,CAACjJ,QAAQ,CAACsC,MAAM;MAC5BkG,IAAI,EAAEtO,kCAAkC,CAACgP;KAC5C,CAAC;EACN;EAEQnB,iCAAiCA,CAACF,SAAmB;IACzDxN,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACsC,MAAM,EAAE,gBAAgB,CAAC;IACzEjI,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACwE,aAAa,EAAE,eAAe,CAAC;IAE/E,OAAO8D,IAAI,CAACC,SAAS,CAAC;MAClBjJ,OAAO,EAAErF,kCAAkC,CAAC8D,uBAAuB;MACnEyG,aAAa,EAAE,IAAI,CAACxE,QAAQ,CAACwE,aAAa;MAC1CyE,MAAM,EAAE,IAAI,CAACjJ,QAAQ,CAACsC,MAAM;MAC5BkG,IAAI,EAAEtO,kCAAkC,CAACgP,kBAAkB;MAC3D1L,KAAK,EAAEqK;KACV,CAAC;EACN;EAEQG,wBAAwBA,CAAC5H,QAAgB;IAC7C/F,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACsC,MAAM,EAAE,gBAAgB,CAAC;IACzEjI,SAAS,CAACwJ,uBAAuB,CAACzD,QAAQ,EAAE,UAAU,CAAC;IACvD/F,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACwE,aAAa,EAAE,eAAe,CAAC;IAE/E,OAAO8D,IAAI,CAACC,SAAS,CAAC;MAClBjJ,OAAO,EAAErF,kCAAkC,CAACqD,cAAc;MAC1D8C,QAAQ;MACRoE,aAAa,EAAE,IAAI,CAACxE,QAAQ,CAACwE,aAAa;MAC1CyE,MAAM,EAAE,IAAI,CAACjJ,QAAQ,CAACsC,MAAM;MAC5BkG,IAAI,EAAEtO,kCAAkC,CAACgP,kBAAkB;MAC3D1L,KAAK,EAAE4C;KACV,CAAC;EACN;EAEQuH,iBAAiBA,CAACD,OAAe;IACrCrN,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACsC,MAAM,EAAE,gBAAgB,CAAC;IACzEjI,SAAS,CAACwJ,uBAAuB,CAAC,IAAI,CAAC7D,QAAQ,CAACwE,aAAa,EAAE,eAAe,CAAC;IAC/EnK,SAAS,CAACwJ,uBAAuB,CAAC6D,OAAO,EAAE,SAAS,CAAC;IAErD,OAAOY,IAAI,CAACC,SAAS,CAAC;MAClB/D,aAAa,EAAE,IAAI,CAACxE,QAAQ,CAACwE,aAAa;MAC1ClC,MAAM,EAAE,IAAI,CAACtC,QAAQ,CAACsC,MAAM;MAC5BgH,IAAI,EAAE5B,OAAO;MACbc,IAAI,EAAEtO,kCAAkC,CAAC0F;KAC5C,CAAC;EACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}