{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports.js\";\nimport { ConnectingToServiceEvent, ListeningStartedEvent, RecognitionStartedEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents.js\";\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal.js\";\nexport class RequestSession {\n  constructor(audioSourceId) {\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n    this.privIsAudioNodeDetached = false;\n    this.privIsRecognizing = false;\n    this.privIsSpeechEnded = false;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privHypothesisReceived = false;\n    this.privBytesSent = 0;\n    this.privRecognitionBytesSent = 0;\n    this.privRecogNumber = 0;\n    this.privInTurn = false;\n    this.privConnectionAttempts = 0;\n    this.privAudioSourceId = audioSourceId;\n    this.privRequestId = createNoDashGuid();\n    this.privAudioNodeId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred();\n    // We're not in a turn, so resolve.\n    this.privTurnDeferral.resolve();\n  }\n  get sessionId() {\n    return this.privSessionId;\n  }\n  get requestId() {\n    return this.privRequestId;\n  }\n  get audioNodeId() {\n    return this.privAudioNodeId;\n  }\n  get turnCompletionPromise() {\n    return this.privTurnDeferral.promise;\n  }\n  get isSpeechEnded() {\n    return this.privIsSpeechEnded;\n  }\n  get isRecognizing() {\n    return this.privIsRecognizing;\n  }\n  get currentTurnAudioOffset() {\n    return this.privTurnStartAudioOffset;\n  }\n  get recogNumber() {\n    return this.privRecogNumber;\n  }\n  get numConnectionAttempts() {\n    return this.privConnectionAttempts;\n  }\n  // The number of bytes sent for the current connection.\n  // Counter is reset to 0 each time a connection is established.\n  get bytesSent() {\n    return this.privBytesSent;\n  }\n  // The number of bytes sent for the current recognition.\n  // Counter is reset to 0 each time recognition is started.\n  get recognitionBytesSent() {\n    return this.privRecognitionBytesSent;\n  }\n  listenForServiceTelemetry(eventSource) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\n    }\n  }\n  startNewRecognition() {\n    this.privRecognitionBytesSent = 0;\n    this.privIsSpeechEnded = false;\n    this.privIsRecognizing = true;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privRecogNumber++;\n    this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\n    this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n  }\n  onAudioSourceAttachCompleted(audioNode, isError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privAudioNode = audioNode;\n      this.privIsAudioNodeDetached = false;\n      if (isError) {\n        yield this.onComplete();\n      } else {\n        this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n      }\n    });\n  }\n  onPreConnectionStart(authFetchEventId, connectionId) {\n    this.privAuthFetchEventId = authFetchEventId;\n    this.privSessionId = connectionId;\n    this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\n  }\n  onAuthCompleted(isError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isError) {\n        yield this.onComplete();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onConnectionEstablishCompleted(statusCode, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (statusCode === 200) {\n        this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\n        if (!!this.privAudioNode) {\n          this.privAudioNode.replay();\n        }\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privBytesSent = 0;\n        return;\n      } else if (statusCode === 403) {\n        yield this.onComplete();\n      }\n    });\n  }\n  onServiceTurnEndResponse(continuousRecognition) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privTurnDeferral.resolve();\n      if (!continuousRecognition || this.isSpeechEnded) {\n        yield this.onComplete();\n        this.privInTurn = false;\n      } else {\n        // Start a new request set.\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privAudioNode.replay();\n      }\n    });\n  }\n  onSpeechContext() {\n    this.privRequestId = createNoDashGuid();\n  }\n  onServiceTurnStartResponse() {\n    if (!!this.privTurnDeferral && !!this.privInTurn) {\n      // What? How are we starting a turn with another not done?\n      this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n      // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      this.privTurnDeferral.promise.then().catch(() => {});\n    }\n    this.privInTurn = true;\n    this.privTurnDeferral = new Deferred();\n  }\n  onHypothesis(offset) {\n    if (!this.privHypothesisReceived) {\n      this.privHypothesisReceived = true;\n      this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\n    }\n  }\n  onPhraseRecognized(offset) {\n    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\n    this.onServiceRecognized(offset);\n  }\n  onServiceRecognized(offset) {\n    this.privLastRecoOffset = offset;\n    this.privHypothesisReceived = false;\n    this.privAudioNode.shrinkBuffers(offset);\n    this.privConnectionAttempts = 0;\n  }\n  onAudioSent(bytesSent) {\n    this.privBytesSent += bytesSent;\n    this.privRecognitionBytesSent += bytesSent;\n  }\n  onRetryConnection() {\n    this.privConnectionAttempts++;\n  }\n  dispose() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        this.privIsDisposed = true;\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n        if (!!this.privServiceTelemetryListener) {\n          this.privServiceTelemetryListener.dispose();\n        }\n        this.privIsRecognizing = false;\n      }\n    });\n  }\n  getTelemetry() {\n    if (this.privServiceTelemetryListener.hasTelemetry) {\n      return this.privServiceTelemetryListener.getTelemetry();\n    } else {\n      return null;\n    }\n  }\n  onStopRecognizing() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.onComplete();\n    });\n  }\n  // Should be called with the audioNode for this session has indicated that it is out of speech.\n  onSpeechEnded() {\n    this.privIsSpeechEnded = true;\n  }\n  onEvent(event) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privServiceTelemetryListener.onEvent(event);\n    }\n    Events.instance.onEvent(event);\n  }\n  onComplete() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privIsRecognizing) {\n        this.privIsRecognizing = false;\n        yield this.detachAudioNode();\n      }\n    });\n  }\n  detachAudioNode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsAudioNodeDetached) {\n        this.privIsAudioNodeDetached = true;\n        if (this.privAudioNode) {\n          yield this.privAudioNode.detach();\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["createNoDashGuid","Deferred","Events","ConnectingToServiceEvent","ListeningStartedEvent","RecognitionStartedEvent","RecognitionTriggeredEvent","ServiceTelemetryListener","RequestSession","constructor","audioSourceId","privIsDisposed","privDetachables","Array","privIsAudioNodeDetached","privIsRecognizing","privIsSpeechEnded","privTurnStartAudioOffset","privLastRecoOffset","privHypothesisReceived","privBytesSent","privRecognitionBytesSent","privRecogNumber","privInTurn","privConnectionAttempts","privAudioSourceId","privRequestId","privAudioNodeId","privTurnDeferral","resolve","sessionId","privSessionId","requestId","audioNodeId","turnCompletionPromise","promise","isSpeechEnded","isRecognizing","currentTurnAudioOffset","recogNumber","numConnectionAttempts","bytesSent","recognitionBytesSent","listenForServiceTelemetry","eventSource","privServiceTelemetryListener","push","attachListener","startNewRecognition","onEvent","onAudioSourceAttachCompleted","audioNode","isError","privAudioNode","onComplete","onPreConnectionStart","authFetchEventId","connectionId","privAuthFetchEventId","onAuthCompleted","onConnectionEstablishCompleted","statusCode","reason","replay","onServiceTurnEndResponse","continuousRecognition","onSpeechContext","onServiceTurnStartResponse","reject","then","catch","onHypothesis","offset","hypothesisReceived","findTimeAtOffset","onPhraseRecognized","phraseReceived","onServiceRecognized","shrinkBuffers","onAudioSent","onRetryConnection","dispose","detachable","detach","getTelemetry","hasTelemetry","onStopRecognizing","onSpeechEnded","event","instance","detachAudioNode"],"sources":["src/common.speech/RequestSession.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports.js\";\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IDetachable,\r\n    IEventSource,\r\n    PlatformEvent\r\n} from \"../common/Exports.js\";\r\nimport {\r\n    ConnectingToServiceEvent,\r\n    ListeningStartedEvent,\r\n    RecognitionStartedEvent,\r\n    RecognitionTriggeredEvent,\r\n    SpeechRecognitionEvent,\r\n} from \"./RecognitionEvents.js\";\r\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal.js\";\r\n\r\nexport class RequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privServiceTelemetryListener: ServiceTelemetryListener;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privAudioSourceId: string;\r\n    private privAudioNodeId: string;\r\n    private privAudioNode: ReplayableAudioNode;\r\n    private privAuthFetchEventId: string;\r\n    private privIsAudioNodeDetached: boolean = false;\r\n    private privIsRecognizing: boolean = false;\r\n    private privIsSpeechEnded: boolean = false;\r\n    private privTurnStartAudioOffset: number = 0;\r\n    private privLastRecoOffset: number = 0;\r\n    private privHypothesisReceived: boolean = false;\r\n    private privBytesSent: number = 0;\r\n    private privRecognitionBytesSent: number = 0;\r\n    private privRecogNumber: number = 0;\r\n    private privSessionId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privConnectionAttempts: number = 0;\r\n\r\n    public constructor(audioSourceId: string) {\r\n        this.privAudioSourceId = audioSourceId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privAudioNodeId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get audioNodeId(): string {\r\n        return this.privAudioNodeId;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSpeechEnded(): boolean {\r\n        return this.privIsSpeechEnded;\r\n    }\r\n\r\n    public get isRecognizing(): boolean {\r\n        return this.privIsRecognizing;\r\n    }\r\n\r\n    public get currentTurnAudioOffset(): number {\r\n        return this.privTurnStartAudioOffset;\r\n    }\r\n\r\n    public get recogNumber(): number {\r\n        return this.privRecogNumber;\r\n    }\r\n\r\n    public get numConnectionAttempts(): number {\r\n        return this.privConnectionAttempts;\r\n    }\r\n\r\n    // The number of bytes sent for the current connection.\r\n    // Counter is reset to 0 each time a connection is established.\r\n    public get bytesSent(): number {\r\n        return this.privBytesSent;\r\n    }\r\n\r\n    // The number of bytes sent for the current recognition.\r\n    // Counter is reset to 0 each time recognition is started.\r\n    public get recognitionBytesSent(): number {\r\n        return this.privRecognitionBytesSent;\r\n    }\r\n\r\n    public listenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\r\n        }\r\n    }\r\n\r\n    public startNewRecognition(): void {\r\n        this.privRecognitionBytesSent = 0;\r\n        this.privIsSpeechEnded = false;\r\n        this.privIsRecognizing = true;\r\n        this.privTurnStartAudioOffset = 0;\r\n        this.privLastRecoOffset = 0;\r\n        this.privRecogNumber++;\r\n        this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\r\n        this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n    }\r\n\r\n    public async onAudioSourceAttachCompleted(audioNode: ReplayableAudioNode, isError: boolean): Promise<void> {\r\n        this.privAudioNode = audioNode;\r\n        this.privIsAudioNodeDetached = false;\r\n\r\n        if (isError) {\r\n            await this.onComplete();\r\n        } else {\r\n            this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n        }\r\n    }\r\n\r\n    public onPreConnectionStart(authFetchEventId: string, connectionId: string): void {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.privSessionId = connectionId;\r\n        this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\r\n    }\r\n\r\n    public async onAuthCompleted(isError: boolean): Promise<void> {\r\n        if (isError) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public async onConnectionEstablishCompleted(statusCode: number, reason?: string): Promise<void> {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\r\n            if (!!this.privAudioNode) {\r\n                this.privAudioNode.replay();\r\n            }\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privBytesSent = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    public async onServiceTurnEndResponse(continuousRecognition: boolean): Promise<void> {\r\n        this.privTurnDeferral.resolve();\r\n\r\n        if (!continuousRecognition || this.isSpeechEnded) {\r\n            await this.onComplete();\r\n            this.privInTurn = false;\r\n        } else {\r\n            // Start a new request set.\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privAudioNode.replay();\r\n        }\r\n    }\r\n\r\n    public onSpeechContext(): void {\r\n        this.privRequestId = createNoDashGuid();\r\n    }\r\n\r\n    public onServiceTurnStartResponse(): void {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n            this.privTurnDeferral.promise.then().catch((): void => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onHypothesis(offset: number): void {\r\n        if (!this.privHypothesisReceived) {\r\n            this.privHypothesisReceived = true;\r\n            this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        }\r\n    }\r\n\r\n    public onPhraseRecognized(offset: number): void {\r\n        this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        this.onServiceRecognized(offset);\r\n    }\r\n\r\n    public onServiceRecognized(offset: number): void {\r\n        this.privLastRecoOffset = offset;\r\n        this.privHypothesisReceived = false;\r\n        this.privAudioNode.shrinkBuffers(offset);\r\n        this.privConnectionAttempts = 0;\r\n    }\r\n\r\n    public onAudioSent(bytesSent: number): void {\r\n        this.privBytesSent += bytesSent;\r\n        this.privRecognitionBytesSent += bytesSent;\r\n    }\r\n\r\n    public onRetryConnection(): void {\r\n        this.privConnectionAttempts++;\r\n    }\r\n\r\n    public async dispose(): Promise<void> {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            if (!!this.privServiceTelemetryListener) {\r\n                this.privServiceTelemetryListener.dispose();\r\n            }\r\n            this.privIsRecognizing = false;\r\n        }\r\n    }\r\n\r\n    public getTelemetry(): string {\r\n        if (this.privServiceTelemetryListener.hasTelemetry) {\r\n            return this.privServiceTelemetryListener.getTelemetry();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public async onStopRecognizing(): Promise<void> {\r\n        await this.onComplete();\r\n    }\r\n\r\n    // Should be called with the audioNode for this session has indicated that it is out of speech.\r\n    public onSpeechEnded(): void {\r\n        this.privIsSpeechEnded = true;\r\n    }\r\n\r\n    protected onEvent(event: SpeechRecognitionEvent): void {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privServiceTelemetryListener.onEvent(event);\r\n        }\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private async onComplete(): Promise<void> {\r\n        if (!!this.privIsRecognizing) {\r\n            this.privIsRecognizing = false;\r\n            await this.detachAudioNode();\r\n        }\r\n    }\r\n\r\n    private async detachAudioNode(): Promise<void> {\r\n        if (!this.privIsAudioNodeDetached) {\r\n            this.privIsAudioNodeDetached = true;\r\n            if (this.privAudioNode) {\r\n                await this.privAudioNode.detach();\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}