{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { connectivity, type } from \"../common.speech/Exports.js\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource } from \"../common/Exports.js\";\nimport { AudioStreamFormat } from \"../sdk/Audio/AudioStreamFormat.js\";\nexport class FileAudioSource {\n  constructor(file, filename, audioSourceId) {\n    this.privStreams = {};\n    this.privHeaderEnd = 44;\n    this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n    this.privEvents = new EventSource();\n    this.privSource = file;\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n      this.privFilename = file.name;\n    } else {\n      this.privFilename = filename || \"unknown.wav\";\n    }\n    // Read the header.\n    this.privAudioFormatPromise = this.readHeader();\n  }\n  get format() {\n    return this.privAudioFormatPromise;\n  }\n  turnOn() {\n    if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\n      const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n      this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n      return Promise.reject(errorMsg);\n    }\n    this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n    this.onEvent(new AudioSourceReadyEvent(this.privId));\n    return;\n  }\n  id() {\n    return this.privId;\n  }\n  attach(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      const stream = yield this.upload(audioNodeId);\n      this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return Promise.resolve({\n        detach: () => __awaiter(this, void 0, void 0, function* () {\n          stream.readEnded();\n          delete this.privStreams[audioNodeId];\n          this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          yield this.turnOff();\n        }),\n        id: () => audioNodeId,\n        read: () => stream.read()\n      });\n    });\n  }\n  detach(audioNodeId) {\n    if (audioNodeId && this.privStreams[audioNodeId]) {\n      this.privStreams[audioNodeId].close();\n      delete this.privStreams[audioNodeId];\n      this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n    }\n  }\n  turnOff() {\n    for (const streamId in this.privStreams) {\n      if (streamId) {\n        const stream = this.privStreams[streamId];\n        if (stream && !stream.isClosed) {\n          stream.close();\n        }\n      }\n    }\n    this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n    return Promise.resolve();\n  }\n  get events() {\n    return this.privEvents;\n  }\n  get deviceInfo() {\n    return this.privAudioFormatPromise.then(result => Promise.resolve({\n      bitspersample: result.bitsPerSample,\n      channelcount: result.channels,\n      connectivity: connectivity.Unknown,\n      manufacturer: \"Speech SDK\",\n      model: \"File\",\n      samplerate: result.samplesPerSec,\n      type: type.File\n    }));\n  }\n  readHeader() {\n    // Read the wave header.\n    const maxHeaderSize = 4296;\n    const header = this.privSource.slice(0, maxHeaderSize);\n    const headerResult = new Deferred();\n    const processHeader = header => {\n      const view = new DataView(header);\n      const getWord = index => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n      // RIFF 4 bytes.\n      if (\"RIFF\" !== getWord(0)) {\n        headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n        return;\n      }\n      // length, 4 bytes\n      // RIFF Type & fmt 8 bytes\n      if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n        headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n        return;\n      }\n      const formatSize = view.getInt32(16, true);\n      const channelCount = view.getUint16(22, true);\n      const sampleRate = view.getUint32(24, true);\n      const bitsPerSample = view.getUint16(34, true);\n      // Confirm if header is 44 bytes long.\n      let pos = 36 + Math.max(formatSize - 16, 0);\n      for (; getWord(pos) !== \"data\"; pos += 2) {\n        if (pos > maxHeaderSize - 8) {\n          headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n          return;\n        }\n      }\n      this.privHeaderEnd = pos + 8;\n      headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n    };\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n      const reader = new FileReader();\n      reader.onload = event => {\n        const header = event.target.result;\n        processHeader(header);\n      };\n      reader.readAsArrayBuffer(header);\n    } else {\n      const h = header;\n      processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n    }\n    return headerResult.promise;\n  }\n  upload(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const onerror = error => {\n        const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\n        this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\n        throw new Error(errorMsg);\n      };\n      try {\n        yield this.turnOn();\n        const format = yield this.privAudioFormatPromise;\n        const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n        this.privStreams[audioNodeId] = stream;\n        const chunk = this.privSource.slice(this.privHeaderEnd);\n        const processFile = buff => {\n          if (stream.isClosed) {\n            return; // output stream was closed (somebody called TurnOff). We're done here.\n          }\n\n          stream.writeStreamChunk({\n            buffer: buff,\n            isEnd: false,\n            timeReceived: Date.now()\n          });\n          stream.close();\n        };\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n          const reader = new FileReader();\n          reader.onerror = ev => onerror(ev.toString());\n          reader.onload = event => {\n            const fileBuffer = event.target.result;\n            processFile(fileBuffer);\n          };\n          reader.readAsArrayBuffer(chunk);\n        } else {\n          const c = chunk;\n          processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n        }\n        return stream;\n      } catch (e) {\n        onerror(e);\n      }\n    });\n  }\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n}","map":{"version":3,"names":["connectivity","type","AudioSourceErrorEvent","AudioSourceInitializingEvent","AudioSourceOffEvent","AudioSourceReadyEvent","AudioStreamNodeAttachedEvent","AudioStreamNodeAttachingEvent","AudioStreamNodeDetachedEvent","AudioStreamNodeErrorEvent","ChunkedArrayBufferStream","createNoDashGuid","Deferred","Events","EventSource","AudioStreamFormat","FileAudioSource","constructor","file","filename","audioSourceId","privStreams","privHeaderEnd","privId","privEvents","privSource","window","Blob","privFilename","name","privAudioFormatPromise","readHeader","format","turnOn","lastIndexOf","length","errorMsg","onEvent","Promise","reject","id","attach","audioNodeId","stream","upload","resolve","detach","__awaiter","readEnded","turnOff","read","close","streamId","isClosed","events","deviceInfo","then","result","bitspersample","bitsPerSample","channelcount","channels","Unknown","manufacturer","model","samplerate","samplesPerSec","File","maxHeaderSize","header","slice","headerResult","processHeader","view","DataView","getWord","index","String","fromCharCode","getUint8","formatSize","getInt32","channelCount","getUint16","sampleRate","getUint32","pos","Math","max","getWaveFormatPCM","reader","FileReader","onload","event","target","readAsArrayBuffer","h","buffer","byteOffset","byteLength","promise","onerror","error","Error","avgBytesPerSec","chunk","processFile","buff","writeStreamChunk","isEnd","timeReceived","Date","now","ev","toString","fileBuffer","c","e","instance"],"sources":["src/common.browser/FileAudioSource.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type,\r\n} from \"../common.speech/Exports.js\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports.js\";\r\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat.js\";\r\n\r\nexport class FileAudioSource implements IAudioSource {\r\n\r\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privSource: Blob | Buffer;\r\n\r\n    private privFilename: string;\r\n\r\n    private privHeaderEnd: number = 44;\r\n\r\n    public constructor(file: File | Buffer, filename?: string, audioSourceId?: string) {\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privSource = file;\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\r\n            this.privFilename = (file as File).name;\r\n        } else {\r\n            this.privFilename = filename || \"unknown.wav\";\r\n        }\r\n\r\n        // Read the header.\r\n        this.privAudioFormatPromise = this.readHeader();\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return this.privAudioFormatPromise;\r\n    }\r\n\r\n    public turnOn(): Promise<void> {\r\n        if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\r\n            const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return Promise.reject(errorMsg);\r\n        }\r\n\r\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n        return;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public async attach(audioNodeId: string): Promise<IAudioStreamNode> {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        const stream: Stream<ArrayBuffer> = await this.upload(audioNodeId);\r\n\r\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n        return Promise.resolve({\r\n            detach: async (): Promise<void> => {\r\n                stream.readEnded();\r\n                delete this.privStreams[audioNodeId];\r\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                await this.turnOff();\r\n            },\r\n            id: (): string => audioNodeId,\r\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => stream.read(),\r\n        });\r\n    }\r\n\r\n    public detach(audioNodeId: string): void {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff(): Promise<void> {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream && !stream.isClosed) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.privAudioFormatPromise.then<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl): Promise<{\r\n            bitspersample: number;\r\n            channelcount: number;\r\n            connectivity: connectivity.Unknown;\r\n            manufacturer: string;\r\n            model: string;\r\n            samplerate: number;\r\n            type: type.File;\r\n        }> => ( Promise.resolve({\r\n                bitspersample: result.bitsPerSample,\r\n                channelcount: result.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: \"File\",\r\n                samplerate: result.samplesPerSec,\r\n                type: type.File,\r\n            })\r\n        ));\r\n    }\r\n\r\n    private readHeader(): Promise<AudioStreamFormatImpl> {\r\n        // Read the wave header.\r\n        const maxHeaderSize: number = 4296;\r\n        const header: Blob | Buffer = this.privSource.slice(0, maxHeaderSize);\r\n\r\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\r\n\r\n        const processHeader = (header: ArrayBuffer): void => {\r\n            const view: DataView = new DataView(header);\r\n\r\n            const getWord = (index: number): string => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\r\n\r\n            // RIFF 4 bytes.\r\n            if (\"RIFF\" !== getWord(0)) {\r\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\r\n                return;\r\n            }\r\n\r\n            // length, 4 bytes\r\n            // RIFF Type & fmt 8 bytes\r\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\r\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\r\n                return;\r\n            }\r\n\r\n            const formatSize: number = view.getInt32(16, true);\r\n            const channelCount: number = view.getUint16(22, true);\r\n            const sampleRate: number = view.getUint32(24, true);\r\n            const bitsPerSample: number = view.getUint16(34, true);\r\n            // Confirm if header is 44 bytes long.\r\n            let pos: number = 36 + Math.max(formatSize - 16, 0);\r\n            for (; getWord(pos) !== \"data\"; pos += 2) {\r\n                if (pos > maxHeaderSize - 8) {\r\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\r\n                    return;\r\n                }\r\n            }\r\n            this.privHeaderEnd = pos + 8;\r\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\r\n        };\r\n\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\r\n            const reader: FileReader = new FileReader();\r\n\r\n            reader.onload = (event: Event): void => {\r\n                const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                processHeader(header);\r\n            };\r\n\r\n            reader.readAsArrayBuffer(header);\r\n        } else {\r\n            const h: Buffer = header as Buffer;\r\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\r\n        }\r\n        return headerResult.promise;\r\n    }\r\n\r\n    private async upload(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\r\n        const onerror = (error: string): void => {\r\n            const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\r\n            throw new Error(errorMsg);\r\n        };\r\n\r\n        try {\r\n            await this.turnOn();\r\n\r\n            const format: AudioStreamFormatImpl = await this.privAudioFormatPromise;\r\n            const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\r\n\r\n            this.privStreams[audioNodeId] = stream;\r\n            const chunk: Blob | Buffer = this.privSource.slice(this.privHeaderEnd);\r\n\r\n            const processFile = (buff: ArrayBuffer): void => {\r\n                if (stream.isClosed) {\r\n                    return; // output stream was closed (somebody called TurnOff). We're done here.\r\n                }\r\n\r\n                stream.writeStreamChunk({\r\n                    buffer: buff,\r\n                    isEnd: false,\r\n                    timeReceived: Date.now(),\r\n                });\r\n                stream.close();\r\n            };\r\n\r\n            if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\r\n                const reader: FileReader = new FileReader();\r\n                reader.onerror = (ev: ProgressEvent<FileReader>): void  =>  onerror(ev.toString());\r\n\r\n                reader.onload = (event: Event): void => {\r\n                    const fileBuffer: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                    processFile(fileBuffer);\r\n                };\r\n\r\n                reader.readAsArrayBuffer(chunk);\r\n            } else {\r\n                const c: Buffer = chunk as Buffer;\r\n                processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\r\n            }\r\n\r\n            return stream;\r\n        } catch (e) {\r\n            onerror(e as string);\r\n        }\r\n    }\r\n\r\n    private onEvent(event: AudioSourceEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}