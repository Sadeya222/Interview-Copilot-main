{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Deferred, MessageType, RawWebsocketMessage } from \"../../common/Exports.js\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage.js\";\n/**\n * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.\n */\nexport class ConversationWebsocketMessageFormatter {\n  /**\n   * Format incoming messages: text (speech partial/final, IM) or binary (tts)\n   */\n  toConnectionMessage(message) {\n    const deferral = new Deferred();\n    try {\n      if (message.messageType === MessageType.Text) {\n        const incomingMessage = new ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);\n        deferral.resolve(incomingMessage);\n      } else if (message.messageType === MessageType.Binary) {\n        deferral.resolve(new ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. Error: ${e}`);\n    }\n    return deferral.promise;\n  }\n  /**\n   * Format outgoing messages: text (commands or IM)\n   */\n  fromConnectionMessage(message) {\n    const deferral = new Deferred();\n    try {\n      if (message.messageType === MessageType.Text) {\n        const payload = `${message.textBody ? message.textBody : \"\"}`;\n        deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. ${e}`);\n    }\n    return deferral.promise;\n  }\n}","map":{"version":3,"names":["Deferred","MessageType","RawWebsocketMessage","ConversationConnectionMessage","ConversationWebsocketMessageFormatter","toConnectionMessage","message","deferral","messageType","Text","incomingMessage","textContent","id","resolve","Binary","binaryContent","undefined","e","reject","promise","fromConnectionMessage","payload","textBody"],"sources":["src/common.speech/Transcription/ConversationWebsocketMessageFormatter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    Deferred,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    RawWebsocketMessage,\r\n} from \"../../common/Exports.js\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage.js\";\r\n\r\n/**\r\n * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.\r\n */\r\nexport class ConversationWebsocketMessageFormatter implements IWebsocketMessageFormatter {\r\n\r\n    /**\r\n     * Format incoming messages: text (speech partial/final, IM) or binary (tts)\r\n     */\r\n    public toConnectionMessage(message: RawWebsocketMessage): Promise<ConversationConnectionMessage> {\r\n        const deferral = new Deferred<ConversationConnectionMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const incomingMessage: ConversationConnectionMessage = new ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);\r\n                deferral.resolve(incomingMessage);\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                deferral.resolve(new ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. Error: ${e as string}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n\r\n    /**\r\n     * Format outgoing messages: text (commands or IM)\r\n     */\r\n    public fromConnectionMessage(message: ConnectionMessage): Promise<RawWebsocketMessage> {\r\n\r\n        const deferral = new Deferred<RawWebsocketMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const payload = `${message.textBody ? message.textBody : \"\"}`;\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. ${e as string}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AAEA,SAEIA,QAAQ,EAERC,WAAW,EACXC,mBAAmB,QAChB,yBAAyB;AAChC,SAASC,6BAA6B,QAAQ,oCAAoC;AAElF;;;AAGA,OAAM,MAAOC,qCAAqC;EAE9C;;;EAGOC,mBAAmBA,CAACC,OAA4B;IACnD,MAAMC,QAAQ,GAAG,IAAIP,QAAQ,EAAiC;IAE9D,IAAI;MACA,IAAIM,OAAO,CAACE,WAAW,KAAKP,WAAW,CAACQ,IAAI,EAAE;QAC1C,MAAMC,eAAe,GAAkC,IAAIP,6BAA6B,CAACG,OAAO,CAACE,WAAW,EAAEF,OAAO,CAACK,WAAW,EAAE,EAAE,EAAEL,OAAO,CAACM,EAAE,CAAC;QAClJL,QAAQ,CAACM,OAAO,CAACH,eAAe,CAAC;OACpC,MAAM,IAAIJ,OAAO,CAACE,WAAW,KAAKP,WAAW,CAACa,MAAM,EAAE;QACnDP,QAAQ,CAACM,OAAO,CAAC,IAAIV,6BAA6B,CAACG,OAAO,CAACE,WAAW,EAAEF,OAAO,CAACS,aAAa,EAAEC,SAAS,EAAEV,OAAO,CAACM,EAAE,CAAC,CAAC;;KAE7H,CAAC,OAAOK,CAAC,EAAE;MACRV,QAAQ,CAACW,MAAM,CAAC,wCAAwCD,CAAW,EAAE,CAAC;;IAG1E,OAAOV,QAAQ,CAACY,OAAO;EAC3B;EAEA;;;EAGOC,qBAAqBA,CAACd,OAA0B;IAEnD,MAAMC,QAAQ,GAAG,IAAIP,QAAQ,EAAuB;IAEpD,IAAI;MACA,IAAIM,OAAO,CAACE,WAAW,KAAKP,WAAW,CAACQ,IAAI,EAAE;QAC1C,MAAMY,OAAO,GAAG,GAAGf,OAAO,CAACgB,QAAQ,GAAGhB,OAAO,CAACgB,QAAQ,GAAG,EAAE,EAAE;QAC7Df,QAAQ,CAACM,OAAO,CAAC,IAAIX,mBAAmB,CAACD,WAAW,CAACQ,IAAI,EAAEY,OAAO,EAAEf,OAAO,CAACM,EAAE,CAAC,CAAC;;KAEvF,CAAC,OAAOK,CAAC,EAAE;MACRV,QAAQ,CAACW,MAAM,CAAC,iCAAiCD,CAAW,EAAE,CAAC;;IAGnE,OAAOV,QAAQ,CAACY,OAAO;EAC3B"},"metadata":{},"sourceType":"module","externalDependencies":[]}