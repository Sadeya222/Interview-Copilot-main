{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ReplayableAudioNode } from \"../common.browser/Exports.js\";\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents.js\";\nimport { BackgroundEvent, createGuid, createNoDashGuid, Deferred, Events, EventSource, MessageType, ServiceEvent } from \"../common/Exports.js\";\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat.js\";\nimport { ActivityReceivedEventArgs, CancellationErrorCode, CancellationReason, DialogServiceConfig, PropertyCollection, PropertyId, RecognitionEventArgs, ResultReason, SessionEventArgs, SpeechRecognitionCanceledEventArgs, SpeechRecognitionEventArgs, SpeechRecognitionResult, TurnStatusReceivedEventArgs } from \"../sdk/Exports.js\";\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager.js\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechDetected, SpeechHypothesis, SpeechKeyword } from \"./Exports.js\";\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload.js\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\n    this.privEvents = new EventSource();\n    this.privDialogServiceConnector = dialogServiceConnector;\n    this.receiveMessageOverride = () => this.receiveDialogMessageOverride();\n    this.privTurnStateManager = new DialogServiceTurnStateManager();\n    this.recognizeOverride = (recoMode, successCallback, errorCallback) => this.listenOnce(recoMode, successCallback, errorCallback);\n    this.postConnectImplOverride = connection => this.dialogConnectImpl(connection);\n    this.configConnectionOverride = connection => this.configConnection(connection);\n    this.disconnectOverride = () => this.privDisconnect();\n    this.privDialogAudioSource = audioSource;\n    this.agentConfigSent = false;\n    this.privLastResult = null;\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        this.terminateMessageLoop = true;\n      }\n    });\n  }\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const interactionGuid = createGuid();\n      const requestId = createNoDashGuid();\n      const agentMessage = {\n        context: {\n          interactionId: interactionGuid\n        },\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        messagePayload: JSON.parse(message),\n        version: 0.5\n      };\n      const agentMessageJson = JSON.stringify(agentMessage);\n      const connection = yield this.fetchConnection();\n      yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson));\n    });\n  }\n  privDisconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n      this.terminateMessageLoop = true;\n      this.agentConfigSent = false;\n      return;\n    });\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    const resultProps = new PropertyCollection();\n    if (connectionMessage.messageType === MessageType.Text) {\n      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n    let result;\n    let processed;\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speech.phrase\":\n        const speechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n        if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\n          const args = this.fireEventForResult(speechPhrase, resultProps);\n          this.privLastResult = args.result;\n          if (!!this.privDialogServiceConnector.recognized) {\n            try {\n              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n              /* eslint-disable no-empty */\n            } catch (error) {\n              // Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n        }\n        processed = true;\n        break;\n      case \"speech.hypothesis\":\n        const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n        const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n        result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);\n        this.privRequestSession.onHypothesis(offset);\n        const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n        if (!!this.privDialogServiceConnector.recognizing) {\n          try {\n            this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"speech.keyword\":\n        const keyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\n        result = new SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);\n        if (keyword.Status !== \"Accepted\") {\n          this.privLastResult = result;\n        }\n        const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\n        if (!!this.privDialogServiceConnector.recognized) {\n          try {\n            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"audio\":\n        {\n          const audioRequestId = connectionMessage.requestId.toUpperCase();\n          const turn = this.privTurnStateManager.GetTurn(audioRequestId);\n          try {\n            // Empty binary message signals end of stream.\n            if (!connectionMessage.binaryBody) {\n              turn.endAudioStream();\n            } else {\n              turn.audioStream.write(connectionMessage.binaryBody);\n            }\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"response\":\n        {\n          this.handleResponseMessage(connectionMessage);\n        }\n        processed = true;\n        break;\n      default:\n        break;\n    }\n    const defferal = new Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = true;\n      if (!!this.privRequestSession.isRecognizing) {\n        yield this.privRequestSession.onStopRecognizing();\n      }\n      if (!!this.privDialogServiceConnector.canceled) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        const cancelEvent = new SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n        try {\n          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n          /* eslint-disable no-empty */\n        } catch (_a) {}\n        if (!!this.privSuccessCallback) {\n          const result = new SpeechRecognitionResult(undefined,\n          // ResultId\n          ResultReason.Canceled, undefined,\n          // Text\n          undefined,\n          // Duration\n          undefined,\n          // Offset\n          undefined,\n          // Language\n          undefined,\n          // Language Detection Confidence\n          undefined,\n          // Speaker Id\n          error, undefined,\n          // Json\n          properties);\n          try {\n            this.privSuccessCallback(result);\n            this.privSuccessCallback = undefined;\n            /* eslint-disable no-empty */\n          } catch (_b) {}\n        }\n      }\n    });\n  }\n  listenOnce(recoMode, successCallback, errorCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privRecognizerConfig.recognitionMode = recoMode;\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallback;\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\n      this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      const conPromise = this.connectImpl();\n      const preAudioPromise = this.sendPreAudioMessages();\n      const node = yield this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\n      const format = yield this.privDialogAudioSource.format;\n      const deviceInfo = yield this.privDialogAudioSource.deviceInfo;\n      const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\n      yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n        source: deviceInfo\n      };\n      try {\n        yield conPromise;\n        yield preAudioPromise;\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n        return Promise.resolve();\n      }\n      const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n      const audioSendPromise = this.sendAudio(audioNode);\n      // /* eslint-disable no-empty */\n      audioSendPromise.then(() => {}, error => __awaiter(this, void 0, void 0, function* () {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }));\n    });\n  }\n  // Establishes a websocket connection to the end point.\n  dialogConnectImpl(connection) {\n    this.privConnectionLoop = this.startMessageLoop();\n    return connection;\n  }\n  receiveDialogMessageOverride() {\n    // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n    const communicationCustodian = new Deferred();\n    const loop = () => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const isDisposed = this.isDisposed();\n        const terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;\n        if (isDisposed || terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve(undefined);\n          return;\n        }\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n        if (!message) {\n          return loop();\n        }\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n        switch (connectionMessage.path.toLowerCase()) {\n          case \"turn.start\":\n            {\n              const turnRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n              // turn started by the service\n              if (turnRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.StartTurn(turnRequestId);\n              } else {\n                this.privRequestSession.onServiceTurnStartResponse();\n              }\n            }\n            break;\n          case \"speech.startdetected\":\n            const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n            const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n            if (!!this.privRecognizer.speechStartDetected) {\n              this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n            }\n            break;\n          case \"speech.enddetected\":\n            let json;\n            if (connectionMessage.textBody.length > 0) {\n              json = connectionMessage.textBody;\n            } else {\n              // If the request was empty, the JSON returned is empty.\n              json = \"{ Offset: 0 }\";\n            }\n            const speechStopDetected = SpeechDetected.fromJSON(json);\n            this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n            const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n            if (!!this.privRecognizer.speechEndDetected) {\n              this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n            }\n            break;\n          case \"turn.end\":\n            {\n              const turnEndRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n              // turn started by the service\n              if (turnEndRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n              } else {\n                // Audio session turn\n                const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n                yield this.privRequestSession.onServiceTurnEndResponse(false);\n                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                  if (!!this.privRecognizer.sessionStopped) {\n                    this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                  }\n                }\n                // report result to promise.\n                if (!!this.privSuccessCallback && this.privLastResult) {\n                  try {\n                    this.privSuccessCallback(this.privLastResult);\n                    this.privLastResult = null;\n                  } catch (e) {\n                    if (!!this.privErrorCallback) {\n                      this.privErrorCallback(e);\n                    }\n                  }\n                  // Only invoke the call back once.\n                  // and if it's successful don't invoke the\n                  // error after that.\n                  this.privSuccessCallback = undefined;\n                  this.privErrorCallback = undefined;\n                }\n              }\n            }\n            break;\n          default:\n            try {\n              const processed = yield this.processTypeSpecificMessages(connectionMessage);\n              if (!processed) {\n                if (!!this.serviceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n            } catch (e) {\n              //\n            }\n        }\n        const ret = loop();\n        return ret;\n      } catch (error) {\n        this.terminateMessageLoop = true;\n        communicationCustodian.resolve();\n      }\n    });\n    loop().catch(reason => {\n      Events.instance.onEvent(new BackgroundEvent(reason));\n    });\n    return communicationCustodian.promise;\n  }\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = false;\n      try {\n        yield this.receiveDialogMessageOverride();\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }\n      return Promise.resolve();\n    });\n  }\n  // Takes an established websocket connection to the endpoint and sends speech configuration information.\n  configConnection(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.terminateMessageLoop) {\n        this.terminateMessageLoop = false;\n        return Promise.reject(\"Connection to service terminated.\");\n      }\n      yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n      yield this.sendAgentConfig(connection);\n      return connection;\n    });\n  }\n  sendPreAudioMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      this.addKeywordContextData();\n      yield this.sendSpeechContext(connection, true);\n      yield this.sendAgentContext(connection);\n      yield this.sendWaveHeader(connection);\n    });\n  }\n  sendAgentConfig(connection) {\n    if (this.agentConfig && !this.agentConfigSent) {\n      if (this.privRecognizerConfig.parameters.getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\n        const config = this.agentConfig.get();\n        config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n        this.agentConfig.set(config);\n      }\n      this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\n      const agentConfigJson = this.agentConfig.toJsonString();\n      // guard against sending this multiple times on one connection\n      this.agentConfigSent = true;\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent.config\", this.privRequestSession.requestId, \"application/json\", agentConfigJson));\n    }\n    return;\n  }\n  sendAgentContext(connection) {\n    const guid = createGuid();\n    const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\n    const agentContext = {\n      channelData: \"\",\n      context: {\n        interactionId: guid\n      },\n      messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n      version: 0.5\n    };\n    const agentContextJson = JSON.stringify(agentContext);\n    return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.agent.context\", this.privRequestSession.requestId, \"application/json\", agentContextJson));\n  }\n  fireEventForResult(serviceResult, properties) {\n    const resultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n    const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);\n    const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  }\n  handleResponseMessage(responseMessage) {\n    // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\n    // event according to the message type that's specified.\n    const responsePayload = JSON.parse(responseMessage.textBody);\n    switch (responsePayload.messageType.toLowerCase()) {\n      case \"message\":\n        const responseRequestId = responseMessage.requestId.toUpperCase();\n        const activityPayload = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\n        const turn = this.privTurnStateManager.GetTurn(responseRequestId);\n        // update the conversation Id\n        if (activityPayload.conversationId) {\n          const updateAgentConfig = this.agentConfig.get();\n          updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n          this.agentConfig.set(updateAgentConfig);\n        }\n        const pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\n        const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n        if (!!this.privDialogServiceConnector.activityReceived) {\n          try {\n            this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\n            /* eslint-disable-next-line no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        break;\n      case \"messagestatus\":\n        if (!!this.privDialogServiceConnector.turnStatusReceived) {\n          try {\n            this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new TurnStatusReceivedEventArgs(responseMessage.textBody));\n            /* eslint-disable-next-line no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        break;\n      default:\n        Events.instance.onEvent(new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\n        break;\n    }\n  }\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n  addKeywordContextData() {\n    const keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\n    if (keywordPropertyValue === undefined) {\n      return;\n    }\n    const keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\n    const keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Durations\");\n    const keywords = keywordPropertyValue.split(\";\");\n    const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\n    const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\n    const keywordDefinitionArray = [];\n    for (let i = 0; i < keywords.length; i++) {\n      const definition = {};\n      definition.text = keywords[i];\n      if (i < keywordOffsets.length) {\n        definition.offset = Number(keywordOffsets[i]);\n      }\n      if (i < keywordDurations.length) {\n        definition.duration = Number(keywordDurations[i]);\n      }\n      keywordDefinitionArray.push(definition);\n    }\n    this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\n    this.speechContext.setSection(\"keywordDetection\", [{\n      clientDetectedKeywords: keywordDefinitionArray,\n      onReject: {\n        action: \"EndOfTurn\"\n      },\n      type: \"startTrigger\"\n    }]);\n  }\n}","map":{"version":3,"names":["ReplayableAudioNode","SendingAgentContextMessageEvent","BackgroundEvent","createGuid","createNoDashGuid","Deferred","Events","EventSource","MessageType","ServiceEvent","AudioOutputFormatImpl","ActivityReceivedEventArgs","CancellationErrorCode","CancellationReason","DialogServiceConfig","PropertyCollection","PropertyId","RecognitionEventArgs","ResultReason","SessionEventArgs","SpeechRecognitionCanceledEventArgs","SpeechRecognitionEventArgs","SpeechRecognitionResult","TurnStatusReceivedEventArgs","DialogServiceTurnStateManager","CancellationErrorCodePropertyName","EnumTranslation","RecognitionStatus","ServiceRecognizerBase","SimpleSpeechPhrase","SpeechDetected","SpeechHypothesis","SpeechKeyword","ActivityPayloadResponse","SpeechConnectionMessage","DialogServiceAdapter","constructor","authentication","connectionFactory","audioSource","recognizerConfig","dialogServiceConnector","privEvents","privDialogServiceConnector","receiveMessageOverride","receiveDialogMessageOverride","privTurnStateManager","recognizeOverride","recoMode","successCallback","errorCallback","listenOnce","postConnectImplOverride","connection","dialogConnectImpl","configConnectionOverride","configConnection","disconnectOverride","privDisconnect","privDialogAudioSource","agentConfigSent","privLastResult","connectionEvents","attach","connectionEvent","name","terminateMessageLoop","sendMessage","message","interactionGuid","requestId","agentMessage","context","interactionId","messagePayload","JSON","parse","version","agentMessageJson","stringify","fetchConnection","send","Text","cancelRecognition","privRequestSession","sessionId","Error","NoError","processTypeSpecificMessages","connectionMessage","resultProps","messageType","setProperty","SpeechServiceResponse_JsonResult","textBody","result","processed","path","toLowerCase","speechPhrase","fromJSON","onPhraseRecognized","currentTurnAudioOffset","Offset","Duration","TooManyRequests","args","fireEventForResult","recognized","error","hypothesis","offset","RecognizingSpeech","Language","LanguageDetectionConfidence","undefined","onHypothesis","ev","recognizing","keyword","Status","RecognizedKeyword","NoMatch","event","duration","resultId","audioRequestId","toUpperCase","turn","GetTurn","binaryBody","endAudioStream","audioStream","write","handleResponseMessage","defferal","resolve","promise","cancellationReason","errorCode","isRecognizing","onStopRecognizing","canceled","properties","cancelEvent","_a","privSuccessCallback","Canceled","_b","privRecognizerConfig","recognitionMode","privErrorCallback","startNewRecognition","listenForServiceTelemetry","events","parameters","Speech_SessionId","conPromise","connectImpl","preAudioPromise","sendPreAudioMessages","node","audioNodeId","format","deviceInfo","audioNode","avgBytesPerSec","onAudioSourceAttachCompleted","SpeechServiceConfig","Context","audio","source","ConnectionFailure","Promise","sessionStartEventArgs","privRecognizer","sessionStarted","audioSendPromise","sendAudio","then","__awaiter","RuntimeError","privConnectionLoop","startMessageLoop","communicationCustodian","loop","isDisposed","read","fromConnectionMessage","turnRequestId","audioSessionReqId","StartTurn","onServiceTurnStartResponse","speechStartDetected","speechStartEventArgs","json","length","speechStopDetected","onServiceRecognized","speechStopEventArgs","speechEndDetected","turnEndRequestId","CompleteTurn","sessionStopEventArgs","onServiceTurnEndResponse","isContinuousRecognition","isSpeechEnded","sessionStopped","e","serviceEvents","onEvent","ret","catch","reason","instance","reject","sendSpeechServiceConfig","serialize","sendAgentConfig","addKeywordContextData","sendSpeechContext","sendAgentContext","sendWaveHeader","agentConfig","getProperty","Conversation_DialogType","DialogTypes","CustomCommands","config","get","botInfo","commandsCulture","SpeechServiceConnection_RecoLanguage","set","agentConfigJson","toJsonString","guid","speechActivityTemplate","Conversation_Speech_Activity_Template","agentContext","channelData","agentContextJson","serviceResult","resultReason","implTranslateRecognitionResult","DisplayText","responseMessage","responsePayload","responseRequestId","activityPayload","conversationId","updateAgentConfig","pullAudioOutputStream","processActivityPayload","fromSpeechSynthesisOutputFormatString","SpeechServiceConnection_SynthOutputFormat","activity","activityReceived","turnStatusReceived","keywordPropertyValue","keywordOffsetPropertyValue","keywordDurationPropertyValue","keywords","split","keywordOffsets","keywordDurations","keywordDefinitionArray","i","definition","text","Number","push","speechContext","setSection","clientDetectedKeywords","onReject","action","type"],"sources":["src/common.speech/DialogServiceAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ReplayableAudioNode\r\n} from \"../common.browser/Exports.js\";\r\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents.js\";\r\nimport {\r\n    BackgroundEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    DialogEvent,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports.js\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat.js\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream.js\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat.js\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConfig,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    TurnStatusReceivedEventArgs,\r\n} from \"../sdk/Exports.js\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager.js\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n    SpeechKeyword,\r\n} from \"./Exports.js\";\r\nimport { IAuthentication } from \"./IAuthentication.js\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory.js\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig.js\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload.js\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n\r\n    private privDialogAudioSource: IAudioSource;\r\n\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n    private privEvents: EventSource<DialogEvent>;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privEvents = new EventSource<DialogEvent>();\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.receiveMessageOverride = (): Promise<void> => this.receiveDialogMessageOverride();\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride =\r\n            (recoMode: RecognitionMode, successCallback: (e: SpeechRecognitionResult) => void, errorCallback: (e: string) => void): Promise<void> =>\r\n            this.listenOnce(recoMode, successCallback, errorCallback);\r\n        this.postConnectImplOverride = (connection: Promise<IConnection>): Promise<IConnection> => this.dialogConnectImpl(connection);\r\n        this.configConnectionOverride = (connection: IConnection): Promise<IConnection> => this.configConnection(connection);\r\n        this.disconnectOverride = (): Promise<void> => this.privDisconnect();\r\n        this.privDialogAudioSource = audioSource;\r\n\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                this.terminateMessageLoop = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"agent\",\r\n            requestId,\r\n            \"application/json\",\r\n            agentMessageJson));\r\n\r\n    }\r\n\r\n    protected async privDisconnect(): Promise<void> {\r\n        await this.cancelRecognition(this.privRequestSession.sessionId,\r\n            this.privRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        return;\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* eslint-disable no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.keyword\":\r\n                const keyword: SpeechKeyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch,\r\n                    keyword.Text,\r\n                    keyword.Duration,\r\n                    keyword.Offset,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                if (keyword.Status !== \"Accepted\") {\r\n                    this.privLastResult = result;\r\n                }\r\n\r\n                const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognized) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    this.handleResponseMessage(connectionMessage);\r\n\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        const defferal = new Deferred<boolean>();\r\n        defferal.resolve(processed);\r\n        return defferal.promise;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected async cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): Promise<void> {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privRequestSession.isRecognizing) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Duration\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    undefined, // Speaker Id\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* eslint-disable no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async listenOnce(\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<void> {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n\r\n        const preAudioPromise: Promise<void> = this.sendPreAudioMessages();\r\n\r\n        const node: IAudioStreamNode = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\r\n        const format: AudioStreamFormatImpl = await this.privDialogAudioSource.format;\r\n        const deviceInfo: ISpeechConfigAudioDevice = await this.privDialogAudioSource.deviceInfo;\r\n\r\n        const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\r\n        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        try {\r\n            await conPromise;\r\n            await preAudioPromise;\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error as string);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        // /* eslint-disable no-empty */\r\n        audioSendPromise.then((): void => { /* add? return true;*/ }, async (error: string): Promise<void> => {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    private receiveDialogMessageOverride(): Promise<void> {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        const loop = async (): Promise<void> => {\r\n            try {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return;\r\n                }\r\n\r\n                const connection: IConnection = await this.fetchConnection();\r\n                const message: ConnectionMessage = await connection.read();\r\n\r\n                if (!message) {\r\n                    return loop();\r\n                }\r\n\r\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        {\r\n                            const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.StartTurn(turnRequestId);\r\n                            } else {\r\n                                this.privRequestSession.onServiceTurnStartResponse();\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"speech.startdetected\":\r\n                        const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechStartDetected) {\r\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case \"speech.enddetected\":\r\n\r\n                        let json: string;\r\n\r\n                        if (connectionMessage.textBody.length > 0) {\r\n                            json = connectionMessage.textBody;\r\n                        } else {\r\n                            // If the request was empty, the JSON returned is empty.\r\n                            json = \"{ Offset: 0 }\";\r\n                        }\r\n\r\n                        const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\r\n\r\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechEndDetected) {\r\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"turn.end\":\r\n                        {\r\n                            const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnEndRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                            } else {\r\n                                // Audio session turn\r\n\r\n                                const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n                                await this.privRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\r\n                                    if (!!this.privRecognizer.sessionStopped) {\r\n                                        this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                    }\r\n                                }\r\n\r\n                                // report result to promise.\r\n                                if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                    try {\r\n                                        this.privSuccessCallback(this.privLastResult);\r\n                                        this.privLastResult = null;\r\n                                    } catch (e) {\r\n                                        if (!!this.privErrorCallback) {\r\n                                            this.privErrorCallback(e as string);\r\n                                        }\r\n                                    }\r\n                                    // Only invoke the call back once.\r\n                                    // and if it's successful don't invoke the\r\n                                    // error after that.\r\n                                    this.privSuccessCallback = undefined;\r\n                                    this.privErrorCallback = undefined;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        try {\r\n                            const processed = await this.processTypeSpecificMessages(connectionMessage);\r\n                            if (!processed) {\r\n                                if (!!this.serviceEvents) {\r\n                                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                                }\r\n                            }\r\n                        } catch (e) {\r\n                            //\r\n                        }\r\n                }\r\n                const ret: Promise<void> = loop();\r\n\r\n                return ret;\r\n            } catch (error) {\r\n                this.terminateMessageLoop = true;\r\n                communicationCustodian.resolve();\r\n            }\r\n        };\r\n\r\n        loop().catch((reason: string): void => {\r\n            Events.instance.onEvent(new BackgroundEvent(reason));\r\n        });\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        try {\r\n            await this.receiveDialogMessageOverride();\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error as string);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configConnection(connection: IConnection): Promise<IConnection> {\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return Promise.reject(\"Connection to service terminated.\");\r\n        }\r\n\r\n        await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\r\n        await this.sendAgentConfig(connection);\r\n        return connection;\r\n    }\r\n\r\n    private async sendPreAudioMessages(): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        this.addKeywordContextData();\r\n        await this.sendSpeechContext(connection, true);\r\n        await this.sendAgentContext(connection);\r\n        await this.sendWaveHeader(connection);\r\n    }\r\n\r\n    private sendAgentConfig(connection: IConnection): Promise<void> {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig\r\n                .parameters\r\n                .getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\r\n\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    private sendAgentContext(connection: IConnection): Promise<void> {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n\r\n    private handleResponseMessage(responseMessage: SpeechConnectionMessage): void {\r\n        // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\r\n        // event according to the message type that's specified.\r\n        const responsePayload: { messageType: string } = JSON.parse(responseMessage.textBody) as { messageType: string };\r\n        switch (responsePayload.messageType.toLowerCase()) {\r\n            case \"message\":\r\n                const responseRequestId = responseMessage.requestId.toUpperCase();\r\n                const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\r\n                const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                // update the conversation Id\r\n                if (activityPayload.conversationId) {\r\n                    const updateAgentConfig = this.agentConfig.get();\r\n                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                    this.agentConfig.set(updateAgentConfig);\r\n                }\r\n\r\n                const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(\r\n                    activityPayload,\r\n                    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\r\n                const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                if (!!this.privDialogServiceConnector.activityReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                        /* eslint-disable-next-line no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"messagestatus\":\r\n                if (!!this.privDialogServiceConnector.turnStatusReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.turnStatusReceived(\r\n                            this.privDialogServiceConnector,\r\n                            new TurnStatusReceivedEventArgs(responseMessage.textBody));\r\n                        /* eslint-disable-next-line no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            default:\r\n                Events.instance.onEvent(\r\n                    new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onEvent(event: DialogEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private addKeywordContextData(): void {\r\n        const keywordPropertyValue: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\r\n        if (keywordPropertyValue === undefined) {\r\n            return;\r\n        }\r\n\r\n        const keywordOffsetPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\r\n        const keywordDurationPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Durations\");\r\n\r\n        const keywords = keywordPropertyValue.split(\";\");\r\n        const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\r\n        const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\r\n\r\n        const keywordDefinitionArray = [];\r\n        for (let i = 0; i < keywords.length; i++) {\r\n            const definition: { [section: string]: any } = {};\r\n            definition.text = keywords[i];\r\n            if (i < keywordOffsets.length) {\r\n                definition.offset = Number(keywordOffsets[i]);\r\n            }\r\n            if (i < keywordDurations.length) {\r\n                definition.duration = Number(keywordDurations[i]);\r\n            }\r\n            keywordDefinitionArray.push(definition);\r\n        }\r\n\r\n        this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\r\n        this.speechContext.setSection(\"keywordDetection\", [{\r\n            clientDetectedKeywords: keywordDefinitionArray,\r\n            onReject: { action: \"EndOfTurn\" },\r\n            type: \"startTrigger\"\r\n        }]);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}