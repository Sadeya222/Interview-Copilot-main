{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { SpeechSynthesisConnectionFactory } from \"../common.speech/SpeechSynthesisConnectionFactory.js\";\nimport { AvatarSynthesisAdapter } from \"../common.speech/Exports.js\";\nimport { createNoDashGuid, Deferred, Events, EventType, PlatformEvent } from \"../common/Exports.js\";\nimport { AudioOutputFormatImpl } from \"./Audio/AudioOutputFormat.js\";\nimport { PropertyId, SpeechSynthesisOutputFormat, SynthesisResult, Synthesizer } from \"./Exports.js\";\nimport { Contracts } from \"./Contracts.js\";\nimport { SynthesisRequest } from \"./Synthesizer.js\";\n/**\n * Defines the avatar synthesizer.\n * @class AvatarSynthesizer\n * Added in version 1.33.0\n *\n * @experimental This feature is experimental and might change or have limited support.\n */\nexport class AvatarSynthesizer extends Synthesizer {\n  /**\n   * Creates and initializes an instance of this class.\n   * @constructor\n   * @param {SpeechConfig} speechConfig - The speech config.\n   * @param {AvatarConfig} avatarConfig - The talking avatar config.\n   */\n  constructor(speechConfig, avatarConfig) {\n    super(speechConfig);\n    Contracts.throwIfNullOrUndefined(avatarConfig, \"avatarConfig\");\n    this.privConnectionFactory = new SpeechSynthesisConnectionFactory();\n    this.privAvatarConfig = avatarConfig;\n    this.implCommonSynthesizeSetup();\n  }\n  implCommonSynthesizeSetup() {\n    super.implCommonSynthesizeSetup();\n    // The service checks the audio format setting while it ignores it in avatar synthesis.\n    this.privAdapter.audioOutputFormat = AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);\n  }\n  /**\n   * Starts the talking avatar session and establishes the WebRTC connection.\n   * @member AvatarSynthesizer.prototype.startAvatarAsync\n   * @function\n   * @public\n   * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.\n   * @returns {Promise<SynthesisResult>} The promise of the connection result.\n   */\n  startAvatarAsync(peerConnection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts.throwIfNullOrUndefined(peerConnection, \"peerConnection\");\n      this.privIceServers = peerConnection.getConfiguration().iceServers;\n      Contracts.throwIfNullOrUndefined(this.privIceServers, \"Ice servers must be set.\");\n      const iceGatheringDone = new Deferred();\n      // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\n      peerConnection.onicegatheringstatechange = () => {\n        Events.instance.onEvent(new PlatformEvent(\"peer connection: ice gathering state: \" + peerConnection.iceGatheringState, EventType.Debug));\n        if (peerConnection.iceGatheringState === \"complete\") {\n          Events.instance.onEvent(new PlatformEvent(\"peer connection: ice gathering complete.\", EventType.Info));\n          iceGatheringDone.resolve();\n        }\n      };\n      const sdp = yield peerConnection.createOffer();\n      yield peerConnection.setLocalDescription(sdp);\n      yield iceGatheringDone.promise;\n      Events.instance.onEvent(new PlatformEvent(\"peer connection: got local SDP.\", EventType.Info));\n      this.privProperties.setProperty(PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(peerConnection.localDescription));\n      const result = yield this.speak(\"\", false);\n      const sdpAnswerString = atob(result.properties.getProperty(PropertyId.TalkingAvatarService_WebRTC_SDP));\n      const sdpAnswer = new RTCSessionDescription(JSON.parse(sdpAnswerString));\n      yield peerConnection.setRemoteDescription(sdpAnswer);\n      return new SynthesisResult(result.resultId, result.reason, undefined, result.properties);\n    });\n  }\n  /**\n   * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.\n   * @member AvatarSynthesizer.prototype.speakTextAsync\n   * @function\n   * @public\n   * @param {string} text - The plain text to speak.\n   * @returns {Promise<SynthesisResult>} The promise of the synthesis result.\n   */\n  speakTextAsync(text) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const r = yield this.speak(text, false);\n      return new SynthesisResult(r.resultId, r.reason, r.errorDetails, r.properties);\n    });\n  }\n  /**\n   * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.\n   * @member AvatarSynthesizer.prototype.speakSsmlAsync\n   * @function\n   * @public\n   * @param {string} ssml - The SSML text to speak.\n   * @returns {Promise<SynthesisResult>} The promise of the synthesis result.\n   */\n  speakSsmlAsync(ssml) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const r = yield this.speak(ssml, true);\n      return new SynthesisResult(r.resultId, r.reason, r.errorDetails, r.properties);\n    });\n  }\n  /**\n   * Speaks text asynchronously. The avatar will switch to idle state.\n   * @member AvatarSynthesizer.prototype.stopSpeakingAsync\n   * @function\n   * @public\n   * @returns {Promise<void>} The promise of the void result.\n   */\n  stopSpeakingAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.privAdapter.stopSpeaking();\n    });\n  }\n  /**\n   * Stops the talking avatar session and closes the WebRTC connection.\n   * For now, this is the same as close().\n   * You need to create a new AvatarSynthesizer instance to start a new session.\n   * @member AvatarSynthesizer.prototype.stopAvatarAsync\n   * @function\n   * @public\n   * @returns {Promise<void>} The promise of the void result.\n   */\n  stopAvatarAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts.throwIfDisposed(this.privDisposed);\n      return this.dispose(true);\n    });\n  }\n  /**\n   * Dispose of associated resources.\n   * @member AvatarSynthesizer.prototype.close\n   * @function\n   * @public\n   */\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privDisposed) {\n        return;\n      }\n      return this.dispose(true);\n    });\n  }\n  /**\n   * Gets the ICE servers. Internal use only.\n   */\n  get iceServers() {\n    return this.privIceServers;\n  }\n  // Creates the synthesis adapter\n  createSynthesisAdapter(authentication, connectionFactory, synthesizerConfig) {\n    return new AvatarSynthesisAdapter(authentication, connectionFactory, synthesizerConfig, this, this.privAvatarConfig);\n  }\n  createRestSynthesisAdapter(_authentication, _synthesizerConfig) {\n    return undefined;\n  }\n  createSynthesizerConfig(speechConfig) {\n    const config = super.createSynthesizerConfig(speechConfig);\n    config.avatarEnabled = true;\n    return config;\n  }\n  speak(text, isSSML) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const requestId = createNoDashGuid();\n      const deferredResult = new Deferred();\n      this.synthesisRequestQueue.enqueue(new SynthesisRequest(requestId, text, isSSML, e => {\n        deferredResult.resolve(e);\n        this.privSynthesizing = false;\n        void this.adapterSpeak();\n      }, e => {\n        deferredResult.reject(e);\n        this.privSynthesizing = false;\n      }));\n      void this.adapterSpeak();\n      return deferredResult.promise;\n    });\n  }\n}","map":{"version":3,"names":["SpeechSynthesisConnectionFactory","AvatarSynthesisAdapter","createNoDashGuid","Deferred","Events","EventType","PlatformEvent","AudioOutputFormatImpl","PropertyId","SpeechSynthesisOutputFormat","SynthesisResult","Synthesizer","Contracts","SynthesisRequest","AvatarSynthesizer","constructor","speechConfig","avatarConfig","throwIfNullOrUndefined","privConnectionFactory","privAvatarConfig","implCommonSynthesizeSetup","privAdapter","audioOutputFormat","fromSpeechSynthesisOutputFormat","Riff24Khz16BitMonoPcm","startAvatarAsync","peerConnection","privIceServers","getConfiguration","iceServers","iceGatheringDone","onicegatheringstatechange","instance","onEvent","iceGatheringState","Debug","Info","resolve","sdp","createOffer","setLocalDescription","promise","privProperties","setProperty","TalkingAvatarService_WebRTC_SDP","JSON","stringify","localDescription","result","speak","sdpAnswerString","atob","properties","getProperty","sdpAnswer","RTCSessionDescription","parse","setRemoteDescription","resultId","reason","undefined","speakTextAsync","text","r","errorDetails","speakSsmlAsync","ssml","stopSpeakingAsync","stopSpeaking","stopAvatarAsync","throwIfDisposed","privDisposed","dispose","close","createSynthesisAdapter","authentication","connectionFactory","synthesizerConfig","createRestSynthesisAdapter","_authentication","_synthesizerConfig","createSynthesizerConfig","config","avatarEnabled","isSSML","requestId","deferredResult","synthesisRequestQueue","enqueue","e","privSynthesizing","adapterSpeak","reject"],"sources":["src/sdk/AvatarSynthesizer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { SpeechSynthesisConnectionFactory } from \"../common.speech/SpeechSynthesisConnectionFactory.js\";\r\nimport { SynthesisRestAdapter } from \"../common.speech/SynthesisRestAdapter.js\";\r\nimport { SynthesizerConfig } from \"../common.speech/SynthesizerConfig.js\";\r\nimport {\r\n    AvatarSynthesisAdapter,\r\n    IAuthentication,\r\n    ISynthesisConnectionFactory,\r\n    SpeechServiceConfig,\r\n    SynthesisAdapterBase\r\n} from \"../common.speech/Exports.js\";\r\nimport { createNoDashGuid, Deferred, Events, EventType, PlatformEvent } from \"../common/Exports.js\";\r\nimport { AudioOutputFormatImpl } from \"./Audio/AudioOutputFormat.js\";\r\nimport {\r\n    AvatarConfig,\r\n    AvatarEventArgs,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    SpeechConfig,\r\n    SpeechSynthesisOutputFormat,\r\n    SpeechSynthesisResult,\r\n    SynthesisResult,\r\n    Synthesizer\r\n} from \"./Exports.js\";\r\nimport { Contracts } from \"./Contracts.js\";\r\nimport { SynthesisRequest } from \"./Synthesizer.js\";\r\n\r\n/**\r\n * Defines the avatar synthesizer.\r\n * @class AvatarSynthesizer\r\n * Added in version 1.33.0\r\n *\r\n * @experimental This feature is experimental and might change or have limited support.\r\n */\r\nexport class AvatarSynthesizer extends Synthesizer {\r\n    protected privProperties: PropertyCollection;\r\n    private privAvatarConfig: AvatarConfig;\r\n    private privIceServers: RTCIceServer[];\r\n    /**\r\n     * Defines event handler for avatar events.\r\n     * @member AvatarSynthesizer.prototype.avatarEventReceived\r\n     * @function\r\n     * @public\r\n     */\r\n    public avatarEventReceived: (sender: AvatarSynthesizer, event: AvatarEventArgs) => void;\r\n\r\n    /**\r\n     * Creates and initializes an instance of this class.\r\n     * @constructor\r\n     * @param {SpeechConfig} speechConfig - The speech config.\r\n     * @param {AvatarConfig} avatarConfig - The talking avatar config.\r\n     */\r\n    public constructor(speechConfig: SpeechConfig, avatarConfig: AvatarConfig) {\r\n        super(speechConfig);\r\n\r\n        Contracts.throwIfNullOrUndefined(avatarConfig, \"avatarConfig\");\r\n\r\n        this.privConnectionFactory = new SpeechSynthesisConnectionFactory();\r\n        this.privAvatarConfig = avatarConfig;\r\n        this.implCommonSynthesizeSetup();\r\n    }\r\n\r\n    protected implCommonSynthesizeSetup(): void {\r\n        super.implCommonSynthesizeSetup();\r\n\r\n        // The service checks the audio format setting while it ignores it in avatar synthesis.\r\n        this.privAdapter.audioOutputFormat = AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(\r\n            SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Starts the talking avatar session and establishes the WebRTC connection.\r\n     * @member AvatarSynthesizer.prototype.startAvatarAsync\r\n     * @function\r\n     * @public\r\n     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.\r\n     * @returns {Promise<SynthesisResult>} The promise of the connection result.\r\n     */\r\n    public async startAvatarAsync(peerConnection: RTCPeerConnection): Promise<SynthesisResult> {\r\n        Contracts.throwIfNullOrUndefined(peerConnection, \"peerConnection\");\r\n        this.privIceServers = peerConnection.getConfiguration().iceServers;\r\n        Contracts.throwIfNullOrUndefined(this.privIceServers, \"Ice servers must be set.\");\r\n        const iceGatheringDone = new Deferred<void>();\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event\r\n        peerConnection.onicegatheringstatechange = (): void => {\r\n            Events.instance.onEvent(new PlatformEvent(\"peer connection: ice gathering state: \" + peerConnection.iceGatheringState, EventType.Debug));\r\n            if (peerConnection.iceGatheringState === \"complete\") {\r\n                Events.instance.onEvent(new PlatformEvent(\"peer connection: ice gathering complete.\", EventType.Info));\r\n                iceGatheringDone.resolve();\r\n            }\r\n        };\r\n        const sdp: RTCSessionDescriptionInit = await peerConnection.createOffer();\r\n        await peerConnection.setLocalDescription(sdp);\r\n        await iceGatheringDone.promise;\r\n        Events.instance.onEvent(new PlatformEvent(\"peer connection: got local SDP.\", EventType.Info));\r\n        this.privProperties.setProperty(PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(peerConnection.localDescription));\r\n\r\n        const result: SpeechSynthesisResult = await this.speak(\"\", false);\r\n        const sdpAnswerString: string = atob(result.properties.getProperty(PropertyId.TalkingAvatarService_WebRTC_SDP));\r\n        const sdpAnswer: RTCSessionDescription = new RTCSessionDescription(\r\n            JSON.parse(sdpAnswerString) as RTCSessionDescriptionInit,\r\n        );\r\n        await peerConnection.setRemoteDescription(sdpAnswer);\r\n        return new SynthesisResult(\r\n            result.resultId,\r\n            result.reason,\r\n            undefined,\r\n            result.properties,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.\r\n     * @member AvatarSynthesizer.prototype.speakTextAsync\r\n     * @function\r\n     * @public\r\n     * @param {string} text - The plain text to speak.\r\n     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.\r\n     */\r\n    public async speakTextAsync(text: string): Promise<SynthesisResult> {\r\n        const r = await this.speak(text, false);\r\n        return new SynthesisResult(\r\n            r.resultId,\r\n            r.reason,\r\n            r.errorDetails,\r\n            r.properties,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.\r\n     * @member AvatarSynthesizer.prototype.speakSsmlAsync\r\n     * @function\r\n     * @public\r\n     * @param {string} ssml - The SSML text to speak.\r\n     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.\r\n     */\r\n    public async speakSsmlAsync(ssml: string): Promise<SynthesisResult> {\r\n        const r = await this.speak(ssml, true);\r\n        return new SynthesisResult(\r\n            r.resultId,\r\n            r.reason,\r\n            r.errorDetails,\r\n            r.properties,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Speaks text asynchronously. The avatar will switch to idle state.\r\n     * @member AvatarSynthesizer.prototype.stopSpeakingAsync\r\n     * @function\r\n     * @public\r\n     * @returns {Promise<void>} The promise of the void result.\r\n     */\r\n    public async stopSpeakingAsync(): Promise<void> {\r\n        return this.privAdapter.stopSpeaking();\r\n    }\r\n\r\n    /**\r\n     * Stops the talking avatar session and closes the WebRTC connection.\r\n     * For now, this is the same as close().\r\n     * You need to create a new AvatarSynthesizer instance to start a new session.\r\n     * @member AvatarSynthesizer.prototype.stopAvatarAsync\r\n     * @function\r\n     * @public\r\n     * @returns {Promise<void>} The promise of the void result.\r\n     */\r\n    public async stopAvatarAsync(): Promise<void> {\r\n        Contracts.throwIfDisposed(this.privDisposed);\r\n        return this.dispose(true);\r\n    }\r\n\r\n    /**\r\n     * Dispose of associated resources.\r\n     * @member AvatarSynthesizer.prototype.close\r\n     * @function\r\n     * @public\r\n     */\r\n    public async close(): Promise<void> {\r\n        if (this.privDisposed) {\r\n            return;\r\n        }\r\n\r\n        return this.dispose(true);\r\n    }\r\n\r\n    /**\r\n     * Gets the ICE servers. Internal use only.\r\n     */\r\n    public get iceServers(): RTCIceServer[] {\r\n        return this.privIceServers;\r\n    }\r\n\r\n    // Creates the synthesis adapter\r\n    protected createSynthesisAdapter(\r\n        authentication: IAuthentication,\r\n        connectionFactory: ISynthesisConnectionFactory,\r\n        synthesizerConfig: SynthesizerConfig): SynthesisAdapterBase {\r\n        return new AvatarSynthesisAdapter(\r\n            authentication,\r\n            connectionFactory,\r\n            synthesizerConfig,\r\n            this,\r\n            this.privAvatarConfig);\r\n    }\r\n\r\n    protected createRestSynthesisAdapter(\r\n        _authentication: IAuthentication,\r\n        _synthesizerConfig: SynthesizerConfig): SynthesisRestAdapter {\r\n        return undefined;\r\n    }\r\n\r\n    protected createSynthesizerConfig(speechConfig: SpeechServiceConfig): SynthesizerConfig {\r\n        const config = super.createSynthesizerConfig(speechConfig);\r\n        config.avatarEnabled = true;\r\n        return config;\r\n    }\r\n\r\n    protected async speak(text: string, isSSML: boolean): Promise<SpeechSynthesisResult> {\r\n        const requestId = createNoDashGuid();\r\n        const deferredResult = new Deferred<SpeechSynthesisResult>();\r\n        this.synthesisRequestQueue.enqueue(new SynthesisRequest(requestId, text, isSSML,\r\n            (e: SpeechSynthesisResult): void => {\r\n                deferredResult.resolve(e);\r\n                this.privSynthesizing = false;\r\n                void this.adapterSpeak();\r\n            },\r\n            (e: string): void => {\r\n                deferredResult.reject(e);\r\n                this.privSynthesizing = false;\r\n            }));\r\n        void this.adapterSpeak();\r\n        return deferredResult.promise;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}