{"ast":null,"code":"//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { ServiceRecognizerBase, SynthesisAdapterBase } from \"../common.speech/Exports.js\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports.js\";\nimport { ConnectionMessageImpl } from \"./ConnectionMessage.js\";\nimport { Contracts } from \"./Contracts.js\";\nimport { ConnectionEventArgs, ConnectionMessageEventArgs, ServiceEventArgs } from \"./Exports.js\";\n/**\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\n * By default, a Recognizer autonomously manages connection to service when needed.\n * The Connection class provides additional methods for users to explicitly open or close a connection and\n * to subscribe to connection status changes.\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\n * in advance before starting recognition on the Recognizer associated with this Connection.\n * If the Recognizer needs to connect or disconnect to service, it will\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\n * status via Connected/Disconnected events.\n * Added in version 1.2.1.\n */\nexport class Connection {\n  /**\n   * Gets the Connection instance from the specified recognizer.\n   * @param recognizer The recognizer associated with the connection.\n   * @return The Connection instance of the recognizer.\n   */\n  static fromRecognizer(recognizer) {\n    const recoBase = recognizer.internalData;\n    const ret = new Connection();\n    ret.privInternalData = recoBase;\n    ret.setupEvents();\n    return ret;\n  }\n  /**\n   * Gets the Connection instance from the specified synthesizer.\n   * @param synthesizer The synthesizer associated with the connection.\n   * @return The Connection instance of the synthesizer.\n   */\n  static fromSynthesizer(synthesizer) {\n    const synthBase = synthesizer.internalData;\n    const ret = new Connection();\n    ret.privInternalData = synthBase;\n    ret.setupEvents();\n    return ret;\n  }\n  /**\n   * Starts to set up connection to the service.\n   * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\n   * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\n   *\n   * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n   * be notified when the connection is established.\n   */\n  openConnection(cb, err) {\n    marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);\n  }\n  /**\n   * Closes the connection the service.\n   * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\n   *\n   * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\n   */\n  closeConnection(cb, err) {\n    if (this.privInternalData instanceof SynthesisAdapterBase) {\n      throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\n    } else {\n      marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);\n    }\n  }\n  /**\n   * Appends a parameter in a message to service.\n   * Added in version 1.12.1.\n   * @param path The path of the network message.\n   * @param propertyName Name of the property\n   * @param propertyValue Value of the property. This is a json string.\n   */\n  setMessageProperty(path, propertyName, propertyValue) {\n    Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\n    if (this.privInternalData instanceof ServiceRecognizerBase) {\n      if (path.toLowerCase() !== \"speech.context\") {\n        throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\n      } else {\n        this.privInternalData.speechContext.setSection(propertyName, propertyValue);\n      }\n    } else if (this.privInternalData instanceof SynthesisAdapterBase) {\n      if (path.toLowerCase() !== \"synthesis.context\") {\n        throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\n      } else {\n        this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);\n      }\n    }\n  }\n  /**\n   * Sends a message to the speech service.\n   * Added in version 1.13.0.\n   * @param path The WebSocket path of the message\n   * @param payload The payload of the message. This is a json string or a ArrayBuffer.\n   * @param success A callback to indicate success.\n   * @param error A callback to indicate an error.\n   */\n  sendMessageAsync(path, payload, success, error) {\n    marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);\n  }\n  /**\n   * Dispose of associated resources.\n   */\n  close() {\n    /* eslint-disable no-empty */\n  }\n  setupEvents() {\n    this.privEventListener = this.privInternalData.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n        if (!!this.connected) {\n          this.connected(new ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        if (!!this.disconnected) {\n          this.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\n        if (!!this.messageSent) {\n          this.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\n        if (!!this.messageReceived) {\n          this.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n        }\n      }\n    });\n    this.privServiceEventListener = this.privInternalData.serviceEvents.attach(e => {\n      if (!!this.receivedServiceMessage) {\n        this.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\n      }\n    });\n  }\n}","map":{"version":3,"names":["ServiceRecognizerBase","SynthesisAdapterBase","marshalPromiseToCallbacks","ConnectionMessageImpl","Contracts","ConnectionEventArgs","ConnectionMessageEventArgs","ServiceEventArgs","Connection","fromRecognizer","recognizer","recoBase","internalData","ret","privInternalData","setupEvents","fromSynthesizer","synthesizer","synthBase","openConnection","cb","err","connect","closeConnection","Error","disconnect","setMessageProperty","path","propertyName","propertyValue","throwIfNullOrWhitespace","toLowerCase","speechContext","setSection","synthesisContext","sendMessageAsync","payload","success","error","sendNetworkMessage","close","privEventListener","connectionEvents","attach","connectionEvent","name","connected","connectionId","disconnected","messageSent","message","messageReceived","privServiceEventListener","serviceEvents","e","receivedServiceMessage","jsonString"],"sources":["src/sdk/Connection.ts"],"sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\nimport {\r\n    ServiceRecognizerBase,\r\n    SynthesisAdapterBase,\r\n} from \"../common.speech/Exports.js\";\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    IDetachable,\r\n    marshalPromiseToCallbacks,\r\n    ServiceEvent,\r\n} from \"../common/Exports.js\";\r\nimport {\r\n    ConnectionMessageImpl\r\n} from \"./ConnectionMessage.js\";\r\nimport { Contracts } from \"./Contracts.js\";\r\nimport {\r\n    ConnectionEventArgs,\r\n    ConnectionMessageEventArgs,\r\n    ConversationTranscriber,\r\n    Recognizer,\r\n    ServiceEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"./Exports.js\";\r\n\r\n/**\r\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\r\n * By default, a Recognizer autonomously manages connection to service when needed.\r\n * The Connection class provides additional methods for users to explicitly open or close a connection and\r\n * to subscribe to connection status changes.\r\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\r\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\r\n * in advance before starting recognition on the Recognizer associated with this Connection.\r\n * If the Recognizer needs to connect or disconnect to service, it will\r\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\r\n * status via Connected/Disconnected events.\r\n * Added in version 1.2.1.\r\n */\r\nexport class Connection {\r\n    private privInternalData: ServiceRecognizerBase | SynthesisAdapterBase;\r\n    private privEventListener: IDetachable;\r\n    private privServiceEventListener: IDetachable;\r\n\r\n    /**\r\n     * Gets the Connection instance from the specified recognizer.\r\n     * @param recognizer The recognizer associated with the connection.\r\n     * @return The Connection instance of the recognizer.\r\n     */\r\n    public static fromRecognizer(recognizer: Recognizer | ConversationTranscriber): Connection {\r\n        const recoBase = recognizer.internalData as ServiceRecognizerBase;\r\n        const ret: Connection = new Connection();\r\n\r\n        ret.privInternalData = recoBase;\r\n        ret.setupEvents();\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the Connection instance from the specified synthesizer.\r\n     * @param synthesizer The synthesizer associated with the connection.\r\n     * @return The Connection instance of the synthesizer.\r\n     */\r\n    public static fromSynthesizer(synthesizer: SpeechSynthesizer): Connection {\r\n        const synthBase: SynthesisAdapterBase = synthesizer.internalData as SynthesisAdapterBase;\r\n\r\n        const ret: Connection = new Connection();\r\n\r\n        ret.privInternalData = synthBase;\r\n        ret.setupEvents();\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Starts to set up connection to the service.\r\n     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\r\n     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\r\n     *\r\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\r\n     * be notified when the connection is established.\r\n     */\r\n    public openConnection(cb?: () => void, err?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Closes the connection the service.\r\n     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\r\n     *\r\n     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\r\n     */\r\n    public closeConnection(cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privInternalData instanceof SynthesisAdapterBase) {\r\n            throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\r\n        } else {\r\n            marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Appends a parameter in a message to service.\r\n     * Added in version 1.12.1.\r\n     * @param path The path of the network message.\r\n     * @param propertyName Name of the property\r\n     * @param propertyValue Value of the property. This is a json string.\r\n     */\r\n    public setMessageProperty(path: string, propertyName: string, propertyValue: string | object): void {\r\n        Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\r\n\r\n        if (this.privInternalData instanceof ServiceRecognizerBase) {\r\n            if (path.toLowerCase() !== \"speech.context\") {\r\n                throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\r\n            } else {\r\n                this.privInternalData.speechContext.setSection(propertyName, propertyValue);\r\n            }\r\n        } else if (this.privInternalData instanceof SynthesisAdapterBase) {\r\n            if (path.toLowerCase() !== \"synthesis.context\") {\r\n                throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\r\n            } else {\r\n                this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends a message to the speech service.\r\n     * Added in version 1.13.0.\r\n     * @param path The WebSocket path of the message\r\n     * @param payload The payload of the message. This is a json string or a ArrayBuffer.\r\n     * @param success A callback to indicate success.\r\n     * @param error A callback to indicate an error.\r\n     */\r\n    public sendMessageAsync(path: string, payload: string | ArrayBuffer, success?: () => void, error?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);\r\n    }\r\n\r\n    /**\r\n     * Any message from service that is not being processed by any other top level recognizers.\r\n     *\r\n     * Will be removed in 2.0.\r\n     */\r\n    public receivedServiceMessage: (args: ServiceEventArgs) => void;\r\n\r\n    /**\r\n     * Any message received from the Speech Service.\r\n     */\r\n    public messageReceived: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * Any message sent to the Speech Service.\r\n     */\r\n    public messageSent: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * The Connected event to indicate that the recognizer is connected to service.\r\n     */\r\n    public connected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * The Disconnected event to indicate that the recognizer is disconnected from service.\r\n     */\r\n    public disconnected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * Dispose of associated resources.\r\n     */\r\n    public close(): void {\r\n        /* eslint-disable no-empty */\r\n    }\r\n\r\n    private setupEvents(): void {\r\n        this.privEventListener = this.privInternalData.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\r\n                if (!!this.connected) {\r\n                    this.connected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                if (!!this.disconnected) {\r\n                    this.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\r\n                if (!!this.messageSent) {\r\n                    this.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageSentEvent).message)));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\r\n                if (!!this.messageReceived) {\r\n                    this.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageReceivedEvent).message)));\r\n                }\r\n            }\r\n        });\r\n\r\n        this.privServiceEventListener = this.privInternalData.serviceEvents.attach((e: ServiceEvent): void => {\r\n            if (!!this.receivedServiceMessage) {\r\n                this.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\r\n            }\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}