{"ast":null,"code":"import \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RiffPcmEncoder } from \"../common/Exports.js\";\nexport class PcmRecorder {\n  constructor(stopInputOnRelease) {\n    this.privStopInputOnRelease = stopInputOnRelease;\n  }\n  record(context, mediaStream, outputStream) {\n    const desiredSampleRate = 16000;\n    const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\n    const micInput = context.createMediaStreamSource(mediaStream);\n    const attachScriptProcessor = () => {\n      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n      const scriptNode = (() => {\n        let bufferSize = 0;\n        try {\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        } catch (error) {\n          // Webkit (<= version 31) requires a valid bufferSize.\n          bufferSize = 2048;\n          let audioSampleRate = context.sampleRate;\n          while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {\n            bufferSize <<= 1;\n            audioSampleRate >>= 1;\n          }\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        }\n      })();\n      scriptNode.onaudioprocess = event => {\n        const inputFrame = event.inputBuffer.getChannelData(0);\n        if (outputStream && !outputStream.isClosed) {\n          const waveFrame = waveStreamEncoder.encode(inputFrame);\n          if (!!waveFrame) {\n            outputStream.writeStreamChunk({\n              buffer: waveFrame,\n              isEnd: false,\n              timeReceived: Date.now()\n            });\n          }\n        }\n      };\n      micInput.connect(scriptNode);\n      scriptNode.connect(context.destination);\n      this.privMediaResources = {\n        scriptProcessorNode: scriptNode,\n        source: micInput,\n        stream: mediaStream\n      };\n    };\n    const connectWorkletToMicInput = context => {\n      const workletNode = new AudioWorkletNode(context, \"speech-processor\");\n      workletNode.port.onmessage = ev => {\n        const inputFrame = ev.data;\n        if (outputStream && !outputStream.isClosed) {\n          const waveFrame = waveStreamEncoder.encode(inputFrame);\n          if (!!waveFrame) {\n            outputStream.writeStreamChunk({\n              buffer: waveFrame,\n              isEnd: false,\n              timeReceived: Date.now()\n            });\n          }\n        }\n      };\n      micInput.connect(workletNode);\n      workletNode.connect(context.destination);\n      this.privMediaResources = {\n        scriptProcessorNode: workletNode,\n        source: micInput,\n        stream: mediaStream\n      };\n    };\n    // https://webaudio.github.io/web-audio-api/#audioworklet\n    // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\n    const skipAudioWorklet = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === \"ignore\";\n    if (!!context.audioWorklet && !skipAudioWorklet) {\n      /* eslint-disable-next-line */\n      this.privSpeechProcessorScript = new URL( /* webpackChunkName: 'script_processor_audioWorklet' */\"speech-processor.js\", import.meta.url).toString();\n      context.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {\n        connectWorkletToMicInput(context);\n      }).catch(() => {\n        const workletScript = `class SP extends AudioWorkletProcessor {\n                        constructor(options) {\n                        super(options);\n                        }\n                        process(inputs, outputs) {\n                        const input = inputs[0];\n                        const output = [];\n                        for (let channel = 0; channel < input.length; channel += 1) {\n                            output[channel] = input[channel];\n                        }\n                        this.port.postMessage(output[0]);\n                        return true;\n                        }\n                    }\n                    registerProcessor('speech-processor', SP);`;\n        const blob = new Blob([workletScript], {\n          type: \"application/javascript; charset=utf-8\"\n        });\n        this.privSpeechProcessorScript = URL.createObjectURL(blob);\n        context.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {\n          connectWorkletToMicInput(context);\n        }).catch(() => {\n          attachScriptProcessor();\n        });\n      });\n    } else {\n      try {\n        attachScriptProcessor();\n      } catch (err) {\n        throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err}`);\n      }\n    }\n  }\n  releaseMediaResources(context) {\n    if (this.privMediaResources) {\n      if (this.privMediaResources.scriptProcessorNode) {\n        this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\n        this.privMediaResources.scriptProcessorNode = null;\n      }\n      if (this.privMediaResources.source) {\n        this.privMediaResources.source.disconnect();\n        if (this.privStopInputOnRelease) {\n          this.privMediaResources.stream.getTracks().forEach(track => track.stop());\n        }\n        this.privMediaResources.source = null;\n      }\n    }\n  }\n  setWorkletUrl(url) {\n    this.privSpeechProcessorScript = url;\n  }\n}","map":{"version":3,"names":["RiffPcmEncoder","PcmRecorder","constructor","stopInputOnRelease","privStopInputOnRelease","record","context","mediaStream","outputStream","desiredSampleRate","waveStreamEncoder","sampleRate","micInput","createMediaStreamSource","attachScriptProcessor","scriptNode","bufferSize","createScriptProcessor","error","audioSampleRate","onaudioprocess","event","inputFrame","inputBuffer","getChannelData","isClosed","waveFrame","encode","writeStreamChunk","buffer","isEnd","timeReceived","Date","now","connect","destination","privMediaResources","scriptProcessorNode","source","stream","connectWorkletToMicInput","workletNode","AudioWorkletNode","port","onmessage","ev","data","skipAudioWorklet","privSpeechProcessorScript","toLowerCase","audioWorklet","URL","import","meta","url","toString","addModule","then","catch","workletScript","blob","Blob","type","createObjectURL","err","Error","releaseMediaResources","disconnect","getTracks","forEach","track","stop","setWorkletUrl"],"sources":["src/common.browser/PCMRecorder.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { RiffPcmEncoder, Stream } from \"../common/Exports.js\";\r\nimport { IRecorder } from \"./IRecorder.js\";\r\n\r\nexport class PcmRecorder implements IRecorder {\r\n    private privMediaResources: IMediaResources;\r\n    private privSpeechProcessorScript: string; // speech-processor.js Url\r\n    private privStopInputOnRelease: boolean;\r\n\r\n    public constructor(stopInputOnRelease: boolean) {\r\n        this.privStopInputOnRelease = stopInputOnRelease;\r\n    }\r\n\r\n    public record(context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void {\r\n        const desiredSampleRate = 16000;\r\n\r\n        const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\r\n\r\n        const micInput = context.createMediaStreamSource(mediaStream);\r\n\r\n        const attachScriptProcessor = (): void => {\r\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\n            const scriptNode = (() => {\r\n                let bufferSize = 0;\r\n                try {\r\n                    return context.createScriptProcessor(bufferSize, 1, 1);\r\n                } catch (error) {\r\n                    // Webkit (<= version 31) requires a valid bufferSize.\r\n                    bufferSize = 2048;\r\n                    let audioSampleRate = context.sampleRate;\r\n                    while (bufferSize < 16384 && audioSampleRate >= (2 * desiredSampleRate)) {\r\n                        bufferSize <<= 1;\r\n                        audioSampleRate >>= 1;\r\n                    }\r\n                    return context.createScriptProcessor(bufferSize, 1, 1);\r\n                }\r\n            })();\r\n            scriptNode.onaudioprocess = (event: AudioProcessingEvent): void => {\r\n                const inputFrame = event.inputBuffer.getChannelData(0);\r\n\r\n                if (outputStream && !outputStream.isClosed) {\r\n                    const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                    if (!!waveFrame) {\r\n                        outputStream.writeStreamChunk({\r\n                            buffer: waveFrame,\r\n                            isEnd: false,\r\n                            timeReceived: Date.now(),\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            micInput.connect(scriptNode);\r\n            scriptNode.connect(context.destination);\r\n            this.privMediaResources = {\r\n                scriptProcessorNode: scriptNode,\r\n                source: micInput,\r\n                stream: mediaStream,\r\n            };\r\n        };\r\n\r\n        const connectWorkletToMicInput = (context: AudioContext): void => {\r\n            const workletNode = new AudioWorkletNode(context, \"speech-processor\");\r\n            workletNode.port.onmessage = (ev: MessageEvent): void => {\r\n                const inputFrame: Float32Array = ev.data as Float32Array;\r\n\r\n                if (outputStream && !outputStream.isClosed) {\r\n                    const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                    if (!!waveFrame) {\r\n                        outputStream.writeStreamChunk({\r\n                            buffer: waveFrame,\r\n                            isEnd: false,\r\n                            timeReceived: Date.now(),\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            micInput.connect(workletNode);\r\n            workletNode.connect(context.destination);\r\n            this.privMediaResources = {\r\n                scriptProcessorNode: workletNode,\r\n                source: micInput,\r\n                stream: mediaStream,\r\n            };\r\n        };\r\n\r\n        // https://webaudio.github.io/web-audio-api/#audioworklet\r\n        // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\r\n        const skipAudioWorklet = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === \"ignore\";\r\n\r\n        if (!!context.audioWorklet && !skipAudioWorklet) {\r\n            /* eslint-disable-next-line */\r\n            this.privSpeechProcessorScript = new URL( /* webpackChunkName: 'script_processor_audioWorklet' */ \"speech-processor.js\", import.meta.url).toString(); \r\n\r\n            context.audioWorklet\r\n                .addModule(this.privSpeechProcessorScript)\r\n                .then((): void => {\r\n                    connectWorkletToMicInput(context);\r\n                })\r\n                .catch((): void => {\r\n                    const workletScript = `class SP extends AudioWorkletProcessor {\r\n                        constructor(options) {\r\n                        super(options);\r\n                        }\r\n                        process(inputs, outputs) {\r\n                        const input = inputs[0];\r\n                        const output = [];\r\n                        for (let channel = 0; channel < input.length; channel += 1) {\r\n                            output[channel] = input[channel];\r\n                        }\r\n                        this.port.postMessage(output[0]);\r\n                        return true;\r\n                        }\r\n                    }\r\n                    registerProcessor('speech-processor', SP);`;\r\n                    const blob = new Blob([workletScript], { type: \"application/javascript; charset=utf-8\" });\r\n                    this.privSpeechProcessorScript = URL.createObjectURL(blob);\r\n\r\n                    context.audioWorklet\r\n                        .addModule(this.privSpeechProcessorScript)\r\n                        .then((): void => {\r\n                            connectWorkletToMicInput(context);\r\n                        })\r\n                        .catch((): void => {\r\n                            attachScriptProcessor();\r\n                        });\r\n                });\r\n        } else {\r\n            try {\r\n                attachScriptProcessor();\r\n            } catch (err) {\r\n                throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err as string}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    public releaseMediaResources(context: AudioContext): void {\r\n        if (this.privMediaResources) {\r\n            if (this.privMediaResources.scriptProcessorNode) {\r\n                this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\r\n                this.privMediaResources.scriptProcessorNode = null;\r\n            }\r\n            if (this.privMediaResources.source) {\r\n                this.privMediaResources.source.disconnect();\r\n                if (this.privStopInputOnRelease) {\r\n                    this.privMediaResources.stream.getTracks().forEach((track: MediaStreamTrack): void => track.stop());\r\n                }\r\n                this.privMediaResources.source = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setWorkletUrl(url: string): void {\r\n        this.privSpeechProcessorScript = url;\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    source: MediaStreamAudioSourceNode;\r\n    scriptProcessorNode: ScriptProcessorNode | AudioWorkletNode;\r\n    stream: MediaStream;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}