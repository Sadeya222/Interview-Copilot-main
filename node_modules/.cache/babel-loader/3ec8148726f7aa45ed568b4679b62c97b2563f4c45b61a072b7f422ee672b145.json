{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error.js\";\nimport { List } from \"./List.js\";\nimport { Deferred } from \"./Promise.js\";\nvar SubscriberType;\n(function (SubscriberType) {\n  SubscriberType[SubscriberType[\"Dequeue\"] = 0] = \"Dequeue\";\n  SubscriberType[SubscriberType[\"Peek\"] = 1] = \"Peek\";\n})(SubscriberType || (SubscriberType = {}));\nexport class Queue {\n  constructor(list) {\n    this.privPromiseStore = new List();\n    this.privIsDrainInProgress = false;\n    this.privIsDisposing = false;\n    this.privDisposeReason = null;\n    this.privList = list ? list : new List();\n    this.privDetachables = [];\n    this.privSubscribers = new List();\n    this.privDetachables.push(this.privList.onAdded(() => this.drain()));\n  }\n  enqueue(item) {\n    this.throwIfDispose();\n    this.enqueueFromPromise(new Promise(resolve => resolve(item)));\n  }\n  enqueueFromPromise(promise) {\n    this.throwIfDispose();\n    promise.then(val => {\n      this.privList.add(val);\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n    }, () => {});\n  }\n  dequeue() {\n    this.throwIfDispose();\n    const deferredSubscriber = new Deferred();\n    if (this.privSubscribers) {\n      this.privSubscribers.add({\n        deferral: deferredSubscriber,\n        type: SubscriberType.Dequeue\n      });\n      this.drain();\n    }\n    return deferredSubscriber.promise;\n  }\n  peek() {\n    this.throwIfDispose();\n    const deferredSubscriber = new Deferred();\n    const subs = this.privSubscribers;\n    if (subs) {\n      this.privSubscribers.add({\n        deferral: deferredSubscriber,\n        type: SubscriberType.Peek\n      });\n      this.drain();\n    }\n    return deferredSubscriber.promise;\n  }\n  length() {\n    this.throwIfDispose();\n    return this.privList.length();\n  }\n  isDisposed() {\n    return this.privSubscribers == null;\n  }\n  drainAndDispose(pendingItemProcessor, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isDisposed() && !this.privIsDisposing) {\n        this.privDisposeReason = reason;\n        this.privIsDisposing = true;\n        const subs = this.privSubscribers;\n        if (subs) {\n          while (subs.length() > 0) {\n            const subscriber = subs.removeFirst();\n            // TODO: this needs work (Resolve(null) instead?).\n            subscriber.deferral.resolve(undefined);\n            // subscriber.deferral.reject(\"Disposed\");\n          }\n          // note: this block assumes cooperative multitasking, i.e.,\n          // between the if-statement and the assignment there are no\n          // thread switches.\n          // Reason is that between the initial const = this.; and this\n          // point there is the derral.resolve() operation that might have\n          // caused recursive calls to the Queue, especially, calling\n          // Dispose() on the queue alredy (which would reset the var\n          // here to null!).\n          // That should generally hold true for javascript...\n          if (this.privSubscribers === subs) {\n            this.privSubscribers = subs;\n          }\n        }\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n        if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\n          const promiseArray = [];\n          this.privPromiseStore.toArray().forEach(wrapper => {\n            promiseArray.push(wrapper);\n          });\n          return Promise.all(promiseArray).finally(() => {\n            this.privSubscribers = null;\n            this.privList.forEach(item => {\n              pendingItemProcessor(item);\n            });\n            this.privList = null;\n            return;\n          }).then();\n        } else {\n          this.privSubscribers = null;\n          this.privList = null;\n        }\n      }\n    });\n  }\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.drainAndDispose(null, reason);\n    });\n  }\n  drain() {\n    if (!this.privIsDrainInProgress && !this.privIsDisposing) {\n      this.privIsDrainInProgress = true;\n      const subs = this.privSubscribers;\n      const lists = this.privList;\n      if (subs && lists) {\n        while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\n          const subscriber = subs.removeFirst();\n          if (subscriber.type === SubscriberType.Peek) {\n            subscriber.deferral.resolve(lists.first());\n          } else {\n            const dequeuedItem = lists.removeFirst();\n            subscriber.deferral.resolve(dequeuedItem);\n          }\n        }\n        // note: this block assumes cooperative multitasking, i.e.,\n        // between the if-statement and the assignment there are no\n        // thread switches.\n        // Reason is that between the initial const = this.; and this\n        // point there is the derral.resolve() operation that might have\n        // caused recursive calls to the Queue, especially, calling\n        // Dispose() on the queue alredy (which would reset the var\n        // here to null!).\n        // That should generally hold true for javascript...\n        if (this.privSubscribers === subs) {\n          this.privSubscribers = subs;\n        }\n        // note: this block assumes cooperative multitasking, i.e.,\n        // between the if-statement and the assignment there are no\n        // thread switches.\n        // Reason is that between the initial const = this.; and this\n        // point there is the derral.resolve() operation that might have\n        // caused recursive calls to the Queue, especially, calling\n        // Dispose() on the queue alredy (which would reset the var\n        // here to null!).\n        // That should generally hold true for javascript...\n        if (this.privList === lists) {\n          this.privList = lists;\n        }\n      }\n      this.privIsDrainInProgress = false;\n    }\n  }\n  throwIfDispose() {\n    if (this.isDisposed()) {\n      if (this.privDisposeReason) {\n        throw new InvalidOperationError(this.privDisposeReason);\n      }\n      throw new ObjectDisposedError(\"Queue\");\n    } else if (this.privIsDisposing) {\n      throw new InvalidOperationError(\"Queue disposing\");\n    }\n  }\n}","map":{"version":3,"names":["InvalidOperationError","ObjectDisposedError","List","Deferred","SubscriberType","Queue","constructor","list","privPromiseStore","privIsDrainInProgress","privIsDisposing","privDisposeReason","privList","privDetachables","privSubscribers","push","onAdded","drain","enqueue","item","throwIfDispose","enqueueFromPromise","Promise","resolve","promise","then","val","add","dequeue","deferredSubscriber","deferral","type","Dequeue","peek","subs","Peek","length","isDisposed","drainAndDispose","pendingItemProcessor","reason","subscriber","removeFirst","undefined","detachable","detach","promiseArray","toArray","forEach","wrapper","all","finally","dispose","lists","first","dequeuedItem"],"sources":["src/common/Queue.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error.js\";\r\nimport { IDetachable } from \"./IDetachable.js\";\r\nimport { IDisposable } from \"./IDisposable.js\";\r\nimport { List } from \"./List.js\";\r\nimport {\r\n    Deferred,\r\n} from \"./Promise.js\";\r\nexport interface IQueue<TItem> extends IDisposable {\r\n    enqueue(item: TItem): void;\r\n    enqueueFromPromise(promise: Promise<TItem>): void;\r\n    dequeue(): Promise<TItem>;\r\n    peek(): Promise<TItem>;\r\n    length(): number;\r\n}\r\n\r\nenum SubscriberType {\r\n    Dequeue,\r\n    Peek,\r\n}\r\n\r\nexport class Queue<TItem> implements IQueue<TItem> {\r\n    private privPromiseStore: List<Promise<TItem>> = new List<Promise<TItem>>();\r\n    private privList: List<TItem>;\r\n    private privDetachables: IDetachable[];\r\n    private privSubscribers: List<{ type: SubscriberType; deferral: Deferred<TItem> }>;\r\n    private privIsDrainInProgress: boolean = false;\r\n    private privIsDisposing: boolean = false;\r\n    private privDisposeReason: string = null;\r\n\r\n    public constructor(list?: List<TItem>) {\r\n        this.privList = list ? list : new List<TItem>();\r\n        this.privDetachables = [];\r\n        this.privSubscribers = new List<{ type: SubscriberType; deferral: Deferred<TItem> }>();\r\n        this.privDetachables.push(this.privList.onAdded((): void => this.drain()));\r\n    }\r\n\r\n    public enqueue(item: TItem): void {\r\n        this.throwIfDispose();\r\n        this.enqueueFromPromise(new Promise<TItem>((resolve: (value: TItem) => void): void => resolve(item)));\r\n    }\r\n\r\n    public enqueueFromPromise(promise: Promise<TItem>): void {\r\n        this.throwIfDispose();\r\n        promise.then((val: TItem): void => {\r\n            this.privList.add(val);\r\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n        }, (): void => { });\r\n    }\r\n\r\n    public dequeue(): Promise<TItem> {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        if (this.privSubscribers) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public peek(): Promise<TItem> {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        const subs = this.privSubscribers;\r\n        if (subs) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public length(): number {\r\n        this.throwIfDispose();\r\n        return this.privList.length();\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privSubscribers == null;\r\n    }\r\n\r\n    public async drainAndDispose(pendingItemProcessor: (pendingItemInQueue: TItem) => void, reason?: string): Promise<void> {\r\n        if (!this.isDisposed() && !this.privIsDisposing) {\r\n            this.privDisposeReason = reason;\r\n            this.privIsDisposing = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            if (subs) {\r\n                while (subs.length() > 0) {\r\n                    const subscriber = subs.removeFirst();\r\n                    // TODO: this needs work (Resolve(null) instead?).\r\n                    subscriber.deferral.resolve(undefined);\r\n                    // subscriber.deferral.reject(\"Disposed\");\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n            }\r\n\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\r\n                const promiseArray: Promise<TItem>[] = [];\r\n\r\n                this.privPromiseStore.toArray().forEach((wrapper: Promise<TItem>): void => {\r\n                    promiseArray.push(wrapper);\r\n                });\r\n                return Promise.all(promiseArray).finally((): void => {\r\n                    this.privSubscribers = null;\r\n                    this.privList.forEach((item: TItem): void => {\r\n                        pendingItemProcessor(item);\r\n                    });\r\n                    this.privList = null;\r\n                    return;\r\n                }).then<void>();\r\n            } else {\r\n                this.privSubscribers = null;\r\n                this.privList = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        await this.drainAndDispose(null, reason);\r\n    }\r\n\r\n    private drain(): void {\r\n        if (!this.privIsDrainInProgress && !this.privIsDisposing) {\r\n            this.privIsDrainInProgress = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            const lists = this.privList;\r\n            if (subs && lists) {\r\n                while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\r\n                    const subscriber = subs.removeFirst();\r\n                    if (subscriber.type === SubscriberType.Peek) {\r\n                        subscriber.deferral.resolve(lists.first());\r\n                    } else {\r\n                        const dequeuedItem = lists.removeFirst();\r\n                        subscriber.deferral.resolve(dequeuedItem);\r\n                    }\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privList === lists) {\r\n                    this.privList = lists;\r\n                }\r\n            }\r\n\r\n            this.privIsDrainInProgress = false;\r\n        }\r\n    }\r\n\r\n    private throwIfDispose(): void {\r\n        if (this.isDisposed()) {\r\n            if (this.privDisposeReason) {\r\n                throw new InvalidOperationError(this.privDisposeReason);\r\n            }\r\n\r\n            throw new ObjectDisposedError(\"Queue\");\r\n        } else if (this.privIsDisposing) {\r\n            throw new InvalidOperationError(\"Queue disposing\");\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}