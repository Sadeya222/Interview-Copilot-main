{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ConnectionMessage, Deferred, MessageType, RawWebsocketMessage } from \"../common/Exports.js\";\nconst CRLF = \"\\r\\n\";\nexport class WebsocketMessageFormatter {\n  toConnectionMessage(message) {\n    const deferral = new Deferred();\n    try {\n      if (message.messageType === MessageType.Text) {\n        const textMessage = message.textContent;\n        let headers = {};\n        let body = null;\n        if (textMessage) {\n          const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\n          if (headerBodySplit && headerBodySplit.length > 0) {\n            headers = this.parseHeaders(headerBodySplit[0]);\n            if (headerBodySplit.length > 1) {\n              body = headerBodySplit[1];\n            }\n          }\n        }\n        deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\n      } else if (message.messageType === MessageType.Binary) {\n        const binaryMessage = message.binaryContent;\n        let headers = {};\n        let body = null;\n        if (!binaryMessage || binaryMessage.byteLength < 2) {\n          throw new Error(\"Invalid binary message format. Header length missing.\");\n        }\n        const dataView = new DataView(binaryMessage);\n        const headerLength = dataView.getInt16(0);\n        if (binaryMessage.byteLength < headerLength + 2) {\n          throw new Error(\"Invalid binary message format. Header content missing.\");\n        }\n        let headersString = \"\";\n        for (let i = 0; i < headerLength; i++) {\n          headersString += String.fromCharCode(dataView.getInt8(i + 2));\n        }\n        headers = this.parseHeaders(headersString);\n        if (binaryMessage.byteLength > headerLength + 2) {\n          body = binaryMessage.slice(2 + headerLength);\n        }\n        deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. Error: ${e}`);\n    }\n    return deferral.promise;\n  }\n  fromConnectionMessage(message) {\n    const deferral = new Deferred();\n    try {\n      if (message.messageType === MessageType.Text) {\n        const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : \"\"}`;\n        deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n      } else if (message.messageType === MessageType.Binary) {\n        const headersString = this.makeHeaders(message);\n        const content = message.binaryBody;\n        const headerBuffer = this.stringToArrayBuffer(headersString);\n        const headerInt8Array = new Int8Array(headerBuffer);\n        const headerLength = headerInt8Array.byteLength;\n        const payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));\n        payloadInt8Array[0] = headerLength >> 8 & 0xff;\n        payloadInt8Array[1] = headerLength & 0xff;\n        payloadInt8Array.set(headerInt8Array, 2);\n        if (content) {\n          const bodyInt8Array = new Int8Array(content);\n          payloadInt8Array.set(bodyInt8Array, 2 + headerLength);\n        }\n        const payload = payloadInt8Array.buffer;\n        deferral.resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. ${e}`);\n    }\n    return deferral.promise;\n  }\n  makeHeaders(message) {\n    let headersString = \"\";\n    if (message.headers) {\n      for (const header in message.headers) {\n        if (header) {\n          headersString += `${header}: ${message.headers[header]}${CRLF}`;\n        }\n      }\n    }\n    return headersString;\n  }\n  parseHeaders(headersString) {\n    const headers = {};\n    if (headersString) {\n      const headerMatches = headersString.match(/[^\\r\\n]+/g);\n      if (headers) {\n        for (const header of headerMatches) {\n          if (header) {\n            const separatorIndex = header.indexOf(\":\");\n            const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\n            const headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : \"\";\n            headers[headerName] = headerValue;\n          }\n        }\n      }\n    }\n    return headers;\n  }\n  stringToArrayBuffer(str) {\n    const buffer = new ArrayBuffer(str.length);\n    const view = new DataView(buffer);\n    for (let i = 0; i < str.length; i++) {\n      view.setUint8(i, str.charCodeAt(i));\n    }\n    return buffer;\n  }\n}","map":{"version":3,"names":["ConnectionMessage","Deferred","MessageType","RawWebsocketMessage","CRLF","WebsocketMessageFormatter","toConnectionMessage","message","deferral","messageType","Text","textMessage","textContent","headers","body","headerBodySplit","split","length","parseHeaders","resolve","id","Binary","binaryMessage","binaryContent","byteLength","Error","dataView","DataView","headerLength","getInt16","headersString","i","String","fromCharCode","getInt8","slice","e","reject","promise","fromConnectionMessage","payload","makeHeaders","textBody","content","binaryBody","headerBuffer","stringToArrayBuffer","headerInt8Array","Int8Array","payloadInt8Array","set","bodyInt8Array","buffer","header","headerMatches","match","separatorIndex","indexOf","headerName","substr","trim","toLowerCase","headerValue","str","ArrayBuffer","view","setUint8","charCodeAt"],"sources":["src/common.speech/WebsocketMessageFormatter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    Deferred,\r\n    IStringDictionary,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    RawWebsocketMessage,\r\n} from \"../common/Exports.js\";\r\n\r\nconst CRLF: string = \"\\r\\n\";\r\n\r\nexport class WebsocketMessageFormatter implements IWebsocketMessageFormatter {\r\n\r\n    public toConnectionMessage(message: RawWebsocketMessage): Promise<ConnectionMessage> {\r\n        const deferral = new Deferred<ConnectionMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const textMessage: string = message.textContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: string = null;\r\n\r\n                if (textMessage) {\r\n                    const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\r\n                    if (headerBodySplit && headerBodySplit.length > 0) {\r\n                        headers = this.parseHeaders(headerBodySplit[0]);\r\n                        if (headerBodySplit.length > 1) {\r\n                            body = headerBodySplit[1];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                const binaryMessage: ArrayBuffer = message.binaryContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: ArrayBuffer = null;\r\n\r\n                if (!binaryMessage || binaryMessage.byteLength < 2) {\r\n                    throw new Error(\"Invalid binary message format. Header length missing.\");\r\n                }\r\n\r\n                const dataView = new DataView(binaryMessage);\r\n                const headerLength = dataView.getInt16(0);\r\n\r\n                if (binaryMessage.byteLength < headerLength + 2) {\r\n                    throw new Error(\"Invalid binary message format. Header content missing.\");\r\n                }\r\n\r\n                let headersString = \"\";\r\n                for (let i = 0; i < headerLength; i++) {\r\n                    headersString += String.fromCharCode((dataView).getInt8(i + 2));\r\n                }\r\n\r\n                headers = this.parseHeaders(headersString);\r\n\r\n                if (binaryMessage.byteLength > headerLength + 2) {\r\n                    body = binaryMessage.slice(2 + headerLength);\r\n                }\r\n\r\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. Error: ${e as string}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n\r\n    public fromConnectionMessage(message: ConnectionMessage): Promise<RawWebsocketMessage> {\r\n        const deferral = new Deferred<RawWebsocketMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : \"\"}`;\r\n\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\r\n\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                const headersString = this.makeHeaders(message);\r\n                const content = message.binaryBody;\r\n\r\n                const headerBuffer = this.stringToArrayBuffer(headersString);\r\n                const headerInt8Array = new Int8Array(headerBuffer);\r\n                const headerLength = headerInt8Array.byteLength;\r\n\r\n                const payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));\r\n                payloadInt8Array[0] = ((headerLength >> 8) & 0xff);\r\n                payloadInt8Array[1] = headerLength & 0xff;\r\n                payloadInt8Array.set(headerInt8Array, 2);\r\n\r\n                if (content) {\r\n                    const bodyInt8Array = new Int8Array(content);\r\n                    payloadInt8Array.set(bodyInt8Array, 2 + headerLength);\r\n                }\r\n\r\n                const payload: ArrayBuffer = payloadInt8Array.buffer;\r\n\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. ${e as string}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n\r\n    private makeHeaders(message: ConnectionMessage): string {\r\n        let headersString: string = \"\";\r\n\r\n        if (message.headers) {\r\n            for (const header in message.headers) {\r\n                if (header) {\r\n                    headersString += `${header}: ${message.headers[header]}${CRLF}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return headersString;\r\n    }\r\n\r\n    private parseHeaders(headersString: string): IStringDictionary<string> {\r\n        const headers: IStringDictionary<string> = {};\r\n\r\n        if (headersString) {\r\n            const headerMatches = headersString.match(/[^\\r\\n]+/g);\r\n            if (headers) {\r\n                for (const header of headerMatches) {\r\n                    if (header) {\r\n                        const separatorIndex = header.indexOf(\":\");\r\n                        const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\r\n                        const headerValue =\r\n                            separatorIndex > 0 && header.length > (separatorIndex + 1) ?\r\n                                header.substr(separatorIndex + 1).trim() :\r\n                                \"\";\r\n\r\n                        headers[headerName] = headerValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return headers;\r\n    }\r\n\r\n    private stringToArrayBuffer(str: string): ArrayBuffer {\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new DataView(buffer);\r\n        for (let i = 0; i < str.length; i++) {\r\n            view.setUint8(i, str.charCodeAt(i));\r\n        }\r\n        return buffer;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}