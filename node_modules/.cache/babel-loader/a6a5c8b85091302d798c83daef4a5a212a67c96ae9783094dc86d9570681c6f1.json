{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { InvalidOperationError } from \"./Error.js\";\nimport { createNoDashGuid } from \"./Guid.js\";\nimport { Queue } from \"./Queue.js\";\nexport class Stream {\n  constructor(streamId) {\n    this.privIsWriteEnded = false;\n    this.privIsReadEnded = false;\n    this.privId = streamId ? streamId : createNoDashGuid();\n    this.privReaderQueue = new Queue();\n  }\n  get isClosed() {\n    return this.privIsWriteEnded;\n  }\n  get isReadEnded() {\n    return this.privIsReadEnded;\n  }\n  get id() {\n    return this.privId;\n  }\n  close() {\n    if (!this.privIsWriteEnded) {\n      this.writeStreamChunk({\n        buffer: null,\n        isEnd: true,\n        timeReceived: Date.now()\n      });\n      this.privIsWriteEnded = true;\n    }\n  }\n  writeStreamChunk(streamChunk) {\n    this.throwIfClosed();\n    if (!this.privReaderQueue.isDisposed()) {\n      try {\n        this.privReaderQueue.enqueue(streamChunk);\n      } catch (e) {\n        // Do nothing\n      }\n    }\n  }\n  read() {\n    if (this.privIsReadEnded) {\n      throw new InvalidOperationError(\"Stream read has already finished\");\n    }\n    return this.privReaderQueue.dequeue().then(streamChunk => __awaiter(this, void 0, void 0, function* () {\n      if (streamChunk === undefined || streamChunk.isEnd) {\n        yield this.privReaderQueue.dispose(\"End of stream reached\");\n      }\n      return streamChunk;\n    }));\n  }\n  readEnded() {\n    if (!this.privIsReadEnded) {\n      this.privIsReadEnded = true;\n      this.privReaderQueue = new Queue();\n    }\n  }\n  throwIfClosed() {\n    if (this.privIsWriteEnded) {\n      throw new InvalidOperationError(\"Stream closed\");\n    }\n  }\n}","map":{"version":3,"names":["InvalidOperationError","createNoDashGuid","Queue","Stream","constructor","streamId","privIsWriteEnded","privIsReadEnded","privId","privReaderQueue","isClosed","isReadEnded","id","close","writeStreamChunk","buffer","isEnd","timeReceived","Date","now","streamChunk","throwIfClosed","isDisposed","enqueue","e","read","dequeue","then","__awaiter","undefined","dispose","readEnded"],"sources":["src/common/Stream.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"./Error.js\";\r\nimport { createNoDashGuid } from \"./Guid.js\";\r\nimport { Queue } from \"./Queue.js\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    isEnd: boolean;\r\n    buffer: TBuffer;\r\n    timeReceived: number;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private privId: string;\r\n    private privIsWriteEnded: boolean = false;\r\n    private privIsReadEnded: boolean = false;\r\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.privId = streamId ? streamId : createNoDashGuid();\r\n        this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsWriteEnded;\r\n    }\r\n\r\n    public get isReadEnded(): boolean {\r\n        return this.privIsReadEnded;\r\n    }\r\n\r\n    public get id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public close(): void {\r\n        if (!this.privIsWriteEnded) {\r\n            this.writeStreamChunk({\r\n                buffer: null,\r\n                isEnd: true,\r\n                timeReceived: Date.now(),\r\n            });\r\n            this.privIsWriteEnded = true;\r\n        }\r\n    }\r\n\r\n    public writeStreamChunk(streamChunk: IStreamChunk<TBuffer>): void {\r\n        this.throwIfClosed();\r\n        if (!this.privReaderQueue.isDisposed()) {\r\n            try {\r\n                this.privReaderQueue.enqueue(streamChunk);\r\n            } catch (e) {\r\n                // Do nothing\r\n            }\r\n        }\r\n    }\r\n\r\n    public read(): Promise<IStreamChunk<TBuffer>> {\r\n        if (this.privIsReadEnded) {\r\n            throw new InvalidOperationError(\"Stream read has already finished\");\r\n        }\r\n\r\n        return this.privReaderQueue\r\n            .dequeue()\r\n            .then(async (streamChunk: IStreamChunk<TBuffer>): Promise<IStreamChunk<TBuffer>> => {\r\n                if (streamChunk === undefined || streamChunk.isEnd) {\r\n                    await this.privReaderQueue.dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n    public readEnded(): void {\r\n        if (!this.privIsReadEnded) {\r\n            this.privIsReadEnded = true;\r\n            this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        }\r\n    }\r\n\r\n    private throwIfClosed(): void {\r\n        if (this.privIsWriteEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAASA,qBAAqB,QAAQ,YAAY;AAClD,SAASC,gBAAgB,QAAQ,WAAW;AAC5C,SAASC,KAAK,QAAQ,YAAY;AAQlC,OAAM,MAAOC,MAAM;EAMfC,YAAmBC,QAAiB;IAJ5B,KAAAC,gBAAgB,GAAY,KAAK;IACjC,KAAAC,eAAe,GAAY,KAAK;IAIpC,IAAI,CAACC,MAAM,GAAGH,QAAQ,GAAGA,QAAQ,GAAGJ,gBAAgB,EAAE;IACtD,IAAI,CAACQ,eAAe,GAAG,IAAIP,KAAK,EAAyB;EAC7D;EAEA,IAAWQ,QAAQA,CAAA;IACf,OAAO,IAAI,CAACJ,gBAAgB;EAChC;EAEA,IAAWK,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACJ,eAAe;EAC/B;EAEA,IAAWK,EAAEA,CAAA;IACT,OAAO,IAAI,CAACJ,MAAM;EACtB;EAEOK,KAAKA,CAAA;IACR,IAAI,CAAC,IAAI,CAACP,gBAAgB,EAAE;MACxB,IAAI,CAACQ,gBAAgB,CAAC;QAClBC,MAAM,EAAE,IAAI;QACZC,KAAK,EAAE,IAAI;QACXC,YAAY,EAAEC,IAAI,CAACC,GAAG;OACzB,CAAC;MACF,IAAI,CAACb,gBAAgB,GAAG,IAAI;;EAEpC;EAEOQ,gBAAgBA,CAACM,WAAkC;IACtD,IAAI,CAACC,aAAa,EAAE;IACpB,IAAI,CAAC,IAAI,CAACZ,eAAe,CAACa,UAAU,EAAE,EAAE;MACpC,IAAI;QACA,IAAI,CAACb,eAAe,CAACc,OAAO,CAACH,WAAW,CAAC;OAC5C,CAAC,OAAOI,CAAC,EAAE;QACR;MAAA;;EAGZ;EAEOC,IAAIA,CAAA;IACP,IAAI,IAAI,CAAClB,eAAe,EAAE;MACtB,MAAM,IAAIP,qBAAqB,CAAC,kCAAkC,CAAC;;IAGvE,OAAO,IAAI,CAACS,eAAe,CACtBiB,OAAO,EAAE,CACTC,IAAI,CAAQP,WAAkC,IAAoCQ,SAAA;MAC/E,IAAIR,WAAW,KAAKS,SAAS,IAAIT,WAAW,CAACJ,KAAK,EAAE;QAChD,MAAM,IAAI,CAACP,eAAe,CAACqB,OAAO,CAAC,uBAAuB,CAAC;;MAG/D,OAAOV,WAAW;IACtB,CAAC,EAAC;EACV;EACOW,SAASA,CAAA;IACZ,IAAI,CAAC,IAAI,CAACxB,eAAe,EAAE;MACvB,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,IAAI,CAACE,eAAe,GAAG,IAAIP,KAAK,EAAyB;;EAEjE;EAEQmB,aAAaA,CAAA;IACjB,IAAI,IAAI,CAACf,gBAAgB,EAAE;MACvB,MAAM,IAAIN,qBAAqB,CAAC,eAAe,CAAC;;EAExD"},"metadata":{},"sourceType":"module","externalDependencies":[]}