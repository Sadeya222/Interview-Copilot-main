{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports.js\";\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream.js\";\nimport { PropertyCollection, PropertyId, ResultReason, SpeechSynthesisResult } from \"../sdk/Exports.js\";\nimport { MetadataType } from \"./ServiceMessages/SynthesisAudioMetadata.js\";\nimport { ConnectingToSynthesisServiceEvent, SynthesisStartedEvent, SynthesisTriggeredEvent } from \"./SynthesisEvents.js\";\nexport class SynthesisTurn {\n  constructor() {\n    this.privIsDisposed = false;\n    this.privIsSynthesizing = false;\n    this.privIsSynthesisEnded = false;\n    this.privBytesReceived = 0;\n    this.privInTurn = false;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n    this.privSentenceOffset = 0;\n    this.privNextSearchSentenceIndex = 0;\n    this.privRequestId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred();\n    // We're not in a turn, so resolve.\n    this.privTurnDeferral.resolve();\n  }\n  get requestId() {\n    return this.privRequestId;\n  }\n  get streamId() {\n    return this.privStreamId;\n  }\n  set streamId(value) {\n    this.privStreamId = value;\n  }\n  get audioOutputFormat() {\n    return this.privAudioOutputFormat;\n  }\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n  }\n  get turnCompletionPromise() {\n    return this.privTurnDeferral.promise;\n  }\n  get isSynthesisEnded() {\n    return this.privIsSynthesisEnded;\n  }\n  get isSynthesizing() {\n    return this.privIsSynthesizing;\n  }\n  get currentTextOffset() {\n    return this.privTextOffset;\n  }\n  get currentSentenceOffset() {\n    return this.privSentenceOffset;\n  }\n  // The number of bytes received for current turn\n  get bytesReceived() {\n    return this.privBytesReceived;\n  }\n  get audioDuration() {\n    return this.privAudioDuration;\n  }\n  get extraProperties() {\n    if (!!this.privWebRTCSDP) {\n      const properties = new PropertyCollection();\n      properties.setProperty(PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP);\n      return properties;\n    }\n    return undefined;\n  }\n  getAllReceivedAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privReceivedAudio) {\n        return Promise.resolve(this.privReceivedAudio);\n      }\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n      yield this.readAllAudioFromStream();\n      return Promise.resolve(this.privReceivedAudio);\n    });\n  }\n  getAllReceivedAudioWithHeader() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privReceivedAudioWithHeader) {\n        return this.privReceivedAudioWithHeader;\n      }\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n      if (this.audioOutputFormat.hasHeader) {\n        const audio = yield this.getAllReceivedAudio();\n        this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(audio);\n        return this.privReceivedAudioWithHeader;\n      } else {\n        return this.getAllReceivedAudio();\n      }\n    });\n  }\n  startNewSynthesis(requestId, rawText, isSSML, audioDestination) {\n    this.privIsSynthesisEnded = false;\n    this.privIsSynthesizing = true;\n    this.privRequestId = requestId;\n    this.privRawText = rawText;\n    this.privIsSSML = isSSML;\n    this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n    this.privAudioOutputStream.format = this.privAudioOutputFormat;\n    this.privReceivedAudio = null;\n    this.privReceivedAudioWithHeader = null;\n    this.privBytesReceived = 0;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n    this.privSentenceOffset = 0;\n    this.privNextSearchSentenceIndex = 0;\n    this.privPartialVisemeAnimation = \"\";\n    this.privWebRTCSDP = \"\";\n    if (audioDestination !== undefined) {\n      this.privTurnAudioDestination = audioDestination;\n      this.privTurnAudioDestination.format = this.privAudioOutputFormat;\n    }\n    this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\n  }\n  onPreConnectionStart(authFetchEventId) {\n    this.privAuthFetchEventId = authFetchEventId;\n    this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\n  }\n  onAuthCompleted(isError) {\n    if (isError) {\n      this.onComplete();\n    }\n  }\n  onConnectionEstablishCompleted(statusCode) {\n    if (statusCode === 200) {\n      this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\n      this.privBytesReceived = 0;\n      return;\n    } else if (statusCode === 403) {\n      this.onComplete();\n    }\n  }\n  onServiceResponseMessage(responseJson) {\n    const response = JSON.parse(responseJson);\n    this.streamId = response.audio.streamId;\n  }\n  onServiceTurnEndResponse() {\n    this.privInTurn = false;\n    this.privTurnDeferral.resolve();\n    this.onComplete();\n  }\n  onServiceTurnStartResponse(responseJson) {\n    if (!!this.privTurnDeferral && !!this.privInTurn) {\n      // What? How are we starting a turn with another not done?\n      this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n      // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      this.privTurnDeferral.promise.then().catch(() => {});\n    }\n    this.privInTurn = true;\n    this.privTurnDeferral = new Deferred();\n    const response = JSON.parse(responseJson);\n    if (!!response.webrtc) {\n      this.privWebRTCSDP = response.webrtc.connectionString;\n    }\n  }\n  onAudioChunkReceived(data) {\n    if (this.isSynthesizing) {\n      this.privAudioOutputStream.write(data);\n      this.privBytesReceived += data.byteLength;\n      if (this.privTurnAudioDestination !== undefined) {\n        this.privTurnAudioDestination.write(data);\n      }\n    }\n  }\n  onTextBoundaryEvent(metadata) {\n    this.updateTextOffset(metadata.Data.text.Text, metadata.Type);\n  }\n  onVisemeMetadataReceived(metadata) {\n    if (metadata.Data.AnimationChunk !== undefined) {\n      this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\n    }\n  }\n  onSessionEnd(metadata) {\n    this.privAudioDuration = metadata.Data.Offset;\n  }\n  constructSynthesisResult() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const audioBuffer = yield this.getAllReceivedAudioWithHeader();\n      return new SpeechSynthesisResult(this.requestId, ResultReason.SynthesizingAudioCompleted, audioBuffer, undefined, this.extraProperties, this.audioDuration);\n    });\n  }\n  dispose() {\n    if (!this.privIsDisposed) {\n      // we should have completed by now. If we did not its an unknown error.\n      this.privIsDisposed = true;\n    }\n  }\n  onStopSynthesizing() {\n    this.onComplete();\n  }\n  /**\n   * Gets the viseme animation string (merged from animation chunk), and clears the internal\n   * partial animation.\n   */\n  getAndClearVisemeAnimation() {\n    const animation = this.privPartialVisemeAnimation;\n    this.privPartialVisemeAnimation = \"\";\n    return animation;\n  }\n  onEvent(event) {\n    Events.instance.onEvent(event);\n  }\n  /**\n   * Check if the text is an XML(SSML) tag\n   * @param text\n   * @private\n   */\n  static isXmlTag(text) {\n    return text.length >= 2 && text[0] === \"<\" && text[text.length - 1] === \">\";\n  }\n  updateTextOffset(text, type) {\n    if (type === MetadataType.WordBoundary) {\n      this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\n      if (this.privTextOffset >= 0) {\n        this.privNextSearchTextIndex = this.privTextOffset + text.length;\n        if (this.privIsSSML) {\n          if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) {\n            this.updateTextOffset(text, type);\n          }\n        }\n      }\n    } else {\n      this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);\n      if (this.privSentenceOffset >= 0) {\n        this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;\n        if (this.privIsSSML) {\n          if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) {\n            this.updateTextOffset(text, type);\n          }\n        }\n      }\n    }\n  }\n  onComplete() {\n    if (this.privIsSynthesizing) {\n      this.privIsSynthesizing = false;\n      this.privIsSynthesisEnded = true;\n      this.privAudioOutputStream.close();\n      this.privInTurn = false;\n      if (this.privTurnAudioDestination !== undefined) {\n        this.privTurnAudioDestination.close();\n        this.privTurnAudioDestination = undefined;\n      }\n    }\n  }\n  readAllAudioFromStream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privIsSynthesisEnded) {\n        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\n        try {\n          yield this.privAudioOutputStream.read(this.privReceivedAudio);\n        } catch (e) {\n          this.privReceivedAudio = new ArrayBuffer(0);\n        }\n      }\n    });\n  }\n  /**\n   * Check if current idx is in XML(SSML) tag\n   * @param idx\n   * @private\n   */\n  withinXmlTag(idx) {\n    return this.privRawText.indexOf(\"<\", idx + 1) > this.privRawText.indexOf(\">\", idx + 1);\n  }\n}","map":{"version":3,"names":["createNoDashGuid","Deferred","Events","PullAudioOutputStreamImpl","PropertyCollection","PropertyId","ResultReason","SpeechSynthesisResult","MetadataType","ConnectingToSynthesisServiceEvent","SynthesisStartedEvent","SynthesisTriggeredEvent","SynthesisTurn","constructor","privIsDisposed","privIsSynthesizing","privIsSynthesisEnded","privBytesReceived","privInTurn","privTextOffset","privNextSearchTextIndex","privSentenceOffset","privNextSearchSentenceIndex","privRequestId","privTurnDeferral","resolve","requestId","streamId","privStreamId","value","audioOutputFormat","privAudioOutputFormat","format","turnCompletionPromise","promise","isSynthesisEnded","isSynthesizing","currentTextOffset","currentSentenceOffset","bytesReceived","audioDuration","privAudioDuration","extraProperties","privWebRTCSDP","properties","setProperty","TalkingAvatarService_WebRTC_SDP","undefined","getAllReceivedAudio","privReceivedAudio","Promise","readAllAudioFromStream","getAllReceivedAudioWithHeader","privReceivedAudioWithHeader","hasHeader","audio","addHeader","startNewSynthesis","rawText","isSSML","audioDestination","privRawText","privIsSSML","privAudioOutputStream","privPartialVisemeAnimation","privTurnAudioDestination","onEvent","id","onPreConnectionStart","authFetchEventId","privAuthFetchEventId","onAuthCompleted","isError","onComplete","onConnectionEstablishCompleted","statusCode","onServiceResponseMessage","responseJson","response","JSON","parse","onServiceTurnEndResponse","onServiceTurnStartResponse","reject","then","catch","webrtc","connectionString","onAudioChunkReceived","data","write","byteLength","onTextBoundaryEvent","metadata","updateTextOffset","Data","text","Text","Type","onVisemeMetadataReceived","AnimationChunk","onSessionEnd","Offset","constructSynthesisResult","audioBuffer","SynthesizingAudioCompleted","dispose","onStopSynthesizing","getAndClearVisemeAnimation","animation","event","instance","isXmlTag","length","type","WordBoundary","indexOf","withinXmlTag","close","ArrayBuffer","read","e","idx"],"sources":["src/common.speech/SynthesisTurn.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IAudioDestination\r\n} from \"../common/Exports.js\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat.js\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream.js\";\r\nimport {\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechSynthesisResult,\r\n} from \"../sdk/Exports.js\";\r\nimport { ISynthesisMetadata, MetadataType } from \"./ServiceMessages/SynthesisAudioMetadata.js\";\r\nimport {\r\n    ConnectingToSynthesisServiceEvent,\r\n    SpeechSynthesisEvent,\r\n    SynthesisStartedEvent,\r\n    SynthesisTriggeredEvent,\r\n} from \"./SynthesisEvents.js\";\r\n\r\nexport interface ISynthesisResponseContext {\r\n    serviceTag: string;\r\n}\r\n\r\nexport interface ISynthesisResponseAudio {\r\n    type: string;\r\n    streamId: string;\r\n}\r\n\r\nexport interface ISynthesisResponse {\r\n    context: ISynthesisResponseContext;\r\n    audio: ISynthesisResponseAudio;\r\n    webrtc: {\r\n        connectionString: string;\r\n    };\r\n}\r\n\r\nexport class SynthesisTurn {\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public set streamId(value: string) {\r\n        this.privStreamId = value;\r\n    }\r\n\r\n    public get audioOutputFormat(): AudioOutputFormatImpl {\r\n        return this.privAudioOutputFormat;\r\n    }\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSynthesisEnded(): boolean {\r\n        return this.privIsSynthesisEnded;\r\n    }\r\n\r\n    public get isSynthesizing(): boolean {\r\n        return this.privIsSynthesizing;\r\n    }\r\n\r\n    public get currentTextOffset(): number {\r\n        return this.privTextOffset;\r\n    }\r\n\r\n    public get currentSentenceOffset(): number {\r\n        return this.privSentenceOffset;\r\n    }\r\n\r\n    // The number of bytes received for current turn\r\n    public get bytesReceived(): number {\r\n        return this.privBytesReceived;\r\n    }\r\n\r\n    public get audioDuration(): number {\r\n        return this.privAudioDuration;\r\n    }\r\n\r\n    public get extraProperties(): PropertyCollection {\r\n        if (!!this.privWebRTCSDP) {\r\n            const properties = new PropertyCollection();\r\n            properties.setProperty(PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP);\r\n            return properties;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    private privIsDisposed: boolean = false;\r\n    private privAuthFetchEventId: string;\r\n    private privIsSynthesizing: boolean = false;\r\n    private privIsSynthesisEnded: boolean = false;\r\n    private privBytesReceived: number = 0;\r\n    private privRequestId: string;\r\n    private privStreamId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privReceivedAudio: ArrayBuffer;\r\n    private privReceivedAudioWithHeader: ArrayBuffer;\r\n    private privTextOffset: number = 0;\r\n    private privNextSearchTextIndex: number = 0;\r\n    private privSentenceOffset: number = 0;\r\n    private privNextSearchSentenceIndex: number = 0;\r\n    private privPartialVisemeAnimation: string;\r\n    private privRawText: string;\r\n    private privIsSSML: boolean;\r\n    private privTurnAudioDestination: IAudioDestination;\r\n    private privAudioDuration: number;\r\n    private privWebRTCSDP: string;\r\n\r\n    public constructor() {\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public async getAllReceivedAudio(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudio) {\r\n            return Promise.resolve(this.privReceivedAudio);\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        await this.readAllAudioFromStream();\r\n        return Promise.resolve(this.privReceivedAudio);\r\n    }\r\n\r\n    public async getAllReceivedAudioWithHeader(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudioWithHeader) {\r\n            return this.privReceivedAudioWithHeader;\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        if (this.audioOutputFormat.hasHeader) {\r\n            const audio: ArrayBuffer = await this.getAllReceivedAudio();\r\n            this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(audio);\r\n            return this.privReceivedAudioWithHeader;\r\n        } else {\r\n            return this.getAllReceivedAudio();\r\n        }\r\n    }\r\n\r\n    public startNewSynthesis(requestId: string, rawText: string, isSSML: boolean, audioDestination?: IAudioDestination): void {\r\n        this.privIsSynthesisEnded = false;\r\n        this.privIsSynthesizing = true;\r\n        this.privRequestId = requestId;\r\n        this.privRawText = rawText;\r\n        this.privIsSSML = isSSML;\r\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\r\n        this.privReceivedAudio = null;\r\n        this.privReceivedAudioWithHeader = null;\r\n        this.privBytesReceived = 0;\r\n        this.privTextOffset = 0;\r\n        this.privNextSearchTextIndex = 0;\r\n        this.privSentenceOffset = 0;\r\n        this.privNextSearchSentenceIndex = 0;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        this.privWebRTCSDP = \"\";\r\n        if (audioDestination !== undefined) {\r\n            this.privTurnAudioDestination = audioDestination;\r\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\r\n        }\r\n        this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\r\n    }\r\n\r\n    public onPreConnectionStart(authFetchEventId: string): void {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\r\n    }\r\n\r\n    public onAuthCompleted(isError: boolean): void {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted(statusCode: number): void {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\r\n            this.privBytesReceived = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceResponseMessage(responseJson: string): void {\r\n        const response: ISynthesisResponse = JSON.parse(responseJson) as ISynthesisResponse;\r\n        this.streamId = response.audio.streamId;\r\n    }\r\n\r\n    public onServiceTurnEndResponse(): void {\r\n        this.privInTurn = false;\r\n        this.privTurnDeferral.resolve();\r\n        this.onComplete();\r\n    }\r\n\r\n    public onServiceTurnStartResponse(responseJson: string): void {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n            this.privTurnDeferral.promise.then().catch((): void => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n        const response: ISynthesisResponse = JSON.parse(responseJson) as ISynthesisResponse;\r\n        if (!!response.webrtc) {\r\n            this.privWebRTCSDP = response.webrtc.connectionString;\r\n        }\r\n    }\r\n\r\n    public onAudioChunkReceived(data: ArrayBuffer): void {\r\n        if (this.isSynthesizing) {\r\n            this.privAudioOutputStream.write(data);\r\n            this.privBytesReceived += data.byteLength;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.write(data);\r\n            }\r\n        }\r\n    }\r\n\r\n    public onTextBoundaryEvent(metadata: ISynthesisMetadata): void {\r\n        this.updateTextOffset(metadata.Data.text.Text, metadata.Type);\r\n    }\r\n\r\n    public onVisemeMetadataReceived(metadata: ISynthesisMetadata): void {\r\n        if (metadata.Data.AnimationChunk !== undefined) {\r\n            this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\r\n        }\r\n    }\r\n\r\n    public onSessionEnd(metadata: ISynthesisMetadata): void {\r\n        this.privAudioDuration = metadata.Data.Offset;\r\n    }\r\n\r\n    public async constructSynthesisResult(): Promise<SpeechSynthesisResult> {\r\n        const audioBuffer: ArrayBuffer = await this.getAllReceivedAudioWithHeader();\r\n        return new SpeechSynthesisResult(\r\n            this.requestId,\r\n            ResultReason.SynthesizingAudioCompleted,\r\n            audioBuffer,\r\n            undefined,\r\n            this.extraProperties,\r\n            this.audioDuration\r\n        );\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n        }\r\n    }\r\n\r\n    public onStopSynthesizing(): void {\r\n        this.onComplete();\r\n    }\r\n\r\n    /**\r\n     * Gets the viseme animation string (merged from animation chunk), and clears the internal\r\n     * partial animation.\r\n     */\r\n    public getAndClearVisemeAnimation(): string {\r\n        const animation: string = this.privPartialVisemeAnimation;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        return animation;\r\n    }\r\n\r\n    protected onEvent(event: SpeechSynthesisEvent): void {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Check if the text is an XML(SSML) tag\r\n     * @param text\r\n     * @private\r\n     */\r\n    private static isXmlTag(text: string): boolean {\r\n        return text.length >= 2 && text[0] === \"<\" && text[text.length - 1] === \">\";\r\n    }\r\n\r\n    private updateTextOffset(text: string, type: MetadataType): void {\r\n        if (type === MetadataType.WordBoundary) {\r\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\r\n            if (this.privTextOffset >= 0) {\r\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\r\n                if (this.privIsSSML) {\r\n                    if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) {\r\n                        this.updateTextOffset(text, type);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);\r\n            if (this.privSentenceOffset >= 0) {\r\n                this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;\r\n                if (this.privIsSSML) {\r\n                    if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) {\r\n                        this.updateTextOffset(text, type);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete(): void {\r\n        if (this.privIsSynthesizing) {\r\n            this.privIsSynthesizing = false;\r\n            this.privIsSynthesisEnded = true;\r\n            this.privAudioOutputStream.close();\r\n            this.privInTurn = false;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.close();\r\n                this.privTurnAudioDestination = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    private async readAllAudioFromStream(): Promise<void> {\r\n        if (this.privIsSynthesisEnded) {\r\n            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\r\n            try {\r\n                await this.privAudioOutputStream.read(this.privReceivedAudio);\r\n            } catch (e) {\r\n                this.privReceivedAudio = new ArrayBuffer(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if current idx is in XML(SSML) tag\r\n     * @param idx\r\n     * @private\r\n     */\r\n    private withinXmlTag(idx: number): boolean {\r\n        return this.privRawText.indexOf(\"<\", idx + 1) > this.privRawText.indexOf(\">\", idx + 1);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}