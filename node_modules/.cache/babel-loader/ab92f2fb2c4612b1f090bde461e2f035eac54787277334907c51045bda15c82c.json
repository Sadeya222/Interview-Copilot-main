{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ConnectionState, createNoDashGuid, Deferred, MessageType } from \"../../common/Exports.js\";\nimport { CancellationErrorCode, CancellationReason, ConversationExpirationEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationResult, ResultReason, Translations } from \"../../sdk/Exports.js\";\nimport { CognitiveTokenAuthentication, ServiceRecognizerBase } from \"../Exports.js\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage.js\";\nimport { ConversationRequestSession } from \"./ConversationRequestSession.js\";\nimport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs.js\";\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes } from \"./ConversationTranslatorInterfaces.js\";\nimport { CommandResponsePayload, ParticipantPayloadResponse, ParticipantsListPayloadResponse, SpeechResponsePayload, TextResponsePayload } from \"./ServiceMessages/Exports.js\";\n/**\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n    this.privConnectionConfigPromise = undefined;\n    this.privLastPartialUtteranceId = \"\";\n    this.privConversationServiceConnector = conversationServiceConnector;\n    this.privConversationAuthentication = authentication;\n    this.receiveMessageOverride = () => this.receiveConversationMessageOverride();\n    this.recognizeOverride = () => this.noOp();\n    this.postConnectImplOverride = connection => this.conversationConnectImpl(connection);\n    this.configConnectionOverride = () => this.configConnection();\n    this.disconnectOverride = () => this.privDisconnect();\n    this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\n    this.privConversationConnectionFactory = connectionFactory;\n    this.privConversationIsDisposed = false;\n  }\n  isDisposed() {\n    return super.isDisposed() || this.privConversationIsDisposed;\n  }\n  dispose(reason) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConversationIsDisposed = true;\n      if (this.privConnectionConfigPromise !== undefined) {\n        const connection = yield this.privConnectionConfigPromise;\n        yield connection.dispose(reason);\n      }\n      yield _super.dispose.call(this, reason);\n    });\n  }\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      return connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n  sendMessageAsync(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      yield connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n  privDisconnect() {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    return Promise.resolve();\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  processTypeSpecificMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return true;\n    });\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    const cancelEvent = new ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {\n      // continue on error\n    }\n  }\n  /**\n   * Establishes a websocket connection to the end point.\n   */\n  conversationConnectImpl(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConnectionLoop = this.startMessageLoop();\n      return connection;\n    });\n  }\n  /**\n   * Process incoming websocket messages\n   */\n  receiveConversationMessageOverride() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed() || this.terminateMessageLoop) {\n        return Promise.resolve();\n      }\n      // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n      const communicationCustodian = new Deferred();\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n        if (this.isDisposed() || this.terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve();\n          return Promise.resolve();\n        }\n        if (!message) {\n          return this.receiveConversationMessageOverride();\n        }\n        const sessionId = this.privConversationRequestSession.sessionId;\n        const conversationMessageType = message.conversationMessageType.toLowerCase();\n        let sendFinal = false;\n        try {\n          switch (conversationMessageType) {\n            case \"info\":\n            case \"participant_command\":\n            case \"command\":\n              const commandPayload = CommandResponsePayload.fromJSON(message.textBody);\n              switch (commandPayload.command.toLowerCase()) {\n                /**\n                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                 * The consuming client must wait for this message to arrive\n                 * before starting to send their own data.\n                 */\n                case \"participantlist\":\n                  const participantsPayload = ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                  const participantsResult = participantsPayload.participants.map(p => {\n                    const participant = {\n                      avatar: p.avatar,\n                      displayName: p.nickname,\n                      id: p.participantId,\n                      isHost: p.ishost,\n                      isMuted: p.ismuted,\n                      isUsingTts: p.usetts,\n                      preferredLanguage: p.locale\n                    };\n                    return participant;\n                  });\n                  if (!!this.privConversationServiceConnector.participantsListReceived) {\n                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                 * This is sent at the start of the Conversation\n                 */\n                case \"settranslatetolanguages\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                 * If sent by the participant the setting will effect only their own profanity level.\n                 * If sent by the host, the setting will effect all participants including the host.\n                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                 */\n                case \"setprofanityfiltering\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetMute' is sent if the participant has been muted by the host.\n                 * Check the 'participantId' to determine if the current user has been muted.\n                 */\n                case \"setmute\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                 */\n                case \"setmuteall\":\n                  if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new MuteAllEventArgs(commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                 */\n                case \"roomexpirationwarning\":\n                  if (!!this.privConversationServiceConnector.conversationExpiration) {\n                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                 */\n                case \"setusetts\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                 */\n                case \"setlockstate\":\n                  if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new LockRoomEventArgs(commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'ChangeNickname' is received if a user changes their display name.\n                 * Any cached particpiants list should be updated to reflect the display name.\n                 */\n                case \"changenickname\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.changeNickname, commandPayload.value, sessionId));\n                  }\n                  break;\n                /**\n                 * 'JoinSession' is sent when a user joins the Conversation.\n                 */\n                case \"joinsession\":\n                  const joinParticipantPayload = ParticipantPayloadResponse.fromJSON(message.textBody);\n                  const joiningParticipant = {\n                    avatar: joinParticipantPayload.avatar,\n                    displayName: joinParticipantPayload.nickname,\n                    id: joinParticipantPayload.participantId,\n                    isHost: joinParticipantPayload.ishost,\n                    isMuted: joinParticipantPayload.ismuted,\n                    isUsingTts: joinParticipantPayload.usetts,\n                    preferredLanguage: joinParticipantPayload.locale\n                  };\n                  if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(joiningParticipant, sessionId));\n                  }\n                  break;\n                /**\n                 * 'LeaveSession' is sent when a user leaves the Conversation'.\n                 */\n                case \"leavesession\":\n                  const leavingParticipant = {\n                    id: commandPayload.participantId\n                  };\n                  if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(leavingParticipant, sessionId));\n                  }\n                  break;\n                /**\n                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                 * Check the 'ParticipantId' to check whether the message is for the current user.\n                 */\n                case \"disconnectsession\":\n                  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                  const disconnectParticipant = {\n                    id: commandPayload.participantId\n                  };\n                  break;\n                case \"token\":\n                  const token = new CognitiveTokenAuthentication(() => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  }, () => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  });\n                  this.authentication = token;\n                  this.privConversationServiceConnector.onToken(token);\n                  break;\n                /**\n                 * Message not recognized.\n                 */\n                default:\n                  break;\n              }\n              break;\n            /**\n             * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n             */\n            case \"partial\":\n            /**\n             * 'final' (or 'phrase') represents a finalized speech message.\n             */\n            case \"final\":\n              const speechPayload = SpeechResponsePayload.fromJSON(message.textBody);\n              const conversationResultReason = conversationMessageType === \"final\" ? ResultReason.TranslatedParticipantSpeech : ResultReason.TranslatingParticipantSpeech;\n              const speechResult = new ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, speechPayload.id, conversationResultReason, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n              if (speechPayload.isFinal) {\n                // check the length, sometimes empty finals are returned\n                if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                  sendFinal = true;\n                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                  // send final as normal. We had a non-empty partial for this same utterance\n                  // so sending the empty final is important\n                  sendFinal = true;\n                } else {\n                  // suppress unneeded final\n                }\n                if (sendFinal) {\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                  }\n                }\n              } else if (speechResult.text !== undefined) {\n                this.privLastPartialUtteranceId = speechPayload.id;\n                if (!!this.privConversationServiceConnector.translationReceived) {\n                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                }\n              }\n              break;\n            /**\n             * \"translated_message\" is a text message or instant message (IM).\n             */\n            case \"translated_message\":\n              const textPayload = TextResponsePayload.fromJSON(message.textBody);\n              // TODO: (Native parity) a result reason should be set based whether the participantId is ours or not\n              const textResult = new ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n              if (!!this.privConversationServiceConnector.translationReceived) {\n                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n              }\n              break;\n            default:\n              // ignore any unsupported message types\n              break;\n          }\n        } catch (e) {\n          // continue\n        }\n        return this.receiveConversationMessageOverride();\n      } catch (e) {\n        this.terminateMessageLoop = true;\n      }\n      return communicationCustodian.promise;\n    });\n  }\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed()) {\n        return Promise.resolve();\n      }\n      this.terminateMessageLoop = false;\n      const messageRetrievalPromise = this.receiveConversationMessageOverride();\n      try {\n        const r = yield messageRetrievalPromise;\n        return r;\n      } catch (error) {\n        this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n        return null;\n      }\n    });\n  }\n  // Takes an established websocket connection to the endpoint\n  configConnection() {\n    if (this.isDisposed()) {\n      return Promise.resolve(undefined);\n    }\n    if (this.privConnectionConfigPromise !== undefined) {\n      return this.privConnectionConfigPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionConfigPromise = undefined;\n          return this.configConnection();\n        }\n        return this.privConnectionConfigPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionConfigPromise = undefined;\n        return this.configConnection();\n      });\n    }\n    if (this.terminateMessageLoop) {\n      return Promise.resolve(undefined);\n    }\n    this.privConnectionConfigPromise = this.connectImpl().then(connection => connection);\n    return this.privConnectionConfigPromise;\n  }\n  getTranslations(serviceResultTranslations) {\n    let translations;\n    if (undefined !== serviceResultTranslations) {\n      translations = new Translations();\n      for (const translation of serviceResultTranslations) {\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n    return translations;\n  }\n}","map":{"version":3,"names":["ConnectionState","createNoDashGuid","Deferred","MessageType","CancellationErrorCode","CancellationReason","ConversationExpirationEventArgs","ConversationTranslationCanceledEventArgs","ConversationTranslationResult","ResultReason","Translations","CognitiveTokenAuthentication","ServiceRecognizerBase","ConversationConnectionMessage","ConversationRequestSession","ConversationReceivedTranslationEventArgs","LockRoomEventArgs","MuteAllEventArgs","ParticipantAttributeEventArgs","ParticipantEventArgs","ParticipantsListEventArgs","ConversationTranslatorCommandTypes","ConversationTranslatorMessageTypes","CommandResponsePayload","ParticipantPayloadResponse","ParticipantsListPayloadResponse","SpeechResponsePayload","TextResponsePayload","ConversationServiceAdapter","constructor","authentication","connectionFactory","audioSource","recognizerConfig","conversationServiceConnector","privConnectionConfigPromise","undefined","privLastPartialUtteranceId","privConversationServiceConnector","privConversationAuthentication","receiveMessageOverride","receiveConversationMessageOverride","recognizeOverride","noOp","postConnectImplOverride","connection","conversationConnectImpl","configConnectionOverride","configConnection","disconnectOverride","privDisconnect","privConversationRequestSession","privConversationConnectionFactory","privConversationIsDisposed","isDisposed","dispose","reason","_super","call","sendMessage","message","fetchConnection","send","Text","sendMessageAsync","terminateMessageLoop","cancelRecognition","sessionId","requestId","Error","NoError","Promise","resolve","processTypeSpecificMessages","cancellationReason","errorCode","error","cancelEvent","canceled","_a","privConnectionLoop","startMessageLoop","communicationCustodian","read","conversationMessageType","toLowerCase","sendFinal","commandPayload","fromJSON","textBody","command","participantsPayload","participantsResult","participants","map","p","participant","avatar","displayName","nickname","id","participantId","isHost","ishost","isMuted","ismuted","isUsingTts","usetts","preferredLanguage","locale","participantsListReceived","roomid","token","translateTo","profanityFilter","roomProfanityFilter","roomLocked","muteAll","participantUpdateCommandReceived","setTranslateToLanguages","value","setProfanityFiltering","setMute","muteAllCommandReceived","conversationExpiration","setUseTTS","lockRoomCommandReceived","changeNickname","joinParticipantPayload","joiningParticipant","participantJoinCommandReceived","leavingParticipant","participantLeaveCommandReceived","disconnectParticipant","authorizationToken","onToken","speechPayload","conversationResultReason","TranslatedParticipantSpeech","TranslatingParticipantSpeech","speechResult","getTranslations","translations","language","recognition","isFinal","text","length","translationReceived","final","partial","textPayload","textResult","originalText","instantMessage","e","promise","messageRetrievalPromise","r","privRequestSession","RuntimeError","then","state","Disconnected","privConnectionId","connectImpl","serviceResultTranslations","translation","set","lang"],"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n} from \"../../common/Exports.js\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    ResultReason,\r\n    Translations\r\n} from \"../../sdk/Exports.js\";\r\nimport {\r\n    CognitiveTokenAuthentication,\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase\r\n} from \"../Exports.js\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage.js\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession.js\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs.js\";\r\nimport {\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IInternalParticipant\r\n} from \"./ConversationTranslatorInterfaces.js\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer.js\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports.js\";\r\n\r\n/**\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection> = undefined;\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string;\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privLastPartialUtteranceId = \"\";\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = (): Promise<void> => this.receiveConversationMessageOverride();\r\n        this.recognizeOverride = (): Promise<void> => this.noOp();\r\n        this.postConnectImplOverride = (connection: Promise<IConnection>): Promise<IConnection> => this.conversationConnectImpl(connection);\r\n        this.configConnectionOverride = (): Promise<IConnection> => this.configConnection();\r\n        this.disconnectOverride = (): Promise<void> => this.privDisconnect();\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return super.isDisposed() || this.privConversationIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise !== undefined) {\r\n            const connection: IConnection = await this.privConnectionConfigPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n        await super.dispose(reason);\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new ConversationConnectionMessage(\r\n            MessageType.Text,\r\n            message));\r\n    }\r\n\r\n    public async sendMessageAsync(message: string): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n\r\n        await connection.send(new ConversationConnectionMessage(MessageType.Text, message));\r\n    }\r\n\r\n    protected privDisconnect(): Promise<void> {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/require-await\r\n    protected async processTypeSpecificMessages(): Promise<boolean> {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     */\r\n    protected async conversationConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private async receiveConversationMessageOverride(): Promise<void> {\r\n        if (this.isDisposed() || this.terminateMessageLoop) {\r\n            return Promise.resolve();\r\n        }\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConversationConnectionMessage = await connection.read() as ConversationConnectionMessage;\r\n            if (this.isDisposed() || this.terminateMessageLoop) {\r\n                // We're done.\r\n                communicationCustodian.resolve();\r\n                return Promise.resolve();\r\n            }\r\n\r\n            if (!message) {\r\n                return this.receiveConversationMessageOverride();\r\n            }\r\n\r\n            const sessionId: string = this.privConversationRequestSession.sessionId;\r\n            const conversationMessageType: string = message.conversationMessageType.toLowerCase();\r\n            let sendFinal: boolean = false;\r\n\r\n            try {\r\n                switch (conversationMessageType) {\r\n                    case \"info\":\r\n                    case \"participant_command\":\r\n                    case \"command\":\r\n                        const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                        switch (commandPayload.command.toLowerCase()) {\r\n\r\n                            /**\r\n                             * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                             * The consuming client must wait for this message to arrive\r\n                             * before starting to send their own data.\r\n                             */\r\n                            case \"participantlist\":\r\n\r\n                                const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse): IInternalParticipant => {\r\n                                    const participant: IInternalParticipant = {\r\n                                        avatar: p.avatar,\r\n                                        displayName: p.nickname,\r\n                                        id: p.participantId,\r\n                                        isHost: p.ishost,\r\n                                        isMuted: p.ismuted,\r\n                                        isUsingTts: p.usetts,\r\n                                        preferredLanguage: p.locale\r\n                                    };\r\n                                    return participant;\r\n                                });\r\n\r\n                                if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                            participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                            participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                            participantsPayload.muteAll, participantsResult, sessionId));\r\n                                }\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                             * This is sent at the start of the Conversation\r\n                             */\r\n                            case \"settranslatetolanguages\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                             * If sent by the participant the setting will effect only their own profanity level.\r\n                             * If sent by the host, the setting will effect all participants including the host.\r\n                             * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                             */\r\n                            case \"setprofanityfiltering\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMute' is sent if the participant has been muted by the host.\r\n                             * Check the 'participantId' to determine if the current user has been muted.\r\n                             */\r\n                            case \"setmute\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setMute,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                             */\r\n                            case \"setmuteall\":\r\n\r\n                                if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                        new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                             */\r\n                            case \"roomexpirationwarning\":\r\n\r\n                                if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                        new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                             */\r\n                            case \"setusetts\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setUseTTS,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                             */\r\n                            case \"setlockstate\":\r\n\r\n                                if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                        new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'ChangeNickname' is received if a user changes their display name.\r\n                             * Any cached particpiants list should be updated to reflect the display name.\r\n                             */\r\n                            case \"changenickname\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.changeNickname,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'JoinSession' is sent when a user joins the Conversation.\r\n                             */\r\n                            case \"joinsession\":\r\n\r\n                                const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const joiningParticipant: IInternalParticipant = {\r\n                                    avatar: joinParticipantPayload.avatar,\r\n                                    displayName: joinParticipantPayload.nickname,\r\n                                    id: joinParticipantPayload.participantId,\r\n                                    isHost: joinParticipantPayload.ishost,\r\n                                    isMuted: joinParticipantPayload.ismuted,\r\n                                    isUsingTts: joinParticipantPayload.usetts,\r\n                                    preferredLanguage: joinParticipantPayload.locale,\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(\r\n                                            joiningParticipant,\r\n                                            sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                             */\r\n                            case \"leavesession\":\r\n\r\n                                const leavingParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                             * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                             */\r\n                            case \"disconnectsession\":\r\n\r\n                                // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n                                const disconnectParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                break;\r\n\r\n                            case \"token\":\r\n                                const token = new CognitiveTokenAuthentication(\r\n                                    (): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    },\r\n                                    (): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    });\r\n                                this.authentication = token;\r\n                                this.privConversationServiceConnector.onToken(token);\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * Message not recognized.\r\n                             */\r\n                            default:\r\n                                break;\r\n                        }\r\n                        break;\r\n\r\n                    /**\r\n                     * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                     */\r\n                    case \"partial\":\r\n\r\n                    /**\r\n                     * 'final' (or 'phrase') represents a finalized speech message.\r\n                     */\r\n                    case \"final\":\r\n\r\n                        const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n                        const conversationResultReason: ResultReason = (conversationMessageType === \"final\") ? ResultReason.TranslatedParticipantSpeech : ResultReason.TranslatingParticipantSpeech;\r\n\r\n                        const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                            this.getTranslations(speechPayload.translations),\r\n                            speechPayload.language,\r\n                            speechPayload.id,\r\n                            conversationResultReason,\r\n                            speechPayload.recognition,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (speechPayload.isFinal) {\r\n                            // check the length, sometimes empty finals are returned\r\n                            if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                sendFinal = true;\r\n                            } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                // send final as normal. We had a non-empty partial for this same utterance\r\n                                // so sending the empty final is important\r\n                                sendFinal = true;\r\n                            } else {\r\n                                // suppress unneeded final\r\n                            }\r\n\r\n                            if (sendFinal) {\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                }\r\n                            }\r\n                        } else if (speechResult.text !== undefined) {\r\n                            this.privLastPartialUtteranceId = speechPayload.id;\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n\r\n                    /**\r\n                     * \"translated_message\" is a text message or instant message (IM).\r\n                     */\r\n                    case \"translated_message\":\r\n\r\n                        const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n                        // TODO: (Native parity) a result reason should be set based whether the participantId is ours or not\r\n\r\n                        const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                            this.getTranslations(textPayload.translations),\r\n                            textPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            textPayload.originalText,\r\n                            undefined,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (!!this.privConversationServiceConnector.translationReceived) {\r\n                            this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        // ignore any unsupported message types\r\n                        break;\r\n                }\r\n            } catch (e) {\r\n                // continue\r\n            }\r\n            return this.receiveConversationMessageOverride();\r\n        } catch (e) {\r\n            this.terminateMessageLoop = true;\r\n        }\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve();\r\n        }\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        try {\r\n            const r = await messageRetrievalPromise;\r\n            return r;\r\n        } catch (error) {\r\n            this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error as string);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n        if (this.privConnectionConfigPromise !== undefined) {\r\n            return this.privConnectionConfigPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigPromise = undefined;\r\n                    return this.configConnection();\r\n                }\r\n                return this.privConnectionConfigPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigPromise = undefined;\r\n                return this.configConnection();\r\n            });\r\n        }\r\n        if (this.terminateMessageLoop) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.connectImpl().then((connection: IConnection): IConnection => connection);\r\n\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}