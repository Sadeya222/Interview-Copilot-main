{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { OutputFormat, PropertyCollection, PropertyId, ResultReason, SpeechRecognitionResult } from \"../sdk/Exports.js\";\nimport { DetailedSpeechPhrase, EnumTranslation, OutputFormatPropertyName, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechHypothesis } from \"./Exports.js\";\nexport class ConversationServiceRecognizer extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.handleSpeechPhraseMessage = textBody => __awaiter(this, void 0, void 0, function* () {\n      return this.handleSpeechPhrase(textBody);\n    });\n    this.handleSpeechHypothesisMessage = textBody => this.handleSpeechHypothesis(textBody);\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    void connectionMessage;\n    return;\n  }\n  handleRecognizedCallback(result, offset, sessionId) {\n    void result;\n    void offset;\n    void sessionId;\n    return;\n  }\n  handleRecognizingCallback(result, duration, sessionId) {\n    void result;\n    void duration;\n    void sessionId;\n    return;\n  }\n  processSpeechMessages(connectionMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let processed = false;\n      switch (connectionMessage.path.toLowerCase()) {\n        case \"speech.hypothesis\":\n        case \"speech.fragment\":\n          if (!!this.handleSpeechHypothesisMessage) {\n            this.handleSpeechHypothesisMessage(connectionMessage.textBody);\n          }\n          processed = true;\n          break;\n        case \"speech.phrase\":\n          if (!!this.handleSpeechPhraseMessage) {\n            yield this.handleSpeechPhraseMessage(connectionMessage.textBody);\n          }\n          processed = true;\n          break;\n        default:\n          break;\n      }\n      return processed;\n    });\n  }\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    // Implementing to allow inheritance\n    void sessionId;\n    void requestId;\n    void cancellationReason;\n    void errorCode;\n    void error;\n  }\n  handleSpeechPhrase(textBody) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const simple = SimpleSpeechPhrase.fromJSON(textBody);\n      const resultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\n      let result;\n      const resultProps = new PropertyCollection();\n      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, textBody);\n      const simpleOffset = simple.Offset + this.privRequestSession.currentTurnAudioOffset;\n      let offset = simpleOffset;\n      this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\n      if (ResultReason.Canceled === resultReason) {\n        const cancelReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\n        const cancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);\n        yield this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n      } else {\n        if (!(this.privRequestSession.isSpeechEnded && resultReason === ResultReason.NoMatch && simple.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n          if (this.privRecognizerConfig.parameters.getProperty(OutputFormatPropertyName) === OutputFormat[OutputFormat.Simple]) {\n            result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simpleOffset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, undefined, textBody, resultProps);\n          } else {\n            const detailed = DetailedSpeechPhrase.fromJSON(textBody);\n            const totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\n            const offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);\n            result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.Text, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, detailed.SpeakerId, undefined, offsetCorrectedJson, resultProps);\n            offset = result.offset;\n          }\n          this.handleRecognizedCallback(result, offset, this.privRequestSession.sessionId);\n        }\n      }\n    });\n  }\n  handleSpeechHypothesis(textBody) {\n    const hypothesis = SpeechHypothesis.fromJSON(textBody);\n    const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const resultProps = new PropertyCollection();\n    resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, textBody);\n    const result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, hypothesis.SpeakerId, undefined, textBody, resultProps);\n    this.privRequestSession.onHypothesis(offset);\n    this.handleRecognizingCallback(result, hypothesis.Duration, this.privRequestSession.sessionId);\n  }\n}","map":{"version":3,"names":["OutputFormat","PropertyCollection","PropertyId","ResultReason","SpeechRecognitionResult","DetailedSpeechPhrase","EnumTranslation","OutputFormatPropertyName","RecognitionStatus","ServiceRecognizerBase","SimpleSpeechPhrase","SpeechHypothesis","ConversationServiceRecognizer","constructor","authentication","connectionFactory","audioSource","recognizerConfig","recognizer","handleSpeechPhraseMessage","textBody","__awaiter","handleSpeechPhrase","handleSpeechHypothesisMessage","handleSpeechHypothesis","processTypeSpecificMessages","connectionMessage","handleRecognizedCallback","result","offset","sessionId","handleRecognizingCallback","duration","processSpeechMessages","processed","path","toLowerCase","cancelRecognition","requestId","cancellationReason","errorCode","error","simple","fromJSON","resultReason","implTranslateRecognitionResult","resultProps","setProperty","SpeechServiceResponse_JsonResult","simpleOffset","Offset","privRequestSession","currentTurnAudioOffset","onPhraseRecognized","Duration","Canceled","cancelReason","implTranslateCancelResult","cancellationErrorCode","implTranslateCancelErrorCode","cancelRecognitionLocal","implTranslateErrorDetails","isSpeechEnded","NoMatch","InitialSilenceTimeout","privRecognizerConfig","parameters","getProperty","Simple","DisplayText","Language","LanguageDetectionConfidence","SpeakerId","undefined","detailed","totalOffset","offsetCorrectedJson","getJsonWithCorrectedOffsets","Text","hypothesis","RecognizingSpeech","onHypothesis"],"sources":["src/common.speech/ConversationServiceRecognizer.ts"],"sourcesContent":["import { IAudioSource } from \"../common/Exports.js\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    OutputFormat,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    Recognizer,\r\n    ResultReason,\r\n    SpeechRecognitionResult\r\n} from \"../sdk/Exports.js\";\r\nimport {\r\n    DetailedSpeechPhrase,\r\n    EnumTranslation,\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    OutputFormatPropertyName,\r\n    RecognitionStatus,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechHypothesis\r\n} from \"./Exports.js\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\r\n\r\nexport class ConversationServiceRecognizer extends ServiceRecognizerBase {\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        recognizer: Recognizer) {\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\r\n        this.handleSpeechPhraseMessage = async (textBody: string): Promise<void> => this.handleSpeechPhrase(textBody);\r\n        this.handleSpeechHypothesisMessage = (textBody: string): void => this.handleSpeechHypothesis(textBody);\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n        void connectionMessage;\r\n        return;\r\n    }\r\n\r\n    protected handleRecognizedCallback(result: SpeechRecognitionResult, offset: number, sessionId: string): void {\r\n        void result;\r\n        void offset;\r\n        void sessionId;\r\n        return;\r\n    }\r\n\r\n    protected handleRecognizingCallback(result: SpeechRecognitionResult, duration: number, sessionId: string): void {\r\n        void result;\r\n        void duration;\r\n        void sessionId;\r\n        return;\r\n    }\r\n\r\n    protected async processSpeechMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n        let processed: boolean = false;\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.hypothesis\":\r\n            case \"speech.fragment\":\r\n                if (!!this.handleSpeechHypothesisMessage) {\r\n                    this.handleSpeechHypothesisMessage(connectionMessage.textBody);\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.phrase\":\r\n                if (!!this.handleSpeechPhraseMessage) {\r\n                    await this.handleSpeechPhraseMessage(connectionMessage.textBody);\r\n                }\r\n                processed = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n            // Implementing to allow inheritance\r\n            void sessionId;\r\n            void requestId;\r\n            void cancellationReason;\r\n            void errorCode;\r\n            void error;\r\n        }\r\n\r\n    protected async handleSpeechPhrase(textBody: string): Promise<void> {\r\n\r\n        const simple: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(textBody);\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\r\n        let result: SpeechRecognitionResult;\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, textBody);\r\n        const simpleOffset = simple.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n        let offset = simpleOffset;\r\n\r\n        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\r\n\r\n        if (ResultReason.Canceled === resultReason) {\r\n            const cancelReason: CancellationReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\r\n            const cancellationErrorCode: CancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);\r\n\r\n            await this.cancelRecognitionLocal(\r\n                cancelReason,\r\n                cancellationErrorCode,\r\n                EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\r\n\r\n        } else {\r\n            if (!(this.privRequestSession.isSpeechEnded && resultReason === ResultReason.NoMatch && simple.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\r\n                if (this.privRecognizerConfig.parameters.getProperty(OutputFormatPropertyName) === OutputFormat[OutputFormat.Simple]) {\r\n                    result = new SpeechRecognitionResult(\r\n                        this.privRequestSession.requestId,\r\n                        resultReason,\r\n                        simple.DisplayText,\r\n                        simple.Duration,\r\n                        simpleOffset,\r\n                        simple.Language,\r\n                        simple.LanguageDetectionConfidence,\r\n                        simple.SpeakerId,\r\n                        undefined,\r\n                        textBody,\r\n                        resultProps);\r\n                } else {\r\n                    const detailed: DetailedSpeechPhrase = DetailedSpeechPhrase.fromJSON(textBody);\r\n                    const totalOffset: number = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n                    const offsetCorrectedJson: string = detailed.getJsonWithCorrectedOffsets(totalOffset);\r\n\r\n                    result = new SpeechRecognitionResult(\r\n                        this.privRequestSession.requestId,\r\n                        resultReason,\r\n                        detailed.Text,\r\n                        detailed.Duration,\r\n                        totalOffset,\r\n                        detailed.Language,\r\n                        detailed.LanguageDetectionConfidence,\r\n                        detailed.SpeakerId,\r\n                        undefined,\r\n                        offsetCorrectedJson,\r\n                        resultProps);\r\n\r\n                        offset = result.offset;\r\n                }\r\n\r\n                this.handleRecognizedCallback(result, offset, this.privRequestSession.sessionId);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected handleSpeechHypothesis(textBody: string): void {\r\n        const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(textBody);\r\n        const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, textBody);\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privRequestSession.requestId,\r\n            ResultReason.RecognizingSpeech,\r\n            hypothesis.Text,\r\n            hypothesis.Duration,\r\n            offset,\r\n            hypothesis.Language,\r\n            hypothesis.LanguageDetectionConfidence,\r\n            hypothesis.SpeakerId,\r\n            undefined,\r\n            textBody,\r\n            resultProps);\r\n\r\n        this.privRequestSession.onHypothesis(offset);\r\n\r\n        this.handleRecognizingCallback(result, hypothesis.Duration, this.privRequestSession.sessionId);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}