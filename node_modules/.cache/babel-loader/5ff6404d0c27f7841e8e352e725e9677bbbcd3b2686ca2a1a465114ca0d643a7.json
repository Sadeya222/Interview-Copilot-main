{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Deferred, MessageType } from \"../common/Exports.js\";\nimport { CancellationErrorCode, IntentRecognitionCanceledEventArgs, IntentRecognitionEventArgs, IntentRecognitionResult, PropertyCollection, PropertyId, ResultReason } from \"../sdk/Exports.js\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, IntentResponse, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechHypothesis } from \"./Exports.js\";\n// eslint-disable-next-line max-classes-per-file\nexport class IntentServiceRecognizer extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\n    this.privIntentRecognizer = recognizer;\n    this.privIntentDataSent = false;\n  }\n  setIntents(addedIntents, umbrellaIntent) {\n    this.privAddedLmIntents = addedIntents;\n    this.privUmbrellaIntent = umbrellaIntent;\n    this.privIntentDataSent = true;\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    let result;\n    let ev;\n    let processed = false;\n    const resultProps = new PropertyCollection();\n    if (connectionMessage.messageType === MessageType.Text) {\n      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speech.hypothesis\":\n        const speechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n        result = new IntentRecognitionResult(undefined, this.privRequestSession.requestId, ResultReason.RecognizingIntent, speechHypothesis.Text, speechHypothesis.Duration, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, speechHypothesis.Language, speechHypothesis.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n        this.privRequestSession.onHypothesis(result.offset);\n        ev = new IntentRecognitionEventArgs(result, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n        if (!!this.privIntentRecognizer.recognizing) {\n          try {\n            this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"speech.phrase\":\n        const simple = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n        result = new IntentRecognitionResult(undefined, this.privRequestSession.requestId, EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus), simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n        ev = new IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n        const sendEvent = () => {\n          if (!!this.privIntentRecognizer.recognized) {\n            try {\n              this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n              /* eslint-disable no-empty */\n            } catch (error) {\n              // Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n          // report result to promise.\n          if (!!this.privSuccessCallback) {\n            try {\n              this.privSuccessCallback(result);\n            } catch (e) {\n              if (!!this.privErrorCallback) {\n                this.privErrorCallback(e);\n              }\n            }\n            // Only invoke the call back once.\n            // and if it's successful don't invoke the\n            // error after that.\n            this.privSuccessCallback = undefined;\n            this.privErrorCallback = undefined;\n          }\n        };\n        // If intent data was sent, the terminal result for this recognizer is an intent being found.\n        // If no intent data was sent, the terminal event is speech recognition being successful.\n        if (false === this.privIntentDataSent || ResultReason.NoMatch === ev.result.reason) {\n          // Advance the buffers.\n          this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n          sendEvent();\n        } else {\n          // Squirrel away the args, when the response event arrives it will build upon them\n          // and then return\n          this.privPendingIntentArgs = ev;\n        }\n        processed = true;\n        break;\n      case \"response\":\n        // Response from LUIS\n        ev = this.privPendingIntentArgs;\n        this.privPendingIntentArgs = undefined;\n        if (undefined === ev) {\n          if (\"\" === connectionMessage.textBody) {\n            // This condition happens if there is nothing but silence in the\n            // audio sent to the service.\n            return;\n          }\n          // Odd... Not sure this can happen\n          ev = new IntentRecognitionEventArgs(new IntentRecognitionResult(), 0, this.privRequestSession.sessionId);\n        }\n        const intentResponse = IntentResponse.fromJSON(connectionMessage.textBody);\n        // If LUIS didn't return anything, send the existing event, else\n        // modify it to show the match.\n        // See if the intent found is in the list of intents asked for.\n        if (null !== intentResponse && !!intentResponse.topScoringIntent && !!intentResponse.topScoringIntent.intent) {\n          let addedIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];\n          if (this.privUmbrellaIntent !== undefined) {\n            addedIntent = this.privUmbrellaIntent;\n          }\n          if (!!addedIntent) {\n            const intentId = addedIntent === undefined || addedIntent.intentName === undefined ? intentResponse.topScoringIntent.intent : addedIntent.intentName;\n            let reason = ev.result.reason;\n            if (undefined !== intentId) {\n              reason = ResultReason.RecognizedIntent;\n            }\n            // make sure, properties is set.\n            const properties = undefined !== ev.result.properties ? ev.result.properties : new PropertyCollection();\n            properties.setProperty(PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);\n            ev = new IntentRecognitionEventArgs(new IntentRecognitionResult(intentId, ev.result.resultId, reason, ev.result.text, ev.result.duration, ev.result.offset, undefined, undefined, ev.result.errorDetails, ev.result.json, properties), ev.offset, ev.sessionId);\n          }\n        }\n        this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\n        if (!!this.privIntentRecognizer.recognized) {\n          try {\n            this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        // report result to promise.\n        if (!!this.privSuccessCallback) {\n          try {\n            this.privSuccessCallback(ev.result);\n          } catch (e) {\n            if (!!this.privErrorCallback) {\n              this.privErrorCallback(e);\n            }\n          }\n          // Only invoke the call back once.\n          // and if it's successful don't invoke the\n          // error after that.\n          this.privSuccessCallback = undefined;\n          this.privErrorCallback = undefined;\n        }\n        processed = true;\n        break;\n      default:\n        break;\n    }\n    const defferal = new Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n    if (!!this.privIntentRecognizer.canceled) {\n      const cancelEvent = new IntentRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, undefined, sessionId);\n      try {\n        this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n    if (!!this.privSuccessCallback) {\n      const result = new IntentRecognitionResult(undefined,\n      // Intent Id\n      requestId, ResultReason.Canceled, undefined,\n      // Text\n      undefined,\n      // Duration\n      undefined,\n      // Offset\n      undefined,\n      // Language\n      undefined,\n      // LanguageDetectionConfidence\n      error, undefined,\n      // Json\n      properties);\n      try {\n        this.privSuccessCallback(result);\n        this.privSuccessCallback = undefined;\n        /* eslint-disable no-empty */\n      } catch (_b) {}\n    }\n  }\n}","map":{"version":3,"names":["Deferred","MessageType","CancellationErrorCode","IntentRecognitionCanceledEventArgs","IntentRecognitionEventArgs","IntentRecognitionResult","PropertyCollection","PropertyId","ResultReason","CancellationErrorCodePropertyName","EnumTranslation","IntentResponse","ServiceRecognizerBase","SimpleSpeechPhrase","SpeechHypothesis","IntentServiceRecognizer","constructor","authentication","connectionFactory","audioSource","recognizerConfig","recognizer","privIntentRecognizer","privIntentDataSent","setIntents","addedIntents","umbrellaIntent","privAddedLmIntents","privUmbrellaIntent","processTypeSpecificMessages","connectionMessage","result","ev","processed","resultProps","messageType","Text","setProperty","SpeechServiceResponse_JsonResult","textBody","path","toLowerCase","speechHypothesis","fromJSON","undefined","privRequestSession","requestId","RecognizingIntent","Duration","Offset","currentTurnAudioOffset","Language","LanguageDetectionConfidence","onHypothesis","offset","sessionId","recognizing","error","simple","implTranslateRecognitionResult","RecognitionStatus","DisplayText","sendEvent","recognized","privSuccessCallback","e","privErrorCallback","NoMatch","reason","onPhraseRecognized","duration","privPendingIntentArgs","intentResponse","topScoringIntent","intent","addedIntent","intentId","intentName","RecognizedIntent","properties","LanguageUnderstandingServiceResponse_JsonResult","resultId","text","errorDetails","json","defferal","resolve","promise","cancelRecognition","cancellationReason","errorCode","canceled","cancelEvent","_a","Canceled","_b"],"sources":["src/common.speech/IntentServiceRecognizer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    Deferred,\r\n    IAudioSource,\r\n    MessageType,\r\n} from \"../common/Exports.js\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    IntentRecognitionCanceledEventArgs,\r\n    IntentRecognitionEventArgs,\r\n    IntentRecognitionResult,\r\n    IntentRecognizer,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n} from \"../sdk/Exports.js\";\r\nimport {\r\n    AddedLmIntent,\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    IntentResponse,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechHypothesis,\r\n} from \"./Exports.js\";\r\nimport { IAuthentication } from \"./IAuthentication.js\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory.js\";\r\nimport { RecognizerConfig } from \"./RecognizerConfig.js\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\r\n\r\n// eslint-disable-next-line max-classes-per-file\r\nexport class IntentServiceRecognizer extends ServiceRecognizerBase {\r\n    private privIntentRecognizer: IntentRecognizer;\r\n    private privAddedLmIntents: { [id: string]: AddedLmIntent };\r\n    private privIntentDataSent: boolean;\r\n    private privUmbrellaIntent: AddedLmIntent;\r\n    private privPendingIntentArgs: IntentRecognitionEventArgs;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        recognizer: IntentRecognizer) {\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);\r\n        this.privIntentRecognizer = recognizer;\r\n        this.privIntentDataSent = false;\r\n    }\r\n\r\n    public setIntents(addedIntents: { [id: string]: AddedLmIntent }, umbrellaIntent: AddedLmIntent): void {\r\n        this.privAddedLmIntents = addedIntents;\r\n        this.privUmbrellaIntent = umbrellaIntent;\r\n        this.privIntentDataSent = true;\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        let result: IntentRecognitionResult;\r\n        let ev: IntentRecognitionEventArgs;\r\n        let processed: boolean = false;\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.hypothesis\":\r\n                const speechHypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n\r\n                result = new IntentRecognitionResult(\r\n                    undefined,\r\n                    this.privRequestSession.requestId,\r\n                    ResultReason.RecognizingIntent,\r\n                    speechHypothesis.Text,\r\n                    speechHypothesis.Duration,\r\n                    speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset,\r\n                    speechHypothesis.Language,\r\n                    speechHypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privRequestSession.onHypothesis(result.offset);\r\n\r\n                ev = new IntentRecognitionEventArgs(result, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n\r\n                if (!!this.privIntentRecognizer.recognizing) {\r\n                    try {\r\n                        this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.phrase\":\r\n                const simple: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n                result = new IntentRecognitionResult(\r\n                    undefined,\r\n                    this.privRequestSession.requestId,\r\n                    EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus),\r\n                    simple.DisplayText,\r\n                    simple.Duration,\r\n                    simple.Offset + this.privRequestSession.currentTurnAudioOffset,\r\n                    simple.Language,\r\n                    simple.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                ev = new IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\r\n\r\n                const sendEvent: () => void = (): void => {\r\n                    if (!!this.privIntentRecognizer.recognized) {\r\n                        try {\r\n                            this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\r\n                            /* eslint-disable no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n\r\n                    // report result to promise.\r\n                    if (!!this.privSuccessCallback) {\r\n                        try {\r\n                            this.privSuccessCallback(result);\r\n                        } catch (e) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(e as string);\r\n                            }\r\n                        }\r\n                        // Only invoke the call back once.\r\n                        // and if it's successful don't invoke the\r\n                        // error after that.\r\n                        this.privSuccessCallback = undefined;\r\n                        this.privErrorCallback = undefined;\r\n                    }\r\n                };\r\n\r\n                // If intent data was sent, the terminal result for this recognizer is an intent being found.\r\n                // If no intent data was sent, the terminal event is speech recognition being successful.\r\n                if (false === this.privIntentDataSent || ResultReason.NoMatch === ev.result.reason) {\r\n                    // Advance the buffers.\r\n                    this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\r\n                    sendEvent();\r\n                } else {\r\n                    // Squirrel away the args, when the response event arrives it will build upon them\r\n                    // and then return\r\n                    this.privPendingIntentArgs = ev;\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"response\":\r\n                // Response from LUIS\r\n                ev = this.privPendingIntentArgs;\r\n                this.privPendingIntentArgs = undefined;\r\n\r\n                if (undefined === ev) {\r\n                    if (\"\" === connectionMessage.textBody) {\r\n                        // This condition happens if there is nothing but silence in the\r\n                        // audio sent to the service.\r\n                        return;\r\n                    }\r\n\r\n                    // Odd... Not sure this can happen\r\n                    ev = new IntentRecognitionEventArgs(new IntentRecognitionResult(), 0, this.privRequestSession.sessionId);\r\n                }\r\n\r\n                const intentResponse: IntentResponse = IntentResponse.fromJSON(connectionMessage.textBody);\r\n\r\n                // If LUIS didn't return anything, send the existing event, else\r\n                // modify it to show the match.\r\n                // See if the intent found is in the list of intents asked for.\r\n\r\n                if (null !== intentResponse && !!intentResponse.topScoringIntent && !!intentResponse.topScoringIntent.intent) {\r\n                    let addedIntent: AddedLmIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];\r\n\r\n                    if (this.privUmbrellaIntent !== undefined) {\r\n                        addedIntent = this.privUmbrellaIntent;\r\n                    }\r\n\r\n                    if (!!addedIntent) {\r\n                        const intentId = addedIntent === undefined || addedIntent.intentName === undefined ? intentResponse.topScoringIntent.intent : addedIntent.intentName;\r\n                        let reason = ev.result.reason;\r\n\r\n                        if (undefined !== intentId) {\r\n                            reason = ResultReason.RecognizedIntent;\r\n                        }\r\n\r\n                        // make sure, properties is set.\r\n                        const properties = (undefined !== ev.result.properties) ?\r\n                            ev.result.properties : new PropertyCollection();\r\n\r\n                        properties.setProperty(PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);\r\n\r\n                        ev = new IntentRecognitionEventArgs(\r\n                            new IntentRecognitionResult(\r\n                                intentId,\r\n                                ev.result.resultId,\r\n                                reason,\r\n                                ev.result.text,\r\n                                ev.result.duration,\r\n                                ev.result.offset,\r\n                                undefined,\r\n                                undefined,\r\n                                ev.result.errorDetails,\r\n                                ev.result.json,\r\n                                properties),\r\n                            ev.offset,\r\n                            ev.sessionId);\r\n\r\n                    }\r\n                }\r\n                this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);\r\n\r\n                if (!!this.privIntentRecognizer.recognized) {\r\n                    try {\r\n                        this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n\r\n                // report result to promise.\r\n                if (!!this.privSuccessCallback) {\r\n                    try {\r\n                        this.privSuccessCallback(ev.result);\r\n                    } catch (e) {\r\n                        if (!!this.privErrorCallback) {\r\n                            this.privErrorCallback(e as string);\r\n                        }\r\n                    }\r\n                    // Only invoke the call back once.\r\n                    // and if it's successful don't invoke the\r\n                    // error after that.\r\n                    this.privSuccessCallback = undefined;\r\n                    this.privErrorCallback = undefined;\r\n                }\r\n                processed = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        const defferal = new Deferred<boolean>();\r\n        defferal.resolve(processed);\r\n        return defferal.promise;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n        if (!!this.privIntentRecognizer.canceled) {\r\n\r\n            const cancelEvent: IntentRecognitionCanceledEventArgs = new IntentRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                undefined,\r\n                sessionId);\r\n            try {\r\n                this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            const result: IntentRecognitionResult = new IntentRecognitionResult(\r\n                undefined, // Intent Id\r\n                requestId,\r\n                ResultReason.Canceled,\r\n                undefined, // Text\r\n                undefined, // Duration\r\n                undefined, // Offset\r\n                undefined, // Language\r\n                undefined, // LanguageDetectionConfidence\r\n                error,\r\n                undefined, // Json\r\n                properties);\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                this.privSuccessCallback = undefined;\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}