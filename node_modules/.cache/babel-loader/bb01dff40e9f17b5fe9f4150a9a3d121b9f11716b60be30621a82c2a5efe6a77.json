{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/* eslint-disable max-classes-per-file */\nimport { AudioSourceErrorEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ConnectionEstablishedEvent, ConnectionEstablishErrorEvent, ConnectionMessageReceivedEvent, ConnectionStartEvent } from \"../common/Exports.js\";\nimport { ConnectingToServiceEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents.js\";\nexport class ServiceTelemetryListener {\n  constructor(requestId, audioSourceId, audioNodeId) {\n    this.privIsDisposed = false;\n    this.privListeningTriggerMetric = null;\n    this.privMicMetric = null;\n    this.privConnectionEstablishMetric = null;\n    this.privRequestId = requestId;\n    this.privAudioSourceId = audioSourceId;\n    this.privAudioNodeId = audioNodeId;\n    this.privReceivedMessages = {};\n    this.privPhraseLatencies = [];\n    this.privHypothesisLatencies = [];\n  }\n  phraseReceived(audioReceivedTime) {\n    if (audioReceivedTime > 0) {\n      // 0 indicates the time is unknown. Drop it.\n      this.privPhraseLatencies.push(Date.now() - audioReceivedTime);\n    }\n  }\n  hypothesisReceived(audioReceivedTime) {\n    if (audioReceivedTime > 0) {\n      // 0 indicates the time is unknown. Drop it.\n      this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);\n    }\n  }\n  onEvent(e) {\n    if (this.privIsDisposed) {\n      return;\n    }\n    if (e instanceof RecognitionTriggeredEvent && e.requestId === this.privRequestId) {\n      this.privListeningTriggerMetric = {\n        End: e.eventTime,\n        Name: \"ListeningTrigger\",\n        Start: e.eventTime\n      };\n    }\n    if (e instanceof AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      this.privMicStartTime = e.eventTime;\n    }\n    if (e instanceof AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      this.privMicStartTime = e.eventTime;\n    }\n    if (e instanceof AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Error: e.error,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n    if (e instanceof AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Error: e.error,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n    if (e instanceof AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n    if (e instanceof ConnectingToServiceEvent && e.requestId === this.privRequestId) {\n      this.privConnectionId = e.sessionId;\n    }\n    if (e instanceof ConnectionStartEvent && e.connectionId === this.privConnectionId) {\n      this.privConnectionStartTime = e.eventTime;\n    }\n    if (e instanceof ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {\n      if (!this.privConnectionEstablishMetric) {\n        this.privConnectionEstablishMetric = {\n          End: e.eventTime,\n          Id: this.privConnectionId,\n          Name: \"Connection\",\n          Start: this.privConnectionStartTime\n        };\n      }\n    }\n    if (e instanceof ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {\n      if (!this.privConnectionEstablishMetric) {\n        this.privConnectionEstablishMetric = {\n          End: e.eventTime,\n          Error: this.getConnectionError(e.statusCode),\n          Id: this.privConnectionId,\n          Name: \"Connection\",\n          Start: this.privConnectionStartTime\n        };\n      }\n    }\n    if (e instanceof ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {\n      if (e.message && e.message.headers && e.message.headers.path) {\n        if (!this.privReceivedMessages[e.message.headers.path]) {\n          this.privReceivedMessages[e.message.headers.path] = new Array();\n        }\n        const maxMessagesToSend = 50;\n        if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {\n          this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);\n        }\n      }\n    }\n  }\n  getTelemetry() {\n    const metrics = new Array();\n    if (this.privListeningTriggerMetric) {\n      metrics.push(this.privListeningTriggerMetric);\n    }\n    if (this.privMicMetric) {\n      metrics.push(this.privMicMetric);\n    }\n    if (this.privConnectionEstablishMetric) {\n      metrics.push(this.privConnectionEstablishMetric);\n    }\n    if (this.privPhraseLatencies.length > 0) {\n      metrics.push({\n        PhraseLatencyMs: this.privPhraseLatencies\n      });\n    }\n    if (this.privHypothesisLatencies.length > 0) {\n      metrics.push({\n        FirstHypothesisLatencyMs: this.privHypothesisLatencies\n      });\n    }\n    const telemetry = {\n      Metrics: metrics,\n      ReceivedMessages: this.privReceivedMessages\n    };\n    const json = JSON.stringify(telemetry);\n    // We dont want to send the same telemetry again. So clean those out.\n    this.privReceivedMessages = {};\n    this.privListeningTriggerMetric = null;\n    this.privMicMetric = null;\n    this.privConnectionEstablishMetric = null;\n    this.privPhraseLatencies = [];\n    this.privHypothesisLatencies = [];\n    return json;\n  }\n  // Determines if there are any telemetry events to send to the service.\n  get hasTelemetry() {\n    return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;\n  }\n  dispose() {\n    this.privIsDisposed = true;\n  }\n  getConnectionError(statusCode) {\n    /*\n    -- Websocket status codes --\n    NormalClosure = 1000,\n    EndpointUnavailable = 1001,\n    ProtocolError = 1002,\n    InvalidMessageType = 1003,\n    Empty = 1005,\n    InvalidPayloadData = 1007,\n    PolicyViolation = 1008,\n    MessageTooBig = 1009,\n    MandatoryExtension = 1010,\n    InternalServerError = 1011\n    */\n    switch (statusCode) {\n      case 400:\n      case 1002:\n      case 1003:\n      case 1005:\n      case 1007:\n      case 1008:\n      case 1009:\n        return \"BadRequest\";\n      case 401:\n        return \"Unauthorized\";\n      case 403:\n        return \"Forbidden\";\n      case 503:\n      case 1001:\n        return \"ServerUnavailable\";\n      case 500:\n      case 1011:\n        return \"ServerError\";\n      case 408:\n      case 504:\n        return \"Timeout\";\n      default:\n        return \"statuscode:\" + statusCode.toString();\n    }\n  }\n}","map":{"version":3,"names":["AudioSourceErrorEvent","AudioStreamNodeAttachedEvent","AudioStreamNodeAttachingEvent","AudioStreamNodeDetachedEvent","AudioStreamNodeErrorEvent","ConnectionEstablishedEvent","ConnectionEstablishErrorEvent","ConnectionMessageReceivedEvent","ConnectionStartEvent","ConnectingToServiceEvent","RecognitionTriggeredEvent","ServiceTelemetryListener","constructor","requestId","audioSourceId","audioNodeId","privIsDisposed","privListeningTriggerMetric","privMicMetric","privConnectionEstablishMetric","privRequestId","privAudioSourceId","privAudioNodeId","privReceivedMessages","privPhraseLatencies","privHypothesisLatencies","phraseReceived","audioReceivedTime","push","Date","now","hypothesisReceived","onEvent","e","End","eventTime","Name","Start","privMicStartTime","Error","error","privConnectionId","sessionId","connectionId","privConnectionStartTime","Id","getConnectionError","statusCode","message","headers","path","Array","maxMessagesToSend","length","networkReceivedTime","getTelemetry","metrics","PhraseLatencyMs","FirstHypothesisLatencyMs","telemetry","Metrics","ReceivedMessages","json","JSON","stringify","hasTelemetry","Object","keys","dispose","toString"],"sources":["src/common.speech/ServiceTelemetryListener.Internal.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\n/* eslint-disable max-classes-per-file */\r\n\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ConnectionEstablishedEvent,\r\n    ConnectionEstablishErrorEvent,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionStartEvent,\r\n    IEventListener,\r\n    IStringDictionary,\r\n    PlatformEvent,\r\n} from \"../common/Exports.js\";\r\nimport { ConnectingToServiceEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents.js\";\r\n\r\nexport interface ITelemetry {\r\n    Metrics: IMetric[];\r\n    ReceivedMessages: IStringDictionary<string[]>;\r\n}\r\n\r\nexport interface IMetric {\r\n    End?: string;\r\n    Error?: string;\r\n    Id?: string;\r\n    Name?: string;\r\n    Start?: string;\r\n    PhraseLatencyMs?: number[];\r\n    FirstHypothesisLatencyMs?: number[];\r\n}\r\n\r\nexport class ServiceTelemetryListener implements IEventListener<PlatformEvent> {\r\n    private privIsDisposed: boolean = false;\r\n\r\n    private privRequestId: string;\r\n    private privAudioSourceId: string;\r\n    private privAudioNodeId: string;\r\n\r\n    private privListeningTriggerMetric: IMetric = null;\r\n    private privMicMetric: IMetric = null;\r\n    private privConnectionEstablishMetric: IMetric = null;\r\n\r\n    private privMicStartTime: string;\r\n\r\n    private privConnectionId: string;\r\n    private privConnectionStartTime: string;\r\n\r\n    private privReceivedMessages: IStringDictionary<string[]>;\r\n    private privPhraseLatencies: number[];\r\n    private privHypothesisLatencies: number[];\r\n\r\n    public constructor(requestId: string, audioSourceId: string, audioNodeId: string) {\r\n        this.privRequestId = requestId;\r\n        this.privAudioSourceId = audioSourceId;\r\n        this.privAudioNodeId = audioNodeId;\r\n\r\n        this.privReceivedMessages = {};\r\n        this.privPhraseLatencies = [];\r\n        this.privHypothesisLatencies = [];\r\n    }\r\n\r\n    public phraseReceived(audioReceivedTime: number): void {\r\n        if (audioReceivedTime > 0) { // 0 indicates the time is unknown. Drop it.\r\n            this.privPhraseLatencies.push(Date.now() - audioReceivedTime);\r\n        }\r\n    }\r\n\r\n    public hypothesisReceived(audioReceivedTime: number): void {\r\n        if (audioReceivedTime > 0) { // 0 indicates the time is unknown. Drop it.\r\n            this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);\r\n        }\r\n    }\r\n\r\n    public onEvent(e: PlatformEvent): void {\r\n        if (this.privIsDisposed) {\r\n            return;\r\n        }\r\n\r\n        if (e instanceof RecognitionTriggeredEvent && e.requestId === this.privRequestId) {\r\n            this.privListeningTriggerMetric = {\r\n                End: e.eventTime,\r\n                Name: \"ListeningTrigger\",\r\n                Start: e.eventTime,\r\n            };\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            this.privMicStartTime = e.eventTime;\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            this.privMicStartTime = e.eventTime;\r\n        }\r\n\r\n        if (e instanceof AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {\r\n            if (!this.privMicMetric) {\r\n                this.privMicMetric = {\r\n                    End: e.eventTime,\r\n                    Error: e.error,\r\n                    Name: \"Microphone\",\r\n                    Start: this.privMicStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            if (!this.privMicMetric) {\r\n                this.privMicMetric = {\r\n                    End: e.eventTime,\r\n                    Error: e.error,\r\n                    Name: \"Microphone\",\r\n                    Start: this.privMicStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            if (!this.privMicMetric) {\r\n                this.privMicMetric = {\r\n                    End: e.eventTime,\r\n                    Name: \"Microphone\",\r\n                    Start: this.privMicStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof ConnectingToServiceEvent && e.requestId === this.privRequestId) {\r\n            this.privConnectionId = e.sessionId;\r\n        }\r\n\r\n        if (e instanceof ConnectionStartEvent && e.connectionId === this.privConnectionId) {\r\n            this.privConnectionStartTime = e.eventTime;\r\n        }\r\n\r\n        if (e instanceof ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {\r\n            if (!this.privConnectionEstablishMetric) {\r\n                this.privConnectionEstablishMetric = {\r\n                    End: e.eventTime,\r\n                    Id: this.privConnectionId,\r\n                    Name: \"Connection\",\r\n                    Start: this.privConnectionStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {\r\n            if (!this.privConnectionEstablishMetric) {\r\n                this.privConnectionEstablishMetric = {\r\n                    End: e.eventTime,\r\n                    Error: this.getConnectionError(e.statusCode),\r\n                    Id: this.privConnectionId,\r\n                    Name: \"Connection\",\r\n                    Start: this.privConnectionStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {\r\n            if (e.message && e.message.headers && e.message.headers.path) {\r\n                if (!this.privReceivedMessages[e.message.headers.path]) {\r\n                    this.privReceivedMessages[e.message.headers.path] = new Array<string>();\r\n                }\r\n                const maxMessagesToSend = 50;\r\n                if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {\r\n                    this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public getTelemetry(): string {\r\n        const metrics = new Array<IMetric>();\r\n\r\n        if (this.privListeningTriggerMetric) {\r\n            metrics.push(this.privListeningTriggerMetric);\r\n        }\r\n\r\n        if (this.privMicMetric) {\r\n            metrics.push(this.privMicMetric);\r\n        }\r\n\r\n        if (this.privConnectionEstablishMetric) {\r\n            metrics.push(this.privConnectionEstablishMetric);\r\n        }\r\n\r\n        if (this.privPhraseLatencies.length > 0) {\r\n            metrics.push({\r\n                PhraseLatencyMs: this.privPhraseLatencies,\r\n            });\r\n        }\r\n\r\n        if (this.privHypothesisLatencies.length > 0) {\r\n            metrics.push({\r\n                FirstHypothesisLatencyMs: this.privHypothesisLatencies,\r\n            });\r\n        }\r\n\r\n        const telemetry: ITelemetry = {\r\n            Metrics: metrics,\r\n            ReceivedMessages: this.privReceivedMessages,\r\n        };\r\n\r\n        const json = JSON.stringify(telemetry);\r\n\r\n        // We dont want to send the same telemetry again. So clean those out.\r\n        this.privReceivedMessages = {};\r\n        this.privListeningTriggerMetric = null;\r\n        this.privMicMetric = null;\r\n        this.privConnectionEstablishMetric = null;\r\n        this.privPhraseLatencies = [];\r\n        this.privHypothesisLatencies = [];\r\n        return json;\r\n    }\r\n\r\n    // Determines if there are any telemetry events to send to the service.\r\n    public get hasTelemetry(): boolean {\r\n        return (Object.keys(this.privReceivedMessages).length !== 0 ||\r\n            this.privListeningTriggerMetric !== null ||\r\n            this.privMicMetric !== null ||\r\n            this.privConnectionEstablishMetric !== null ||\r\n            this.privPhraseLatencies.length !== 0 ||\r\n            this.privHypothesisLatencies.length !== 0);\r\n    }\r\n\r\n    public dispose(): void {\r\n        this.privIsDisposed = true;\r\n    }\r\n\r\n    private getConnectionError(statusCode: number): string {\r\n        /*\r\n        -- Websocket status codes --\r\n        NormalClosure = 1000,\r\n        EndpointUnavailable = 1001,\r\n        ProtocolError = 1002,\r\n        InvalidMessageType = 1003,\r\n        Empty = 1005,\r\n        InvalidPayloadData = 1007,\r\n        PolicyViolation = 1008,\r\n        MessageTooBig = 1009,\r\n        MandatoryExtension = 1010,\r\n        InternalServerError = 1011\r\n        */\r\n\r\n        switch (statusCode) {\r\n            case 400:\r\n            case 1002:\r\n            case 1003:\r\n            case 1005:\r\n            case 1007:\r\n            case 1008:\r\n            case 1009: return \"BadRequest\";\r\n            case 401: return \"Unauthorized\";\r\n            case 403: return \"Forbidden\";\r\n            case 503:\r\n            case 1001: return \"ServerUnavailable\";\r\n            case 500:\r\n            case 1011: return \"ServerError\";\r\n            case 408:\r\n            case 504: return \"Timeout\";\r\n            default: return \"statuscode:\" + statusCode.toString();\r\n        }\r\n    }\r\n}\r\n"],"mappings":";AAAA;AACA;AAEA;AAEA,SACIA,qBAAqB,EACrBC,4BAA4B,EAC5BC,6BAA6B,EAC7BC,4BAA4B,EAC5BC,yBAAyB,EACzBC,0BAA0B,EAC1BC,6BAA6B,EAC7BC,8BAA8B,EAC9BC,oBAAoB,QAIjB,sBAAsB;AAC7B,SAASC,wBAAwB,EAAEC,yBAAyB,QAAQ,wBAAwB;AAiB5F,OAAM,MAAOC,wBAAwB;EAoBjCC,YAAmBC,SAAiB,EAAEC,aAAqB,EAAEC,WAAmB;IAnBxE,KAAAC,cAAc,GAAY,KAAK;IAM/B,KAAAC,0BAA0B,GAAY,IAAI;IAC1C,KAAAC,aAAa,GAAY,IAAI;IAC7B,KAAAC,6BAA6B,GAAY,IAAI;IAYjD,IAAI,CAACC,aAAa,GAAGP,SAAS;IAC9B,IAAI,CAACQ,iBAAiB,GAAGP,aAAa;IACtC,IAAI,CAACQ,eAAe,GAAGP,WAAW;IAElC,IAAI,CAACQ,oBAAoB,GAAG,EAAE;IAC9B,IAAI,CAACC,mBAAmB,GAAG,EAAE;IAC7B,IAAI,CAACC,uBAAuB,GAAG,EAAE;EACrC;EAEOC,cAAcA,CAACC,iBAAyB;IAC3C,IAAIA,iBAAiB,GAAG,CAAC,EAAE;MAAE;MACzB,IAAI,CAACH,mBAAmB,CAACI,IAAI,CAACC,IAAI,CAACC,GAAG,EAAE,GAAGH,iBAAiB,CAAC;;EAErE;EAEOI,kBAAkBA,CAACJ,iBAAyB;IAC/C,IAAIA,iBAAiB,GAAG,CAAC,EAAE;MAAE;MACzB,IAAI,CAACF,uBAAuB,CAACG,IAAI,CAACC,IAAI,CAACC,GAAG,EAAE,GAAGH,iBAAiB,CAAC;;EAEzE;EAEOK,OAAOA,CAACC,CAAgB;IAC3B,IAAI,IAAI,CAACjB,cAAc,EAAE;MACrB;;IAGJ,IAAIiB,CAAC,YAAYvB,yBAAyB,IAAIuB,CAAC,CAACpB,SAAS,KAAK,IAAI,CAACO,aAAa,EAAE;MAC9E,IAAI,CAACH,0BAA0B,GAAG;QAC9BiB,GAAG,EAAED,CAAC,CAACE,SAAS;QAChBC,IAAI,EAAE,kBAAkB;QACxBC,KAAK,EAAEJ,CAAC,CAACE;OACZ;;IAGL,IAAIF,CAAC,YAAY/B,6BAA6B,IAAI+B,CAAC,CAACnB,aAAa,KAAK,IAAI,CAACO,iBAAiB,IAAIY,CAAC,CAAClB,WAAW,KAAK,IAAI,CAACO,eAAe,EAAE;MACpI,IAAI,CAACgB,gBAAgB,GAAGL,CAAC,CAACE,SAAS;;IAGvC,IAAIF,CAAC,YAAYhC,4BAA4B,IAAIgC,CAAC,CAACnB,aAAa,KAAK,IAAI,CAACO,iBAAiB,IAAIY,CAAC,CAAClB,WAAW,KAAK,IAAI,CAACO,eAAe,EAAE;MACnI,IAAI,CAACgB,gBAAgB,GAAGL,CAAC,CAACE,SAAS;;IAGvC,IAAIF,CAAC,YAAYjC,qBAAqB,IAAIiC,CAAC,CAACnB,aAAa,KAAK,IAAI,CAACO,iBAAiB,EAAE;MAClF,IAAI,CAAC,IAAI,CAACH,aAAa,EAAE;QACrB,IAAI,CAACA,aAAa,GAAG;UACjBgB,GAAG,EAAED,CAAC,CAACE,SAAS;UAChBI,KAAK,EAAEN,CAAC,CAACO,KAAK;UACdJ,IAAI,EAAE,YAAY;UAClBC,KAAK,EAAE,IAAI,CAACC;SACf;;;IAIT,IAAIL,CAAC,YAAY7B,yBAAyB,IAAI6B,CAAC,CAACnB,aAAa,KAAK,IAAI,CAACO,iBAAiB,IAAIY,CAAC,CAAClB,WAAW,KAAK,IAAI,CAACO,eAAe,EAAE;MAChI,IAAI,CAAC,IAAI,CAACJ,aAAa,EAAE;QACrB,IAAI,CAACA,aAAa,GAAG;UACjBgB,GAAG,EAAED,CAAC,CAACE,SAAS;UAChBI,KAAK,EAAEN,CAAC,CAACO,KAAK;UACdJ,IAAI,EAAE,YAAY;UAClBC,KAAK,EAAE,IAAI,CAACC;SACf;;;IAIT,IAAIL,CAAC,YAAY9B,4BAA4B,IAAI8B,CAAC,CAACnB,aAAa,KAAK,IAAI,CAACO,iBAAiB,IAAIY,CAAC,CAAClB,WAAW,KAAK,IAAI,CAACO,eAAe,EAAE;MACnI,IAAI,CAAC,IAAI,CAACJ,aAAa,EAAE;QACrB,IAAI,CAACA,aAAa,GAAG;UACjBgB,GAAG,EAAED,CAAC,CAACE,SAAS;UAChBC,IAAI,EAAE,YAAY;UAClBC,KAAK,EAAE,IAAI,CAACC;SACf;;;IAIT,IAAIL,CAAC,YAAYxB,wBAAwB,IAAIwB,CAAC,CAACpB,SAAS,KAAK,IAAI,CAACO,aAAa,EAAE;MAC7E,IAAI,CAACqB,gBAAgB,GAAGR,CAAC,CAACS,SAAS;;IAGvC,IAAIT,CAAC,YAAYzB,oBAAoB,IAAIyB,CAAC,CAACU,YAAY,KAAK,IAAI,CAACF,gBAAgB,EAAE;MAC/E,IAAI,CAACG,uBAAuB,GAAGX,CAAC,CAACE,SAAS;;IAG9C,IAAIF,CAAC,YAAY5B,0BAA0B,IAAI4B,CAAC,CAACU,YAAY,KAAK,IAAI,CAACF,gBAAgB,EAAE;MACrF,IAAI,CAAC,IAAI,CAACtB,6BAA6B,EAAE;QACrC,IAAI,CAACA,6BAA6B,GAAG;UACjCe,GAAG,EAAED,CAAC,CAACE,SAAS;UAChBU,EAAE,EAAE,IAAI,CAACJ,gBAAgB;UACzBL,IAAI,EAAE,YAAY;UAClBC,KAAK,EAAE,IAAI,CAACO;SACf;;;IAIT,IAAIX,CAAC,YAAY3B,6BAA6B,IAAI2B,CAAC,CAACU,YAAY,KAAK,IAAI,CAACF,gBAAgB,EAAE;MACxF,IAAI,CAAC,IAAI,CAACtB,6BAA6B,EAAE;QACrC,IAAI,CAACA,6BAA6B,GAAG;UACjCe,GAAG,EAAED,CAAC,CAACE,SAAS;UAChBI,KAAK,EAAE,IAAI,CAACO,kBAAkB,CAACb,CAAC,CAACc,UAAU,CAAC;UAC5CF,EAAE,EAAE,IAAI,CAACJ,gBAAgB;UACzBL,IAAI,EAAE,YAAY;UAClBC,KAAK,EAAE,IAAI,CAACO;SACf;;;IAIT,IAAIX,CAAC,YAAY1B,8BAA8B,IAAI0B,CAAC,CAACU,YAAY,KAAK,IAAI,CAACF,gBAAgB,EAAE;MACzF,IAAIR,CAAC,CAACe,OAAO,IAAIf,CAAC,CAACe,OAAO,CAACC,OAAO,IAAIhB,CAAC,CAACe,OAAO,CAACC,OAAO,CAACC,IAAI,EAAE;QAC1D,IAAI,CAAC,IAAI,CAAC3B,oBAAoB,CAACU,CAAC,CAACe,OAAO,CAACC,OAAO,CAACC,IAAI,CAAC,EAAE;UACpD,IAAI,CAAC3B,oBAAoB,CAACU,CAAC,CAACe,OAAO,CAACC,OAAO,CAACC,IAAI,CAAC,GAAG,IAAIC,KAAK,EAAU;;QAE3E,MAAMC,iBAAiB,GAAG,EAAE;QAC5B,IAAI,IAAI,CAAC7B,oBAAoB,CAACU,CAAC,CAACe,OAAO,CAACC,OAAO,CAACC,IAAI,CAAC,CAACG,MAAM,GAAGD,iBAAiB,EAAE;UAC9E,IAAI,CAAC7B,oBAAoB,CAACU,CAAC,CAACe,OAAO,CAACC,OAAO,CAACC,IAAI,CAAC,CAACtB,IAAI,CAACK,CAAC,CAACqB,mBAAmB,CAAC;;;;EAI7F;EAEOC,YAAYA,CAAA;IACf,MAAMC,OAAO,GAAG,IAAIL,KAAK,EAAW;IAEpC,IAAI,IAAI,CAAClC,0BAA0B,EAAE;MACjCuC,OAAO,CAAC5B,IAAI,CAAC,IAAI,CAACX,0BAA0B,CAAC;;IAGjD,IAAI,IAAI,CAACC,aAAa,EAAE;MACpBsC,OAAO,CAAC5B,IAAI,CAAC,IAAI,CAACV,aAAa,CAAC;;IAGpC,IAAI,IAAI,CAACC,6BAA6B,EAAE;MACpCqC,OAAO,CAAC5B,IAAI,CAAC,IAAI,CAACT,6BAA6B,CAAC;;IAGpD,IAAI,IAAI,CAACK,mBAAmB,CAAC6B,MAAM,GAAG,CAAC,EAAE;MACrCG,OAAO,CAAC5B,IAAI,CAAC;QACT6B,eAAe,EAAE,IAAI,CAACjC;OACzB,CAAC;;IAGN,IAAI,IAAI,CAACC,uBAAuB,CAAC4B,MAAM,GAAG,CAAC,EAAE;MACzCG,OAAO,CAAC5B,IAAI,CAAC;QACT8B,wBAAwB,EAAE,IAAI,CAACjC;OAClC,CAAC;;IAGN,MAAMkC,SAAS,GAAe;MAC1BC,OAAO,EAAEJ,OAAO;MAChBK,gBAAgB,EAAE,IAAI,CAACtC;KAC1B;IAED,MAAMuC,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACL,SAAS,CAAC;IAEtC;IACA,IAAI,CAACpC,oBAAoB,GAAG,EAAE;IAC9B,IAAI,CAACN,0BAA0B,GAAG,IAAI;IACtC,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,6BAA6B,GAAG,IAAI;IACzC,IAAI,CAACK,mBAAmB,GAAG,EAAE;IAC7B,IAAI,CAACC,uBAAuB,GAAG,EAAE;IACjC,OAAOqC,IAAI;EACf;EAEA;EACA,IAAWG,YAAYA,CAAA;IACnB,OAAQC,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC5C,oBAAoB,CAAC,CAAC8B,MAAM,KAAK,CAAC,IACvD,IAAI,CAACpC,0BAA0B,KAAK,IAAI,IACxC,IAAI,CAACC,aAAa,KAAK,IAAI,IAC3B,IAAI,CAACC,6BAA6B,KAAK,IAAI,IAC3C,IAAI,CAACK,mBAAmB,CAAC6B,MAAM,KAAK,CAAC,IACrC,IAAI,CAAC5B,uBAAuB,CAAC4B,MAAM,KAAK,CAAC;EACjD;EAEOe,OAAOA,CAAA;IACV,IAAI,CAACpD,cAAc,GAAG,IAAI;EAC9B;EAEQ8B,kBAAkBA,CAACC,UAAkB;IACzC;;;;;;;;;;;;;IAcA,QAAQA,UAAU;MACd,KAAK,GAAG;MACR,KAAK,IAAI;MACT,KAAK,IAAI;MACT,KAAK,IAAI;MACT,KAAK,IAAI;MACT,KAAK,IAAI;MACT,KAAK,IAAI;QAAE,OAAO,YAAY;MAC9B,KAAK,GAAG;QAAE,OAAO,cAAc;MAC/B,KAAK,GAAG;QAAE,OAAO,WAAW;MAC5B,KAAK,GAAG;MACR,KAAK,IAAI;QAAE,OAAO,mBAAmB;MACrC,KAAK,GAAG;MACR,KAAK,IAAI;QAAE,OAAO,aAAa;MAC/B,KAAK,GAAG;MACR,KAAK,GAAG;QAAE,OAAO,SAAS;MAC1B;QAAS,OAAO,aAAa,GAAGA,UAAU,CAACsB,QAAQ,EAAE;;EAE7D"},"metadata":{},"sourceType":"module","externalDependencies":[]}