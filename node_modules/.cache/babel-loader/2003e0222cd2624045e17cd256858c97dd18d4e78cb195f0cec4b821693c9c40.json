{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { MessageType, TranslationStatus } from \"../common/Exports.js\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, TranslationRecognitionCanceledEventArgs, TranslationRecognitionEventArgs, TranslationRecognitionResult, Translations, TranslationSynthesisEventArgs, TranslationSynthesisResult } from \"../sdk/Exports.js\";\nimport { CancellationErrorCodePropertyName, ConversationServiceRecognizer, EnumTranslation, RecognitionStatus, SynthesisStatus, TranslationHypothesis, TranslationPhrase, TranslationSynthesisEnd } from \"./Exports.js\";\n// eslint-disable-next-line max-classes-per-file\nexport class TranslationServiceRecognizer extends ConversationServiceRecognizer {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer);\n    this.privTranslationRecognizer = translationRecognizer;\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n        this.privTranslationRecognizer.onConnection();\n      }\n    });\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const resultProps = new PropertyCollection();\n      let processed = yield this.processSpeechMessages(connectionMessage);\n      if (processed) {\n        return true;\n      }\n      const handleTranslationPhrase = translatedPhrase => __awaiter(this, void 0, void 0, function* () {\n        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset + translatedPhrase.Duration);\n        if (translatedPhrase.RecognitionStatus === RecognitionStatus.Success) {\n          // OK, the recognition was successful. How'd the translation do?\n          const result = this.fireEventForResult(translatedPhrase, resultProps);\n          if (!!this.privTranslationRecognizer.recognized) {\n            try {\n              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);\n              /* eslint-disable no-empty */\n            } catch (error) {\n              // Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n          // report result to promise.\n          if (!!this.privSuccessCallback) {\n            try {\n              this.privSuccessCallback(result.result);\n            } catch (e) {\n              if (!!this.privErrorCallback) {\n                this.privErrorCallback(e);\n              }\n            }\n            // Only invoke the call back once.\n            // and if it's successful don't invoke the\n            // error after that.\n            this.privSuccessCallback = undefined;\n            this.privErrorCallback = undefined;\n          }\n        } else {\n          const reason = EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);\n          const result = new TranslationRecognitionResult(undefined, this.privRequestSession.requestId, reason, translatedPhrase.Text, translatedPhrase.Duration, this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset, translatedPhrase.Language, translatedPhrase.Confidence, undefined, connectionMessage.textBody, resultProps);\n          if (reason === ResultReason.Canceled) {\n            const cancelReason = EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);\n            const cancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus);\n            yield this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n          } else {\n            if (!(this.privRequestSession.isSpeechEnded && reason === ResultReason.NoMatch && translatedPhrase.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n              const ev = new TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n              if (!!this.privTranslationRecognizer.recognized) {\n                try {\n                  this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\n                  /* eslint-disable no-empty */\n                } catch (error) {\n                  // Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n            }\n            // report result to promise.\n            if (!!this.privSuccessCallback) {\n              try {\n                this.privSuccessCallback(result);\n              } catch (e) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(e);\n                }\n              }\n              // Only invoke the call back once.\n              // and if it's successful don't invoke the\n              // error after that.\n              this.privSuccessCallback = undefined;\n              this.privErrorCallback = undefined;\n            }\n          }\n          processed = true;\n        }\n      });\n      const handleTranslationHypothesis = (hypothesis, resultProperties) => {\n        const result = this.fireEventForResult(hypothesis, resultProperties);\n        this.privRequestSession.onHypothesis(this.privRequestSession.currentTurnAudioOffset + result.offset);\n        if (!!this.privTranslationRecognizer.recognizing) {\n          try {\n            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n      };\n      if (connectionMessage.messageType === MessageType.Text) {\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n      }\n      switch (connectionMessage.path.toLowerCase()) {\n        case \"translation.hypothesis\":\n          handleTranslationHypothesis(TranslationHypothesis.fromJSON(connectionMessage.textBody), resultProps);\n          break;\n        case \"translation.response\":\n          const phrase = JSON.parse(connectionMessage.textBody);\n          if (!!phrase.SpeechPhrase) {\n            yield handleTranslationPhrase(TranslationPhrase.fromTranslationResponse(phrase));\n          } else {\n            const hypothesis = JSON.parse(connectionMessage.textBody);\n            if (!!hypothesis.SpeechHypothesis) {\n              handleTranslationHypothesis(TranslationHypothesis.fromTranslationResponse(hypothesis), resultProps);\n            }\n          }\n          break;\n        case \"translation.phrase\":\n          yield handleTranslationPhrase(TranslationPhrase.fromJSON(connectionMessage.textBody));\n          break;\n        case \"translation.synthesis\":\n          this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);\n          processed = true;\n          break;\n        case \"audio.end\":\n        case \"translation.synthesis.end\":\n          const synthEnd = TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);\n          switch (synthEnd.SynthesisStatus) {\n            case SynthesisStatus.Error:\n              if (!!this.privTranslationRecognizer.synthesizing) {\n                const result = new TranslationSynthesisResult(ResultReason.Canceled, undefined);\n                const retEvent = new TranslationSynthesisEventArgs(result, this.privRequestSession.sessionId);\n                try {\n                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n                  /* eslint-disable no-empty */\n                } catch (error) {\n                  // Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n              if (!!this.privTranslationRecognizer.canceled) {\n                // And raise a canceled event to send the rich(er) error message back.\n                const canceledResult = new TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, CancellationReason.Error, synthEnd.FailureReason, CancellationErrorCode.ServiceError, null);\n                try {\n                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);\n                  /* eslint-disable no-empty */\n                } catch (error) {\n                  // Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n              break;\n            case SynthesisStatus.Success:\n              this.sendSynthesisAudio(undefined, this.privRequestSession.sessionId);\n              break;\n            default:\n              break;\n          }\n          processed = true;\n          break;\n        default:\n          break;\n      }\n      return processed;\n    });\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n    if (!!this.privTranslationRecognizer.canceled) {\n      const cancelEvent = new TranslationRecognitionCanceledEventArgs(sessionId, cancellationReason, error, errorCode, undefined);\n      try {\n        this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n    if (!!this.privSuccessCallback) {\n      const result = new TranslationRecognitionResult(undefined,\n      // Translations\n      requestId, ResultReason.Canceled, undefined,\n      // Text\n      undefined,\n      // Druation\n      undefined,\n      // Offset\n      undefined,\n      // Language\n      undefined,\n      // LanguageDetectionConfidence\n      error, undefined,\n      // Json\n      properties);\n      try {\n        this.privSuccessCallback(result);\n        /* eslint-disable no-empty */\n        this.privSuccessCallback = undefined;\n      } catch (_b) {}\n    }\n  }\n  handleRecognizingCallback(result, duration, sessionId) {\n    try {\n      const ev = new TranslationRecognitionEventArgs(TranslationRecognitionResult.fromSpeechRecognitionResult(result), duration, sessionId);\n      this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, ev);\n      /* eslint-disable no-empty */\n    } catch (error) {\n      // Not going to let errors in the event handler\n      // trip things up.\n    }\n  }\n  handleRecognizedCallback(result, offset, sessionId) {\n    try {\n      const ev = new TranslationRecognitionEventArgs(TranslationRecognitionResult.fromSpeechRecognitionResult(result), offset, sessionId);\n      this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\n    } catch (error) {\n      // Not going to let errors in the event handler\n      // trip things up.\n    }\n  }\n  fireEventForResult(serviceResult, properties) {\n    let translations;\n    if (undefined !== serviceResult.Translation.Translations) {\n      translations = new Translations();\n      for (const translation of serviceResult.Translation.Translations) {\n        translations.set(translation.Language, translation.Text || translation.DisplayText);\n      }\n    }\n    let resultReason;\n    let confidence;\n    if (serviceResult instanceof TranslationPhrase) {\n      if (!!serviceResult.Translation && serviceResult.Translation.TranslationStatus === TranslationStatus.Success) {\n        resultReason = ResultReason.TranslatedSpeech;\n      } else {\n        resultReason = ResultReason.RecognizedSpeech;\n      }\n      confidence = serviceResult.Confidence;\n    } else {\n      resultReason = ResultReason.TranslatingSpeech;\n    }\n    const language = serviceResult.Language;\n    const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const result = new TranslationRecognitionResult(translations, this.privRequestSession.requestId, resultReason, serviceResult.Text, serviceResult.Duration, offset, language, confidence, serviceResult.Translation.FailureReason, JSON.stringify(serviceResult), properties);\n    const ev = new TranslationRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  }\n  sendSynthesisAudio(audio, sessionId) {\n    const reason = undefined === audio ? ResultReason.SynthesizingAudioCompleted : ResultReason.SynthesizingAudio;\n    const result = new TranslationSynthesisResult(reason, audio);\n    const retEvent = new TranslationSynthesisEventArgs(result, sessionId);\n    if (!!this.privTranslationRecognizer.synthesizing) {\n      try {\n        this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\n        /* eslint-disable no-empty */\n      } catch (error) {\n        // Not going to let errors in the event handler\n        // trip things up.\n      }\n    }\n  }\n}","map":{"version":3,"names":["MessageType","TranslationStatus","CancellationErrorCode","CancellationReason","PropertyCollection","PropertyId","ResultReason","TranslationRecognitionCanceledEventArgs","TranslationRecognitionEventArgs","TranslationRecognitionResult","Translations","TranslationSynthesisEventArgs","TranslationSynthesisResult","CancellationErrorCodePropertyName","ConversationServiceRecognizer","EnumTranslation","RecognitionStatus","SynthesisStatus","TranslationHypothesis","TranslationPhrase","TranslationSynthesisEnd","TranslationServiceRecognizer","constructor","authentication","connectionFactory","audioSource","recognizerConfig","translationRecognizer","privTranslationRecognizer","connectionEvents","attach","connectionEvent","name","onConnection","processTypeSpecificMessages","connectionMessage","resultProps","processed","processSpeechMessages","handleTranslationPhrase","translatedPhrase","__awaiter","privRequestSession","onPhraseRecognized","currentTurnAudioOffset","Offset","Duration","Success","result","fireEventForResult","recognized","error","privSuccessCallback","e","privErrorCallback","undefined","reason","implTranslateRecognitionResult","requestId","Text","Language","Confidence","textBody","Canceled","cancelReason","implTranslateCancelResult","cancellationErrorCode","implTranslateCancelErrorCode","cancelRecognitionLocal","implTranslateErrorDetails","isSpeechEnded","NoMatch","InitialSilenceTimeout","ev","offset","sessionId","handleTranslationHypothesis","hypothesis","resultProperties","onHypothesis","recognizing","messageType","setProperty","SpeechServiceResponse_JsonResult","path","toLowerCase","fromJSON","phrase","JSON","parse","SpeechPhrase","fromTranslationResponse","SpeechHypothesis","sendSynthesisAudio","binaryBody","synthEnd","Error","synthesizing","retEvent","canceled","canceledResult","FailureReason","ServiceError","cancelRecognition","cancellationReason","errorCode","properties","cancelEvent","_a","_b","handleRecognizingCallback","duration","fromSpeechRecognitionResult","handleRecognizedCallback","serviceResult","translations","Translation","translation","set","DisplayText","resultReason","confidence","TranslatedSpeech","RecognizedSpeech","TranslatingSpeech","language","stringify","audio","SynthesizingAudioCompleted","SynthesizingAudio"],"sources":["src/common.speech/TranslationServiceRecognizer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionEvent,\r\n    IAudioSource,\r\n    MessageType,\r\n    TranslationStatus,\r\n} from \"../common/Exports.js\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechRecognitionResult,\r\n    TranslationRecognitionCanceledEventArgs,\r\n    TranslationRecognitionEventArgs,\r\n    TranslationRecognitionResult,\r\n    TranslationRecognizer,\r\n    Translations,\r\n    TranslationSynthesisEventArgs,\r\n    TranslationSynthesisResult,\r\n} from \"../sdk/Exports.js\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    ConversationServiceRecognizer,\r\n    EnumTranslation,\r\n    ITranslationHypothesis,\r\n    RecognitionStatus,\r\n    SynthesisStatus,\r\n    TranslationHypothesis,\r\n    TranslationPhrase,\r\n    TranslationSynthesisEnd,\r\n} from \"./Exports.js\";\r\nimport { IAuthentication } from \"./IAuthentication.js\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory.js\";\r\nimport { RecognizerConfig } from \"./RecognizerConfig.js\";\r\nimport { ITranslationPhrase } from \"./ServiceMessages/TranslationPhrase.js\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal.js\";\r\n\r\n// eslint-disable-next-line max-classes-per-file\r\nexport class TranslationServiceRecognizer extends ConversationServiceRecognizer {\r\n    private privTranslationRecognizer: TranslationRecognizer;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        translationRecognizer: TranslationRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer);\r\n        this.privTranslationRecognizer = translationRecognizer;\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\r\n                this.privTranslationRecognizer.onConnection();\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    protected async processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        let processed: boolean = await this.processSpeechMessages(connectionMessage);\r\n        if (processed) {\r\n            return true;\r\n        }\r\n\r\n        const handleTranslationPhrase = async (translatedPhrase: TranslationPhrase): Promise<void> => {\r\n            this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset + translatedPhrase.Duration);\r\n\r\n            if (translatedPhrase.RecognitionStatus === RecognitionStatus.Success) {\r\n\r\n                // OK, the recognition was successful. How'd the translation do?\r\n                const result: TranslationRecognitionEventArgs = this.fireEventForResult(translatedPhrase, resultProps);\r\n                if (!!this.privTranslationRecognizer.recognized) {\r\n                    try {\r\n                        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n\r\n                // report result to promise.\r\n                if (!!this.privSuccessCallback) {\r\n                    try {\r\n                        this.privSuccessCallback(result.result);\r\n                    } catch (e) {\r\n                        if (!!this.privErrorCallback) {\r\n                            this.privErrorCallback(e as string);\r\n                        }\r\n                    }\r\n                    // Only invoke the call back once.\r\n                    // and if it's successful don't invoke the\r\n                    // error after that.\r\n                    this.privSuccessCallback = undefined;\r\n                    this.privErrorCallback = undefined;\r\n                }\r\n            } else {\r\n                const reason: ResultReason = EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);\r\n\r\n                const result = new TranslationRecognitionResult(\r\n                    undefined,\r\n                    this.privRequestSession.requestId,\r\n                    reason,\r\n                    translatedPhrase.Text,\r\n                    translatedPhrase.Duration,\r\n                    this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset,\r\n                    translatedPhrase.Language,\r\n                    translatedPhrase.Confidence,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                if (reason === ResultReason.Canceled) {\r\n                    const cancelReason: CancellationReason = EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);\r\n                    const cancellationErrorCode: CancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus);\r\n\r\n                    await this.cancelRecognitionLocal(\r\n                        cancelReason,\r\n                        cancellationErrorCode,\r\n                        EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\r\n\r\n                } else {\r\n                    if (!(this.privRequestSession.isSpeechEnded && reason === ResultReason.NoMatch && translatedPhrase.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\r\n                        const ev = new TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privTranslationRecognizer.recognized) {\r\n                            try {\r\n                                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\r\n                                /* eslint-disable no-empty */\r\n                            } catch (error) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // report result to promise.\r\n                    if (!!this.privSuccessCallback) {\r\n                        try {\r\n                            this.privSuccessCallback(result);\r\n                        } catch (e) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(e as string);\r\n                            }\r\n                        }\r\n                        // Only invoke the call back once.\r\n                        // and if it's successful don't invoke the\r\n                        // error after that.\r\n                        this.privSuccessCallback = undefined;\r\n                        this.privErrorCallback = undefined;\r\n                    }\r\n                }\r\n                processed = true;\r\n            }\r\n\r\n        };\r\n\r\n        const handleTranslationHypothesis = (hypothesis: TranslationHypothesis, resultProperties: PropertyCollection): void => {\r\n            const result: TranslationRecognitionEventArgs = this.fireEventForResult(hypothesis, resultProperties);\r\n            this.privRequestSession.onHypothesis(this.privRequestSession.currentTurnAudioOffset + result.offset);\r\n\r\n            if (!!this.privTranslationRecognizer.recognizing) {\r\n                try {\r\n                    this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);\r\n                    /* eslint-disable no-empty */\r\n                } catch (error) {\r\n                    // Not going to let errors in the event handler\r\n                    // trip things up.\r\n                }\r\n            }\r\n            processed = true;\r\n        };\r\n\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"translation.hypothesis\":\r\n                handleTranslationHypothesis(TranslationHypothesis.fromJSON(connectionMessage.textBody), resultProps);\r\n                break;\r\n\r\n            case \"translation.response\":\r\n                const phrase: { SpeechPhrase: ITranslationPhrase } = JSON.parse(connectionMessage.textBody) as { SpeechPhrase: ITranslationPhrase };\r\n                if (!!phrase.SpeechPhrase) {\r\n                    await handleTranslationPhrase(TranslationPhrase.fromTranslationResponse(phrase));\r\n                } else {\r\n                    const hypothesis: { SpeechHypothesis: ITranslationHypothesis } = JSON.parse(connectionMessage.textBody) as { SpeechHypothesis: ITranslationHypothesis };\r\n                    if (!!hypothesis.SpeechHypothesis) {\r\n                        handleTranslationHypothesis(TranslationHypothesis.fromTranslationResponse(hypothesis), resultProps);\r\n                    }\r\n                }\r\n                break;\r\n            case \"translation.phrase\":\r\n                await handleTranslationPhrase(TranslationPhrase.fromJSON(connectionMessage.textBody));\r\n                break;\r\n\r\n            case \"translation.synthesis\":\r\n                this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);\r\n                processed = true;\r\n                break;\r\n\r\n            case \"audio.end\":\r\n            case \"translation.synthesis.end\":\r\n                const synthEnd: TranslationSynthesisEnd = TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);\r\n\r\n                switch (synthEnd.SynthesisStatus) {\r\n                    case SynthesisStatus.Error:\r\n                        if (!!this.privTranslationRecognizer.synthesizing) {\r\n                            const result = new TranslationSynthesisResult(ResultReason.Canceled, undefined);\r\n                            const retEvent: TranslationSynthesisEventArgs = new TranslationSynthesisEventArgs(result, this.privRequestSession.sessionId);\r\n\r\n                            try {\r\n                                this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\r\n                                /* eslint-disable no-empty */\r\n                            } catch (error) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n\r\n                        if (!!this.privTranslationRecognizer.canceled) {\r\n                            // And raise a canceled event to send the rich(er) error message back.\r\n                            const canceledResult: TranslationRecognitionCanceledEventArgs = new TranslationRecognitionCanceledEventArgs(\r\n                                this.privRequestSession.sessionId,\r\n                                CancellationReason.Error,\r\n                                synthEnd.FailureReason,\r\n                                CancellationErrorCode.ServiceError,\r\n                                null);\r\n\r\n                            try {\r\n                                this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);\r\n                                /* eslint-disable no-empty */\r\n                            } catch (error) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n                        break;\r\n                    case SynthesisStatus.Success:\r\n                        this.sendSynthesisAudio(undefined, this.privRequestSession.sessionId);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n                processed = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n        if (!!this.privTranslationRecognizer.canceled) {\r\n\r\n            const cancelEvent: TranslationRecognitionCanceledEventArgs = new TranslationRecognitionCanceledEventArgs(\r\n                sessionId,\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined);\r\n\r\n            try {\r\n                this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            const result: TranslationRecognitionResult = new TranslationRecognitionResult(\r\n                undefined, // Translations\r\n                requestId,\r\n                ResultReason.Canceled,\r\n                undefined, // Text\r\n                undefined, // Druation\r\n                undefined, // Offset\r\n                undefined, // Language\r\n                undefined, // LanguageDetectionConfidence\r\n                error,\r\n                undefined, // Json\r\n                properties);\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                /* eslint-disable no-empty */\r\n                this.privSuccessCallback = undefined;\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    protected handleRecognizingCallback(result: SpeechRecognitionResult, duration: number, sessionId: string): void {\r\n        try {\r\n            const ev = new TranslationRecognitionEventArgs(TranslationRecognitionResult.fromSpeechRecognitionResult(result), duration, sessionId);\r\n            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, ev);\r\n            /* eslint-disable no-empty */\r\n        } catch (error) {\r\n            // Not going to let errors in the event handler\r\n            // trip things up.\r\n        }\r\n    }\r\n\r\n    protected handleRecognizedCallback(result: SpeechRecognitionResult, offset: number, sessionId: string): void {\r\n        try {\r\n            const ev = new TranslationRecognitionEventArgs(TranslationRecognitionResult.fromSpeechRecognitionResult(result), offset, sessionId);\r\n            this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);\r\n        } catch (error) {\r\n            // Not going to let errors in the event handler\r\n            // trip things up.\r\n        }\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: TranslationHypothesis | TranslationPhrase, properties: PropertyCollection): TranslationRecognitionEventArgs {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResult.Translation.Translations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResult.Translation.Translations) {\r\n                translations.set(translation.Language, translation.Text || translation.DisplayText);\r\n            }\r\n        }\r\n\r\n        let resultReason: ResultReason;\r\n        let confidence: string;\r\n        if (serviceResult instanceof TranslationPhrase) {\r\n            if (!!serviceResult.Translation && serviceResult.Translation.TranslationStatus === TranslationStatus.Success) {\r\n                resultReason = ResultReason.TranslatedSpeech;\r\n            } else {\r\n                resultReason = ResultReason.RecognizedSpeech;\r\n            }\r\n            confidence = serviceResult.Confidence;\r\n        } else {\r\n            resultReason = ResultReason.TranslatingSpeech;\r\n        }\r\n        const language = serviceResult.Language;\r\n\r\n        const offset: number = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new TranslationRecognitionResult(\r\n            translations,\r\n            this.privRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.Text,\r\n            serviceResult.Duration,\r\n            offset,\r\n            language,\r\n            confidence,\r\n            serviceResult.Translation.FailureReason,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new TranslationRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n\r\n    private sendSynthesisAudio(audio: ArrayBuffer, sessionId: string): void {\r\n        const reason = (undefined === audio) ? ResultReason.SynthesizingAudioCompleted : ResultReason.SynthesizingAudio;\r\n        const result = new TranslationSynthesisResult(reason, audio);\r\n        const retEvent: TranslationSynthesisEventArgs = new TranslationSynthesisEventArgs(result, sessionId);\r\n\r\n        if (!!this.privTranslationRecognizer.synthesizing) {\r\n            try {\r\n                this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch (error) {\r\n                // Not going to let errors in the event handler\r\n                // trip things up.\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}